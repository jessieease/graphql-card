{"ast":null,"code":"\"use strict\";\n\nvar __assign = void 0 && (void 0).__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar graphql_1 = require(\"graphql\");\n\nfunction getNewStack(root, schema, stack) {\n  var path = stack.getIn(['field', 'path']);\n  var splittedPath = path.split('/');\n  var pointer = null;\n  var count = 0;\n  var lastPointer = null;\n  var y = -1;\n\n  var _loop_1 = function _loop_1() {\n    var currentPath = splittedPath.shift();\n\n    if (count === 0) {\n      pointer = root[currentPath];\n      y = Object.keys(root).indexOf(currentPath);\n    } else {\n      var argFound = pointer.args.find(function (arg) {\n        return arg.name === currentPath;\n      });\n      lastPointer = pointer;\n\n      if (argFound) {\n        pointer = argFound;\n      } else {\n        if (pointer.type.ofType) {\n          pointer = getDeeperType(pointer.type.ofType);\n        }\n\n        if (pointer.type) {\n          pointer = pointer.type;\n        }\n\n        pointer = pointer.getFields()[currentPath] || pointer.getInterfaces().find(function (i) {\n          return i.name === currentPath;\n        });\n      }\n    }\n\n    if (lastPointer) {\n      y = getElementIndex(schema, lastPointer, pointer);\n    }\n\n    count++;\n  };\n\n  while (splittedPath.length > 0) {\n    _loop_1();\n  }\n\n  if (!pointer) {\n    return null;\n  }\n\n  pointer.path = path;\n  pointer.parent = lastPointer;\n  return stack.merge({\n    y: y,\n    field: pointer\n  });\n}\n\nexports.getNewStack = getNewStack; // Return the deeper type found on object\n// For example [[[Company]!]!]! will return only Company\n\nfunction getDeeperType(type, depth) {\n  if (depth === void 0) {\n    depth = 0;\n  }\n\n  if (type.ofType && depth < 5) {\n    return getDeeperType(type.ofType, depth + 1);\n  }\n\n  return type;\n}\n\nexports.getDeeperType = getDeeperType;\n\nfunction getRootMap(schema) {\n  return __assign(__assign(__assign({}, schema.getQueryType().getFields()), schema.getMutationType && schema.getMutationType() && schema.getMutationType().getFields()), schema.getSubscriptionType && schema.getSubscriptionType() && schema.getSubscriptionType().getFields());\n}\n\nexports.getRootMap = getRootMap; // Serialize schema to get root object\n\nfunction serializeRoot(schema) {\n  var obj = {\n    queries: [],\n    mutations: [],\n    subscriptions: []\n  };\n  var queryType = schema.getQueryType();\n  var queryFieldMap = queryType.getFields();\n  obj.queries = Object.keys(queryFieldMap).map(function (fieldName) {\n    var field = queryFieldMap[fieldName];\n    field.path = fieldName;\n    field.parent = null;\n    return field;\n  });\n  var mutationType = schema.getMutationType && schema.getMutationType();\n\n  if (mutationType) {\n    var mutationFieldMap_1 = mutationType.getFields();\n    obj.mutations = Object.keys(mutationFieldMap_1).map(function (fieldName) {\n      var field = mutationFieldMap_1[fieldName];\n      field.path = fieldName;\n      field.parent = null;\n      return field;\n    });\n  }\n\n  ;\n  window.ss = schema;\n  var subscriptionType = schema.getSubscriptionType && schema.getSubscriptionType();\n\n  if (subscriptionType) {\n    var subscriptionFieldMap_1 = subscriptionType.getFields();\n    obj.subscriptions = Object.keys(subscriptionFieldMap_1).map(function (fieldName) {\n      var field = subscriptionFieldMap_1[fieldName];\n      field.path = fieldName;\n      field.parent = null;\n      return field;\n    });\n  }\n\n  return obj;\n}\n\nexports.serializeRoot = serializeRoot; // Return element that match index on root object\n\nfunction getElementRoot(obj, index) {\n  var i = 0;\n\n  if (obj.queries[index + i]) {\n    return obj.queries[index + i];\n  }\n\n  i += obj.queries.length;\n\n  if (obj.mutations[index - i]) {\n    return obj.mutations[index - i];\n  }\n\n  i += obj.mutations.length;\n\n  if (obj.subscriptions[index - i]) {\n    return obj.subscriptions[index - i];\n  }\n}\n\nexports.getElementRoot = getElementRoot; // Serialize field\n\nfunction serialize(schema, field) {\n  var obj = {\n    fields: [],\n    interfaces: [],\n    args: [],\n    implementations: []\n  };\n  var type = field.type || field;\n  var isVarType = graphql_1.isType(type);\n\n  if (type.ofType) {\n    type = getDeeperType(type.ofType);\n  } // Get fields\n\n\n  if (type.getFields) {\n    var fieldMap_1 = type.getFields();\n    obj.fields = Object.keys(fieldMap_1).map(function (name) {\n      var f = fieldMap_1[name];\n      f.parent = field;\n      f.path = field.path + (\"/\" + name);\n      return f;\n    });\n  } // Get interfaces\n\n\n  if (type instanceof graphql_1.GraphQLObjectType) {\n    obj.interfaces = type.getInterfaces();\n  } // Get args\n\n\n  obj.args = field.args ? field.args : []; // Get implementations\n\n  if (isVarType && type instanceof graphql_1.GraphQLInterfaceType) {\n    obj.implementations = schema.getPossibleTypes(type);\n  }\n\n  return obj;\n}\n\nexports.serialize = serialize; // Return element that match index on object\n\nfunction getElement(obj, index) {\n  var i = 0;\n\n  if (obj.interfaces[index + i]) {\n    return obj.interfaces[index + i];\n  }\n\n  i += obj.interfaces.length;\n\n  if (obj.fields[index - i]) {\n    return obj.fields[index - i];\n  }\n\n  i += obj.fields.length;\n\n  if (obj.args[index - i]) {\n    return obj.args[index - i];\n  }\n\n  i += obj.args.length;\n\n  if (obj.implementations[index - i]) {\n    return obj.implementations[index - i];\n  }\n}\n\nexports.getElement = getElement;\n\nfunction getElementIndex(schema, main, element) {\n  var obj = serialize(schema, main);\n  var interfaceIndex = obj.interfaces.indexOf(element);\n\n  if (interfaceIndex > -1) {\n    return interfaceIndex;\n  }\n\n  var fieldsIndex = obj.fields.indexOf(element);\n\n  if (fieldsIndex > -1) {\n    return obj.interfaces.length + fieldsIndex;\n  }\n\n  var argsIndex = obj.args.indexOf(element);\n\n  if (argsIndex > -1) {\n    return obj.interfaces.length + obj.fields.length + argsIndex;\n  }\n\n  var implementationIndex = obj.implementations.indexOf(element);\n\n  if (implementationIndex > -1) {\n    return obj.interfaces.length + obj.fields.length + obj.args.length + implementationIndex;\n  }\n\n  return 0;\n}\n\nexports.getElementIndex = getElementIndex;","map":{"version":3,"sources":["/Users/wubo/Desktop/card-design/card-design/node_modules/graphql-playground-react/lib/components/Playground/util/stack.js"],"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","defineProperty","exports","value","graphql_1","require","getNewStack","root","schema","stack","path","getIn","splittedPath","split","pointer","count","lastPointer","y","_loop_1","currentPath","shift","keys","indexOf","argFound","args","find","arg","name","type","ofType","getDeeperType","getFields","getInterfaces","getElementIndex","parent","merge","field","depth","getRootMap","getQueryType","getMutationType","getSubscriptionType","serializeRoot","obj","queries","mutations","subscriptions","queryType","queryFieldMap","map","fieldName","mutationType","mutationFieldMap_1","window","ss","subscriptionType","subscriptionFieldMap_1","getElementRoot","index","serialize","fields","interfaces","implementations","isVarType","isType","fieldMap_1","f","GraphQLObjectType","GraphQLInterfaceType","getPossibleTypes","getElement","main","element","interfaceIndex","fieldsIndex","argsIndex","implementationIndex"],"mappings":"AAAA;;AAEA,IAAIA,QAAQ,GAAG,KAAK,CAAL,IAAU,CAAC,KAAK,CAAN,EAASA,QAAnB,IAA+B,YAAY;AACxDA,EAAAA,QAAQ,GAAGC,MAAM,CAACC,MAAP,IAAiB,UAAUC,CAAV,EAAa;AACvC,SAAK,IAAIC,CAAJ,EAAOC,CAAC,GAAG,CAAX,EAAcC,CAAC,GAAGC,SAAS,CAACC,MAAjC,EAAyCH,CAAC,GAAGC,CAA7C,EAAgDD,CAAC,EAAjD,EAAqD;AACnDD,MAAAA,CAAC,GAAGG,SAAS,CAACF,CAAD,CAAb;;AAEA,WAAK,IAAII,CAAT,IAAcL,CAAd,EAAiB;AACf,YAAIH,MAAM,CAACS,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCR,CAArC,EAAwCK,CAAxC,CAAJ,EAAgDN,CAAC,CAACM,CAAD,CAAD,GAAOL,CAAC,CAACK,CAAD,CAAR;AACjD;AACF;;AAED,WAAON,CAAP;AACD,GAVD;;AAYA,SAAOH,QAAQ,CAACa,KAAT,CAAe,IAAf,EAAqBN,SAArB,CAAP;AACD,CAdD;;AAgBAN,MAAM,CAACa,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;;AAIA,IAAIC,SAAS,GAAGC,OAAO,CAAC,SAAD,CAAvB;;AAEA,SAASC,WAAT,CAAqBC,IAArB,EAA2BC,MAA3B,EAAmCC,KAAnC,EAA0C;AACxC,MAAIC,IAAI,GAAGD,KAAK,CAACE,KAAN,CAAY,CAAC,OAAD,EAAU,MAAV,CAAZ,CAAX;AACA,MAAIC,YAAY,GAAGF,IAAI,CAACG,KAAL,CAAW,GAAX,CAAnB;AACA,MAAIC,OAAO,GAAG,IAAd;AACA,MAAIC,KAAK,GAAG,CAAZ;AACA,MAAIC,WAAW,GAAG,IAAlB;AACA,MAAIC,CAAC,GAAG,CAAC,CAAT;;AAEA,MAAIC,OAAO,GAAG,SAASA,OAAT,GAAmB;AAC/B,QAAIC,WAAW,GAAGP,YAAY,CAACQ,KAAb,EAAlB;;AAEA,QAAIL,KAAK,KAAK,CAAd,EAAiB;AACfD,MAAAA,OAAO,GAAGP,IAAI,CAACY,WAAD,CAAd;AACAF,MAAAA,CAAC,GAAG7B,MAAM,CAACiC,IAAP,CAAYd,IAAZ,EAAkBe,OAAlB,CAA0BH,WAA1B,CAAJ;AACD,KAHD,MAGO;AACL,UAAII,QAAQ,GAAGT,OAAO,CAACU,IAAR,CAAaC,IAAb,CAAkB,UAAUC,GAAV,EAAe;AAC9C,eAAOA,GAAG,CAACC,IAAJ,KAAaR,WAApB;AACD,OAFc,CAAf;AAGAH,MAAAA,WAAW,GAAGF,OAAd;;AAEA,UAAIS,QAAJ,EAAc;AACZT,QAAAA,OAAO,GAAGS,QAAV;AACD,OAFD,MAEO;AACL,YAAIT,OAAO,CAACc,IAAR,CAAaC,MAAjB,EAAyB;AACvBf,UAAAA,OAAO,GAAGgB,aAAa,CAAChB,OAAO,CAACc,IAAR,CAAaC,MAAd,CAAvB;AACD;;AAED,YAAIf,OAAO,CAACc,IAAZ,EAAkB;AAChBd,UAAAA,OAAO,GAAGA,OAAO,CAACc,IAAlB;AACD;;AAEDd,QAAAA,OAAO,GAAGA,OAAO,CAACiB,SAAR,GAAoBZ,WAApB,KAAoCL,OAAO,CAACkB,aAAR,GAAwBP,IAAxB,CAA6B,UAAUjC,CAAV,EAAa;AACtF,iBAAOA,CAAC,CAACmC,IAAF,KAAWR,WAAlB;AACD,SAF6C,CAA9C;AAGD;AACF;;AAED,QAAIH,WAAJ,EAAiB;AACfC,MAAAA,CAAC,GAAGgB,eAAe,CAACzB,MAAD,EAASQ,WAAT,EAAsBF,OAAtB,CAAnB;AACD;;AAEDC,IAAAA,KAAK;AACN,GAlCD;;AAoCA,SAAOH,YAAY,CAACjB,MAAb,GAAsB,CAA7B,EAAgC;AAC9BuB,IAAAA,OAAO;AACR;;AAED,MAAI,CAACJ,OAAL,EAAc;AACZ,WAAO,IAAP;AACD;;AAEDA,EAAAA,OAAO,CAACJ,IAAR,GAAeA,IAAf;AACAI,EAAAA,OAAO,CAACoB,MAAR,GAAiBlB,WAAjB;AACA,SAAOP,KAAK,CAAC0B,KAAN,CAAY;AACjBlB,IAAAA,CAAC,EAAEA,CADc;AAEjBmB,IAAAA,KAAK,EAAEtB;AAFU,GAAZ,CAAP;AAID;;AAEDZ,OAAO,CAACI,WAAR,GAAsBA,WAAtB,C,CAAmC;AACnC;;AAEA,SAASwB,aAAT,CAAuBF,IAAvB,EAA6BS,KAA7B,EAAoC;AAClC,MAAIA,KAAK,KAAK,KAAK,CAAnB,EAAsB;AACpBA,IAAAA,KAAK,GAAG,CAAR;AACD;;AAED,MAAIT,IAAI,CAACC,MAAL,IAAeQ,KAAK,GAAG,CAA3B,EAA8B;AAC5B,WAAOP,aAAa,CAACF,IAAI,CAACC,MAAN,EAAcQ,KAAK,GAAG,CAAtB,CAApB;AACD;;AAED,SAAOT,IAAP;AACD;;AAED1B,OAAO,CAAC4B,aAAR,GAAwBA,aAAxB;;AAEA,SAASQ,UAAT,CAAoB9B,MAApB,EAA4B;AAC1B,SAAOrB,QAAQ,CAACA,QAAQ,CAACA,QAAQ,CAAC,EAAD,EAAKqB,MAAM,CAAC+B,YAAP,GAAsBR,SAAtB,EAAL,CAAT,EAAkDvB,MAAM,CAACgC,eAAP,IAA0BhC,MAAM,CAACgC,eAAP,EAA1B,IAAsDhC,MAAM,CAACgC,eAAP,GAAyBT,SAAzB,EAAxG,CAAT,EAAwJvB,MAAM,CAACiC,mBAAP,IAA8BjC,MAAM,CAACiC,mBAAP,EAA9B,IAA8DjC,MAAM,CAACiC,mBAAP,GAA6BV,SAA7B,EAAtN,CAAf;AACD;;AAED7B,OAAO,CAACoC,UAAR,GAAqBA,UAArB,C,CAAiC;;AAEjC,SAASI,aAAT,CAAuBlC,MAAvB,EAA+B;AAC7B,MAAImC,GAAG,GAAG;AACRC,IAAAA,OAAO,EAAE,EADD;AAERC,IAAAA,SAAS,EAAE,EAFH;AAGRC,IAAAA,aAAa,EAAE;AAHP,GAAV;AAKA,MAAIC,SAAS,GAAGvC,MAAM,CAAC+B,YAAP,EAAhB;AACA,MAAIS,aAAa,GAAGD,SAAS,CAAChB,SAAV,EAApB;AACAY,EAAAA,GAAG,CAACC,OAAJ,GAAcxD,MAAM,CAACiC,IAAP,CAAY2B,aAAZ,EAA2BC,GAA3B,CAA+B,UAAUC,SAAV,EAAqB;AAChE,QAAId,KAAK,GAAGY,aAAa,CAACE,SAAD,CAAzB;AACAd,IAAAA,KAAK,CAAC1B,IAAN,GAAawC,SAAb;AACAd,IAAAA,KAAK,CAACF,MAAN,GAAe,IAAf;AACA,WAAOE,KAAP;AACD,GALa,CAAd;AAMA,MAAIe,YAAY,GAAG3C,MAAM,CAACgC,eAAP,IAA0BhC,MAAM,CAACgC,eAAP,EAA7C;;AAEA,MAAIW,YAAJ,EAAkB;AAChB,QAAIC,kBAAkB,GAAGD,YAAY,CAACpB,SAAb,EAAzB;AACAY,IAAAA,GAAG,CAACE,SAAJ,GAAgBzD,MAAM,CAACiC,IAAP,CAAY+B,kBAAZ,EAAgCH,GAAhC,CAAoC,UAAUC,SAAV,EAAqB;AACvE,UAAId,KAAK,GAAGgB,kBAAkB,CAACF,SAAD,CAA9B;AACAd,MAAAA,KAAK,CAAC1B,IAAN,GAAawC,SAAb;AACAd,MAAAA,KAAK,CAACF,MAAN,GAAe,IAAf;AACA,aAAOE,KAAP;AACD,KALe,CAAhB;AAMD;;AAED;AACAiB,EAAAA,MAAM,CAACC,EAAP,GAAY9C,MAAZ;AACA,MAAI+C,gBAAgB,GAAG/C,MAAM,CAACiC,mBAAP,IAA8BjC,MAAM,CAACiC,mBAAP,EAArD;;AAEA,MAAIc,gBAAJ,EAAsB;AACpB,QAAIC,sBAAsB,GAAGD,gBAAgB,CAACxB,SAAjB,EAA7B;AACAY,IAAAA,GAAG,CAACG,aAAJ,GAAoB1D,MAAM,CAACiC,IAAP,CAAYmC,sBAAZ,EAAoCP,GAApC,CAAwC,UAAUC,SAAV,EAAqB;AAC/E,UAAId,KAAK,GAAGoB,sBAAsB,CAACN,SAAD,CAAlC;AACAd,MAAAA,KAAK,CAAC1B,IAAN,GAAawC,SAAb;AACAd,MAAAA,KAAK,CAACF,MAAN,GAAe,IAAf;AACA,aAAOE,KAAP;AACD,KALmB,CAApB;AAMD;;AAED,SAAOO,GAAP;AACD;;AAEDzC,OAAO,CAACwC,aAAR,GAAwBA,aAAxB,C,CAAuC;;AAEvC,SAASe,cAAT,CAAwBd,GAAxB,EAA6Be,KAA7B,EAAoC;AAClC,MAAIlE,CAAC,GAAG,CAAR;;AAEA,MAAImD,GAAG,CAACC,OAAJ,CAAYc,KAAK,GAAGlE,CAApB,CAAJ,EAA4B;AAC1B,WAAOmD,GAAG,CAACC,OAAJ,CAAYc,KAAK,GAAGlE,CAApB,CAAP;AACD;;AAEDA,EAAAA,CAAC,IAAImD,GAAG,CAACC,OAAJ,CAAYjD,MAAjB;;AAEA,MAAIgD,GAAG,CAACE,SAAJ,CAAca,KAAK,GAAGlE,CAAtB,CAAJ,EAA8B;AAC5B,WAAOmD,GAAG,CAACE,SAAJ,CAAca,KAAK,GAAGlE,CAAtB,CAAP;AACD;;AAEDA,EAAAA,CAAC,IAAImD,GAAG,CAACE,SAAJ,CAAclD,MAAnB;;AAEA,MAAIgD,GAAG,CAACG,aAAJ,CAAkBY,KAAK,GAAGlE,CAA1B,CAAJ,EAAkC;AAChC,WAAOmD,GAAG,CAACG,aAAJ,CAAkBY,KAAK,GAAGlE,CAA1B,CAAP;AACD;AACF;;AAEDU,OAAO,CAACuD,cAAR,GAAyBA,cAAzB,C,CAAyC;;AAEzC,SAASE,SAAT,CAAmBnD,MAAnB,EAA2B4B,KAA3B,EAAkC;AAChC,MAAIO,GAAG,GAAG;AACRiB,IAAAA,MAAM,EAAE,EADA;AAERC,IAAAA,UAAU,EAAE,EAFJ;AAGRrC,IAAAA,IAAI,EAAE,EAHE;AAIRsC,IAAAA,eAAe,EAAE;AAJT,GAAV;AAMA,MAAIlC,IAAI,GAAGQ,KAAK,CAACR,IAAN,IAAcQ,KAAzB;AACA,MAAI2B,SAAS,GAAG3D,SAAS,CAAC4D,MAAV,CAAiBpC,IAAjB,CAAhB;;AAEA,MAAIA,IAAI,CAACC,MAAT,EAAiB;AACfD,IAAAA,IAAI,GAAGE,aAAa,CAACF,IAAI,CAACC,MAAN,CAApB;AACD,GAZ+B,CAY9B;;;AAGF,MAAID,IAAI,CAACG,SAAT,EAAoB;AAClB,QAAIkC,UAAU,GAAGrC,IAAI,CAACG,SAAL,EAAjB;AACAY,IAAAA,GAAG,CAACiB,MAAJ,GAAaxE,MAAM,CAACiC,IAAP,CAAY4C,UAAZ,EAAwBhB,GAAxB,CAA4B,UAAUtB,IAAV,EAAgB;AACvD,UAAIuC,CAAC,GAAGD,UAAU,CAACtC,IAAD,CAAlB;AACAuC,MAAAA,CAAC,CAAChC,MAAF,GAAWE,KAAX;AACA8B,MAAAA,CAAC,CAACxD,IAAF,GAAS0B,KAAK,CAAC1B,IAAN,IAAc,MAAMiB,IAApB,CAAT;AACA,aAAOuC,CAAP;AACD,KALY,CAAb;AAMD,GAvB+B,CAuB9B;;;AAGF,MAAItC,IAAI,YAAYxB,SAAS,CAAC+D,iBAA9B,EAAiD;AAC/CxB,IAAAA,GAAG,CAACkB,UAAJ,GAAiBjC,IAAI,CAACI,aAAL,EAAjB;AACD,GA5B+B,CA4B9B;;;AAGFW,EAAAA,GAAG,CAACnB,IAAJ,GAAWY,KAAK,CAACZ,IAAN,GAAaY,KAAK,CAACZ,IAAnB,GAA0B,EAArC,CA/BgC,CA+BS;;AAEzC,MAAIuC,SAAS,IAAInC,IAAI,YAAYxB,SAAS,CAACgE,oBAA3C,EAAiE;AAC/DzB,IAAAA,GAAG,CAACmB,eAAJ,GAAsBtD,MAAM,CAAC6D,gBAAP,CAAwBzC,IAAxB,CAAtB;AACD;;AAED,SAAOe,GAAP;AACD;;AAEDzC,OAAO,CAACyD,SAAR,GAAoBA,SAApB,C,CAA+B;;AAE/B,SAASW,UAAT,CAAoB3B,GAApB,EAAyBe,KAAzB,EAAgC;AAC9B,MAAIlE,CAAC,GAAG,CAAR;;AAEA,MAAImD,GAAG,CAACkB,UAAJ,CAAeH,KAAK,GAAGlE,CAAvB,CAAJ,EAA+B;AAC7B,WAAOmD,GAAG,CAACkB,UAAJ,CAAeH,KAAK,GAAGlE,CAAvB,CAAP;AACD;;AAEDA,EAAAA,CAAC,IAAImD,GAAG,CAACkB,UAAJ,CAAelE,MAApB;;AAEA,MAAIgD,GAAG,CAACiB,MAAJ,CAAWF,KAAK,GAAGlE,CAAnB,CAAJ,EAA2B;AACzB,WAAOmD,GAAG,CAACiB,MAAJ,CAAWF,KAAK,GAAGlE,CAAnB,CAAP;AACD;;AAEDA,EAAAA,CAAC,IAAImD,GAAG,CAACiB,MAAJ,CAAWjE,MAAhB;;AAEA,MAAIgD,GAAG,CAACnB,IAAJ,CAASkC,KAAK,GAAGlE,CAAjB,CAAJ,EAAyB;AACvB,WAAOmD,GAAG,CAACnB,IAAJ,CAASkC,KAAK,GAAGlE,CAAjB,CAAP;AACD;;AAEDA,EAAAA,CAAC,IAAImD,GAAG,CAACnB,IAAJ,CAAS7B,MAAd;;AAEA,MAAIgD,GAAG,CAACmB,eAAJ,CAAoBJ,KAAK,GAAGlE,CAA5B,CAAJ,EAAoC;AAClC,WAAOmD,GAAG,CAACmB,eAAJ,CAAoBJ,KAAK,GAAGlE,CAA5B,CAAP;AACD;AACF;;AAEDU,OAAO,CAACoE,UAAR,GAAqBA,UAArB;;AAEA,SAASrC,eAAT,CAAyBzB,MAAzB,EAAiC+D,IAAjC,EAAuCC,OAAvC,EAAgD;AAC9C,MAAI7B,GAAG,GAAGgB,SAAS,CAACnD,MAAD,EAAS+D,IAAT,CAAnB;AACA,MAAIE,cAAc,GAAG9B,GAAG,CAACkB,UAAJ,CAAevC,OAAf,CAAuBkD,OAAvB,CAArB;;AAEA,MAAIC,cAAc,GAAG,CAAC,CAAtB,EAAyB;AACvB,WAAOA,cAAP;AACD;;AAED,MAAIC,WAAW,GAAG/B,GAAG,CAACiB,MAAJ,CAAWtC,OAAX,CAAmBkD,OAAnB,CAAlB;;AAEA,MAAIE,WAAW,GAAG,CAAC,CAAnB,EAAsB;AACpB,WAAO/B,GAAG,CAACkB,UAAJ,CAAelE,MAAf,GAAwB+E,WAA/B;AACD;;AAED,MAAIC,SAAS,GAAGhC,GAAG,CAACnB,IAAJ,CAASF,OAAT,CAAiBkD,OAAjB,CAAhB;;AAEA,MAAIG,SAAS,GAAG,CAAC,CAAjB,EAAoB;AAClB,WAAOhC,GAAG,CAACkB,UAAJ,CAAelE,MAAf,GAAwBgD,GAAG,CAACiB,MAAJ,CAAWjE,MAAnC,GAA4CgF,SAAnD;AACD;;AAED,MAAIC,mBAAmB,GAAGjC,GAAG,CAACmB,eAAJ,CAAoBxC,OAApB,CAA4BkD,OAA5B,CAA1B;;AAEA,MAAII,mBAAmB,GAAG,CAAC,CAA3B,EAA8B;AAC5B,WAAOjC,GAAG,CAACkB,UAAJ,CAAelE,MAAf,GAAwBgD,GAAG,CAACiB,MAAJ,CAAWjE,MAAnC,GAA4CgD,GAAG,CAACnB,IAAJ,CAAS7B,MAArD,GAA8DiF,mBAArE;AACD;;AAED,SAAO,CAAP;AACD;;AAED1E,OAAO,CAAC+B,eAAR,GAA0BA,eAA1B","sourcesContent":["\"use strict\";\n\nvar __assign = void 0 && (void 0).__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar graphql_1 = require(\"graphql\");\n\nfunction getNewStack(root, schema, stack) {\n  var path = stack.getIn(['field', 'path']);\n  var splittedPath = path.split('/');\n  var pointer = null;\n  var count = 0;\n  var lastPointer = null;\n  var y = -1;\n\n  var _loop_1 = function _loop_1() {\n    var currentPath = splittedPath.shift();\n\n    if (count === 0) {\n      pointer = root[currentPath];\n      y = Object.keys(root).indexOf(currentPath);\n    } else {\n      var argFound = pointer.args.find(function (arg) {\n        return arg.name === currentPath;\n      });\n      lastPointer = pointer;\n\n      if (argFound) {\n        pointer = argFound;\n      } else {\n        if (pointer.type.ofType) {\n          pointer = getDeeperType(pointer.type.ofType);\n        }\n\n        if (pointer.type) {\n          pointer = pointer.type;\n        }\n\n        pointer = pointer.getFields()[currentPath] || pointer.getInterfaces().find(function (i) {\n          return i.name === currentPath;\n        });\n      }\n    }\n\n    if (lastPointer) {\n      y = getElementIndex(schema, lastPointer, pointer);\n    }\n\n    count++;\n  };\n\n  while (splittedPath.length > 0) {\n    _loop_1();\n  }\n\n  if (!pointer) {\n    return null;\n  }\n\n  pointer.path = path;\n  pointer.parent = lastPointer;\n  return stack.merge({\n    y: y,\n    field: pointer\n  });\n}\n\nexports.getNewStack = getNewStack; // Return the deeper type found on object\n// For example [[[Company]!]!]! will return only Company\n\nfunction getDeeperType(type, depth) {\n  if (depth === void 0) {\n    depth = 0;\n  }\n\n  if (type.ofType && depth < 5) {\n    return getDeeperType(type.ofType, depth + 1);\n  }\n\n  return type;\n}\n\nexports.getDeeperType = getDeeperType;\n\nfunction getRootMap(schema) {\n  return __assign(__assign(__assign({}, schema.getQueryType().getFields()), schema.getMutationType && schema.getMutationType() && schema.getMutationType().getFields()), schema.getSubscriptionType && schema.getSubscriptionType() && schema.getSubscriptionType().getFields());\n}\n\nexports.getRootMap = getRootMap; // Serialize schema to get root object\n\nfunction serializeRoot(schema) {\n  var obj = {\n    queries: [],\n    mutations: [],\n    subscriptions: []\n  };\n  var queryType = schema.getQueryType();\n  var queryFieldMap = queryType.getFields();\n  obj.queries = Object.keys(queryFieldMap).map(function (fieldName) {\n    var field = queryFieldMap[fieldName];\n    field.path = fieldName;\n    field.parent = null;\n    return field;\n  });\n  var mutationType = schema.getMutationType && schema.getMutationType();\n\n  if (mutationType) {\n    var mutationFieldMap_1 = mutationType.getFields();\n    obj.mutations = Object.keys(mutationFieldMap_1).map(function (fieldName) {\n      var field = mutationFieldMap_1[fieldName];\n      field.path = fieldName;\n      field.parent = null;\n      return field;\n    });\n  }\n\n  ;\n  window.ss = schema;\n  var subscriptionType = schema.getSubscriptionType && schema.getSubscriptionType();\n\n  if (subscriptionType) {\n    var subscriptionFieldMap_1 = subscriptionType.getFields();\n    obj.subscriptions = Object.keys(subscriptionFieldMap_1).map(function (fieldName) {\n      var field = subscriptionFieldMap_1[fieldName];\n      field.path = fieldName;\n      field.parent = null;\n      return field;\n    });\n  }\n\n  return obj;\n}\n\nexports.serializeRoot = serializeRoot; // Return element that match index on root object\n\nfunction getElementRoot(obj, index) {\n  var i = 0;\n\n  if (obj.queries[index + i]) {\n    return obj.queries[index + i];\n  }\n\n  i += obj.queries.length;\n\n  if (obj.mutations[index - i]) {\n    return obj.mutations[index - i];\n  }\n\n  i += obj.mutations.length;\n\n  if (obj.subscriptions[index - i]) {\n    return obj.subscriptions[index - i];\n  }\n}\n\nexports.getElementRoot = getElementRoot; // Serialize field\n\nfunction serialize(schema, field) {\n  var obj = {\n    fields: [],\n    interfaces: [],\n    args: [],\n    implementations: []\n  };\n  var type = field.type || field;\n  var isVarType = graphql_1.isType(type);\n\n  if (type.ofType) {\n    type = getDeeperType(type.ofType);\n  } // Get fields\n\n\n  if (type.getFields) {\n    var fieldMap_1 = type.getFields();\n    obj.fields = Object.keys(fieldMap_1).map(function (name) {\n      var f = fieldMap_1[name];\n      f.parent = field;\n      f.path = field.path + (\"/\" + name);\n      return f;\n    });\n  } // Get interfaces\n\n\n  if (type instanceof graphql_1.GraphQLObjectType) {\n    obj.interfaces = type.getInterfaces();\n  } // Get args\n\n\n  obj.args = field.args ? field.args : []; // Get implementations\n\n  if (isVarType && type instanceof graphql_1.GraphQLInterfaceType) {\n    obj.implementations = schema.getPossibleTypes(type);\n  }\n\n  return obj;\n}\n\nexports.serialize = serialize; // Return element that match index on object\n\nfunction getElement(obj, index) {\n  var i = 0;\n\n  if (obj.interfaces[index + i]) {\n    return obj.interfaces[index + i];\n  }\n\n  i += obj.interfaces.length;\n\n  if (obj.fields[index - i]) {\n    return obj.fields[index - i];\n  }\n\n  i += obj.fields.length;\n\n  if (obj.args[index - i]) {\n    return obj.args[index - i];\n  }\n\n  i += obj.args.length;\n\n  if (obj.implementations[index - i]) {\n    return obj.implementations[index - i];\n  }\n}\n\nexports.getElement = getElement;\n\nfunction getElementIndex(schema, main, element) {\n  var obj = serialize(schema, main);\n  var interfaceIndex = obj.interfaces.indexOf(element);\n\n  if (interfaceIndex > -1) {\n    return interfaceIndex;\n  }\n\n  var fieldsIndex = obj.fields.indexOf(element);\n\n  if (fieldsIndex > -1) {\n    return obj.interfaces.length + fieldsIndex;\n  }\n\n  var argsIndex = obj.args.indexOf(element);\n\n  if (argsIndex > -1) {\n    return obj.interfaces.length + obj.fields.length + argsIndex;\n  }\n\n  var implementationIndex = obj.implementations.indexOf(element);\n\n  if (implementationIndex > -1) {\n    return obj.interfaces.length + obj.fields.length + obj.args.length + implementationIndex;\n  }\n\n  return 0;\n}\n\nexports.getElementIndex = getElementIndex;"]},"metadata":{},"sourceType":"script"}