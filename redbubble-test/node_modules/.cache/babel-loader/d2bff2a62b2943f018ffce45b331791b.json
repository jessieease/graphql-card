{"ast":null,"code":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n/**\n * Supported keybindings:\n *   Too many to list. Refer to defaultKeymap below.\n *\n * Supported Ex commands:\n *   Refer to defaultExCommandMap below.\n *\n * Registers: unnamed, -, ., :, /, _, a-z, A-Z, 0-9\n *   (Does not respect the special case for number registers when delete\n *    operator is made with these commands: %, (, ),  , /, ?, n, N, {, } )\n *   TODO: Implement the remaining registers.\n *\n * Marks: a-z, A-Z, and 0-9\n *   TODO: Implement the remaining special marks. They have more complex\n *       behavior.\n *\n * Events:\n *  'vim-mode-change' - raised on the editor anytime the current mode changes,\n *                      Event object: {mode: \"visual\", subMode: \"linewise\"}\n *\n * Code structure:\n *  1. Default keymap\n *  2. Variable declarations and short basic helpers\n *  3. Instance (External API) implementation\n *  4. Internal state tracking objects (input state, counter) implementation\n *     and instantiation\n *  5. Key handler (the main command dispatcher) implementation\n *  6. Motion, operator, and action implementations\n *  7. Helper functions for the key handler, motions, operators, and actions\n *  8. Set up Vim to work as a keymap for CodeMirror.\n *  9. Ex command implementations.\n */\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../lib/codemirror\"), require(\"../addon/search/searchcursor\"), require(\"../addon/dialog/dialog\"), require(\"../addon/edit/matchbrackets.js\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../lib/codemirror\", \"../addon/search/searchcursor\", \"../addon/dialog/dialog\", \"../addon/edit/matchbrackets\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  'use strict';\n\n  var defaultKeymap = [// Key to key mapping. This goes first to make it possible to override\n  // existing mappings.\n  {\n    keys: '<Left>',\n    type: 'keyToKey',\n    toKeys: 'h'\n  }, {\n    keys: '<Right>',\n    type: 'keyToKey',\n    toKeys: 'l'\n  }, {\n    keys: '<Up>',\n    type: 'keyToKey',\n    toKeys: 'k'\n  }, {\n    keys: '<Down>',\n    type: 'keyToKey',\n    toKeys: 'j'\n  }, {\n    keys: '<Space>',\n    type: 'keyToKey',\n    toKeys: 'l'\n  }, {\n    keys: '<BS>',\n    type: 'keyToKey',\n    toKeys: 'h',\n    context: 'normal'\n  }, {\n    keys: '<Del>',\n    type: 'keyToKey',\n    toKeys: 'x',\n    context: 'normal'\n  }, {\n    keys: '<C-Space>',\n    type: 'keyToKey',\n    toKeys: 'W'\n  }, {\n    keys: '<C-BS>',\n    type: 'keyToKey',\n    toKeys: 'B',\n    context: 'normal'\n  }, {\n    keys: '<S-Space>',\n    type: 'keyToKey',\n    toKeys: 'w'\n  }, {\n    keys: '<S-BS>',\n    type: 'keyToKey',\n    toKeys: 'b',\n    context: 'normal'\n  }, {\n    keys: '<C-n>',\n    type: 'keyToKey',\n    toKeys: 'j'\n  }, {\n    keys: '<C-p>',\n    type: 'keyToKey',\n    toKeys: 'k'\n  }, {\n    keys: '<C-[>',\n    type: 'keyToKey',\n    toKeys: '<Esc>'\n  }, {\n    keys: '<C-c>',\n    type: 'keyToKey',\n    toKeys: '<Esc>'\n  }, {\n    keys: '<C-[>',\n    type: 'keyToKey',\n    toKeys: '<Esc>',\n    context: 'insert'\n  }, {\n    keys: '<C-c>',\n    type: 'keyToKey',\n    toKeys: '<Esc>',\n    context: 'insert'\n  }, {\n    keys: 's',\n    type: 'keyToKey',\n    toKeys: 'cl',\n    context: 'normal'\n  }, {\n    keys: 's',\n    type: 'keyToKey',\n    toKeys: 'c',\n    context: 'visual'\n  }, {\n    keys: 'S',\n    type: 'keyToKey',\n    toKeys: 'cc',\n    context: 'normal'\n  }, {\n    keys: 'S',\n    type: 'keyToKey',\n    toKeys: 'VdO',\n    context: 'visual'\n  }, {\n    keys: '<Home>',\n    type: 'keyToKey',\n    toKeys: '0'\n  }, {\n    keys: '<End>',\n    type: 'keyToKey',\n    toKeys: '$'\n  }, {\n    keys: '<PageUp>',\n    type: 'keyToKey',\n    toKeys: '<C-b>'\n  }, {\n    keys: '<PageDown>',\n    type: 'keyToKey',\n    toKeys: '<C-f>'\n  }, {\n    keys: '<CR>',\n    type: 'keyToKey',\n    toKeys: 'j^',\n    context: 'normal'\n  }, {\n    keys: '<Ins>',\n    type: 'action',\n    action: 'toggleOverwrite',\n    context: 'insert'\n  }, // Motions\n  {\n    keys: 'H',\n    type: 'motion',\n    motion: 'moveToTopLine',\n    motionArgs: {\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'M',\n    type: 'motion',\n    motion: 'moveToMiddleLine',\n    motionArgs: {\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'L',\n    type: 'motion',\n    motion: 'moveToBottomLine',\n    motionArgs: {\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'h',\n    type: 'motion',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: 'l',\n    type: 'motion',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: 'j',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: true,\n      linewise: true\n    }\n  }, {\n    keys: 'k',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: false,\n      linewise: true\n    }\n  }, {\n    keys: 'gj',\n    type: 'motion',\n    motion: 'moveByDisplayLines',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: 'gk',\n    type: 'motion',\n    motion: 'moveByDisplayLines',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: 'w',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: true,\n      wordEnd: false\n    }\n  }, {\n    keys: 'W',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: true,\n      wordEnd: false,\n      bigWord: true\n    }\n  }, {\n    keys: 'e',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: true,\n      wordEnd: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'E',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: true,\n      wordEnd: true,\n      bigWord: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'b',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: false\n    }\n  }, {\n    keys: 'B',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: false,\n      bigWord: true\n    }\n  }, {\n    keys: 'ge',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'gE',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: true,\n      bigWord: true,\n      inclusive: true\n    }\n  }, {\n    keys: '{',\n    type: 'motion',\n    motion: 'moveByParagraph',\n    motionArgs: {\n      forward: false,\n      toJumplist: true\n    }\n  }, {\n    keys: '}',\n    type: 'motion',\n    motion: 'moveByParagraph',\n    motionArgs: {\n      forward: true,\n      toJumplist: true\n    }\n  }, {\n    keys: '(',\n    type: 'motion',\n    motion: 'moveBySentence',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: ')',\n    type: 'motion',\n    motion: 'moveBySentence',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: '<C-f>',\n    type: 'motion',\n    motion: 'moveByPage',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: '<C-b>',\n    type: 'motion',\n    motion: 'moveByPage',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: '<C-d>',\n    type: 'motion',\n    motion: 'moveByScroll',\n    motionArgs: {\n      forward: true,\n      explicitRepeat: true\n    }\n  }, {\n    keys: '<C-u>',\n    type: 'motion',\n    motion: 'moveByScroll',\n    motionArgs: {\n      forward: false,\n      explicitRepeat: true\n    }\n  }, {\n    keys: 'gg',\n    type: 'motion',\n    motion: 'moveToLineOrEdgeOfDocument',\n    motionArgs: {\n      forward: false,\n      explicitRepeat: true,\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'G',\n    type: 'motion',\n    motion: 'moveToLineOrEdgeOfDocument',\n    motionArgs: {\n      forward: true,\n      explicitRepeat: true,\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: '0',\n    type: 'motion',\n    motion: 'moveToStartOfLine'\n  }, {\n    keys: '^',\n    type: 'motion',\n    motion: 'moveToFirstNonWhiteSpaceCharacter'\n  }, {\n    keys: '+',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: true,\n      toFirstChar: true\n    }\n  }, {\n    keys: '-',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: false,\n      toFirstChar: true\n    }\n  }, {\n    keys: '_',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: true,\n      toFirstChar: true,\n      repeatOffset: -1\n    }\n  }, {\n    keys: '$',\n    type: 'motion',\n    motion: 'moveToEol',\n    motionArgs: {\n      inclusive: true\n    }\n  }, {\n    keys: '%',\n    type: 'motion',\n    motion: 'moveToMatchedSymbol',\n    motionArgs: {\n      inclusive: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'f<character>',\n    type: 'motion',\n    motion: 'moveToCharacter',\n    motionArgs: {\n      forward: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'F<character>',\n    type: 'motion',\n    motion: 'moveToCharacter',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: 't<character>',\n    type: 'motion',\n    motion: 'moveTillCharacter',\n    motionArgs: {\n      forward: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'T<character>',\n    type: 'motion',\n    motion: 'moveTillCharacter',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: ';',\n    type: 'motion',\n    motion: 'repeatLastCharacterSearch',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: ',',\n    type: 'motion',\n    motion: 'repeatLastCharacterSearch',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: '\\'<character>',\n    type: 'motion',\n    motion: 'goToMark',\n    motionArgs: {\n      toJumplist: true,\n      linewise: true\n    }\n  }, {\n    keys: '`<character>',\n    type: 'motion',\n    motion: 'goToMark',\n    motionArgs: {\n      toJumplist: true\n    }\n  }, {\n    keys: ']`',\n    type: 'motion',\n    motion: 'jumpToMark',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: '[`',\n    type: 'motion',\n    motion: 'jumpToMark',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: ']\\'',\n    type: 'motion',\n    motion: 'jumpToMark',\n    motionArgs: {\n      forward: true,\n      linewise: true\n    }\n  }, {\n    keys: '[\\'',\n    type: 'motion',\n    motion: 'jumpToMark',\n    motionArgs: {\n      forward: false,\n      linewise: true\n    }\n  }, // the next two aren't motions but must come before more general motion declarations\n  {\n    keys: ']p',\n    type: 'action',\n    action: 'paste',\n    isEdit: true,\n    actionArgs: {\n      after: true,\n      isEdit: true,\n      matchIndent: true\n    }\n  }, {\n    keys: '[p',\n    type: 'action',\n    action: 'paste',\n    isEdit: true,\n    actionArgs: {\n      after: false,\n      isEdit: true,\n      matchIndent: true\n    }\n  }, {\n    keys: ']<character>',\n    type: 'motion',\n    motion: 'moveToSymbol',\n    motionArgs: {\n      forward: true,\n      toJumplist: true\n    }\n  }, {\n    keys: '[<character>',\n    type: 'motion',\n    motion: 'moveToSymbol',\n    motionArgs: {\n      forward: false,\n      toJumplist: true\n    }\n  }, {\n    keys: '|',\n    type: 'motion',\n    motion: 'moveToColumn'\n  }, {\n    keys: 'o',\n    type: 'motion',\n    motion: 'moveToOtherHighlightedEnd',\n    context: 'visual'\n  }, {\n    keys: 'O',\n    type: 'motion',\n    motion: 'moveToOtherHighlightedEnd',\n    motionArgs: {\n      sameLine: true\n    },\n    context: 'visual'\n  }, // Operators\n  {\n    keys: 'd',\n    type: 'operator',\n    operator: 'delete'\n  }, {\n    keys: 'y',\n    type: 'operator',\n    operator: 'yank'\n  }, {\n    keys: 'c',\n    type: 'operator',\n    operator: 'change'\n  }, {\n    keys: '=',\n    type: 'operator',\n    operator: 'indentAuto'\n  }, {\n    keys: '>',\n    type: 'operator',\n    operator: 'indent',\n    operatorArgs: {\n      indentRight: true\n    }\n  }, {\n    keys: '<',\n    type: 'operator',\n    operator: 'indent',\n    operatorArgs: {\n      indentRight: false\n    }\n  }, {\n    keys: 'g~',\n    type: 'operator',\n    operator: 'changeCase'\n  }, {\n    keys: 'gu',\n    type: 'operator',\n    operator: 'changeCase',\n    operatorArgs: {\n      toLower: true\n    },\n    isEdit: true\n  }, {\n    keys: 'gU',\n    type: 'operator',\n    operator: 'changeCase',\n    operatorArgs: {\n      toLower: false\n    },\n    isEdit: true\n  }, {\n    keys: 'n',\n    type: 'motion',\n    motion: 'findNext',\n    motionArgs: {\n      forward: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'N',\n    type: 'motion',\n    motion: 'findNext',\n    motionArgs: {\n      forward: false,\n      toJumplist: true\n    }\n  }, {\n    keys: 'gn',\n    type: 'motion',\n    motion: 'findAndSelectNextInclusive',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: 'gN',\n    type: 'motion',\n    motion: 'findAndSelectNextInclusive',\n    motionArgs: {\n      forward: false\n    }\n  }, // Operator-Motion dual commands\n  {\n    keys: 'x',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: true\n    },\n    operatorMotionArgs: {\n      visualLine: false\n    }\n  }, {\n    keys: 'X',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: false\n    },\n    operatorMotionArgs: {\n      visualLine: true\n    }\n  }, {\n    keys: 'D',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveToEol',\n    motionArgs: {\n      inclusive: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'D',\n    type: 'operator',\n    operator: 'delete',\n    operatorArgs: {\n      linewise: true\n    },\n    context: 'visual'\n  }, {\n    keys: 'Y',\n    type: 'operatorMotion',\n    operator: 'yank',\n    motion: 'expandToLine',\n    motionArgs: {\n      linewise: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'Y',\n    type: 'operator',\n    operator: 'yank',\n    operatorArgs: {\n      linewise: true\n    },\n    context: 'visual'\n  }, {\n    keys: 'C',\n    type: 'operatorMotion',\n    operator: 'change',\n    motion: 'moveToEol',\n    motionArgs: {\n      inclusive: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'C',\n    type: 'operator',\n    operator: 'change',\n    operatorArgs: {\n      linewise: true\n    },\n    context: 'visual'\n  }, {\n    keys: '~',\n    type: 'operatorMotion',\n    operator: 'changeCase',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: true\n    },\n    operatorArgs: {\n      shouldMoveCursor: true\n    },\n    context: 'normal'\n  }, {\n    keys: '~',\n    type: 'operator',\n    operator: 'changeCase',\n    context: 'visual'\n  }, {\n    keys: '<C-w>',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: false\n    },\n    context: 'insert'\n  }, //ignore C-w in normal mode\n  {\n    keys: '<C-w>',\n    type: 'idle',\n    context: 'normal'\n  }, // Actions\n  {\n    keys: '<C-i>',\n    type: 'action',\n    action: 'jumpListWalk',\n    actionArgs: {\n      forward: true\n    }\n  }, {\n    keys: '<C-o>',\n    type: 'action',\n    action: 'jumpListWalk',\n    actionArgs: {\n      forward: false\n    }\n  }, {\n    keys: '<C-e>',\n    type: 'action',\n    action: 'scroll',\n    actionArgs: {\n      forward: true,\n      linewise: true\n    }\n  }, {\n    keys: '<C-y>',\n    type: 'action',\n    action: 'scroll',\n    actionArgs: {\n      forward: false,\n      linewise: true\n    }\n  }, {\n    keys: 'a',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'charAfter'\n    },\n    context: 'normal'\n  }, {\n    keys: 'A',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'eol'\n    },\n    context: 'normal'\n  }, {\n    keys: 'A',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'endOfSelectedArea'\n    },\n    context: 'visual'\n  }, {\n    keys: 'i',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'inplace'\n    },\n    context: 'normal'\n  }, {\n    keys: 'gi',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'lastEdit'\n    },\n    context: 'normal'\n  }, {\n    keys: 'I',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'firstNonBlank'\n    },\n    context: 'normal'\n  }, {\n    keys: 'gI',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'bol'\n    },\n    context: 'normal'\n  }, {\n    keys: 'I',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'startOfSelectedArea'\n    },\n    context: 'visual'\n  }, {\n    keys: 'o',\n    type: 'action',\n    action: 'newLineAndEnterInsertMode',\n    isEdit: true,\n    interlaceInsertRepeat: true,\n    actionArgs: {\n      after: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'O',\n    type: 'action',\n    action: 'newLineAndEnterInsertMode',\n    isEdit: true,\n    interlaceInsertRepeat: true,\n    actionArgs: {\n      after: false\n    },\n    context: 'normal'\n  }, {\n    keys: 'v',\n    type: 'action',\n    action: 'toggleVisualMode'\n  }, {\n    keys: 'V',\n    type: 'action',\n    action: 'toggleVisualMode',\n    actionArgs: {\n      linewise: true\n    }\n  }, {\n    keys: '<C-v>',\n    type: 'action',\n    action: 'toggleVisualMode',\n    actionArgs: {\n      blockwise: true\n    }\n  }, {\n    keys: '<C-q>',\n    type: 'action',\n    action: 'toggleVisualMode',\n    actionArgs: {\n      blockwise: true\n    }\n  }, {\n    keys: 'gv',\n    type: 'action',\n    action: 'reselectLastSelection'\n  }, {\n    keys: 'J',\n    type: 'action',\n    action: 'joinLines',\n    isEdit: true\n  }, {\n    keys: 'gJ',\n    type: 'action',\n    action: 'joinLines',\n    actionArgs: {\n      keepSpaces: true\n    },\n    isEdit: true\n  }, {\n    keys: 'p',\n    type: 'action',\n    action: 'paste',\n    isEdit: true,\n    actionArgs: {\n      after: true,\n      isEdit: true\n    }\n  }, {\n    keys: 'P',\n    type: 'action',\n    action: 'paste',\n    isEdit: true,\n    actionArgs: {\n      after: false,\n      isEdit: true\n    }\n  }, {\n    keys: 'r<character>',\n    type: 'action',\n    action: 'replace',\n    isEdit: true\n  }, {\n    keys: '@<character>',\n    type: 'action',\n    action: 'replayMacro'\n  }, {\n    keys: 'q<character>',\n    type: 'action',\n    action: 'enterMacroRecordMode'\n  }, // Handle Replace-mode as a special case of insert mode.\n  {\n    keys: 'R',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      replace: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'R',\n    type: 'operator',\n    operator: 'change',\n    operatorArgs: {\n      linewise: true,\n      fullLine: true\n    },\n    context: 'visual',\n    exitVisualBlock: true\n  }, {\n    keys: 'u',\n    type: 'action',\n    action: 'undo',\n    context: 'normal'\n  }, {\n    keys: 'u',\n    type: 'operator',\n    operator: 'changeCase',\n    operatorArgs: {\n      toLower: true\n    },\n    context: 'visual',\n    isEdit: true\n  }, {\n    keys: 'U',\n    type: 'operator',\n    operator: 'changeCase',\n    operatorArgs: {\n      toLower: false\n    },\n    context: 'visual',\n    isEdit: true\n  }, {\n    keys: '<C-r>',\n    type: 'action',\n    action: 'redo'\n  }, {\n    keys: 'm<character>',\n    type: 'action',\n    action: 'setMark'\n  }, {\n    keys: '\"<character>',\n    type: 'action',\n    action: 'setRegister'\n  }, {\n    keys: 'zz',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'center'\n    }\n  }, {\n    keys: 'z.',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'center'\n    },\n    motion: 'moveToFirstNonWhiteSpaceCharacter'\n  }, {\n    keys: 'zt',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'top'\n    }\n  }, {\n    keys: 'z<CR>',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'top'\n    },\n    motion: 'moveToFirstNonWhiteSpaceCharacter'\n  }, {\n    keys: 'z-',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'bottom'\n    }\n  }, {\n    keys: 'zb',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'bottom'\n    },\n    motion: 'moveToFirstNonWhiteSpaceCharacter'\n  }, {\n    keys: '.',\n    type: 'action',\n    action: 'repeatLastEdit'\n  }, {\n    keys: '<C-a>',\n    type: 'action',\n    action: 'incrementNumberToken',\n    isEdit: true,\n    actionArgs: {\n      increase: true,\n      backtrack: false\n    }\n  }, {\n    keys: '<C-x>',\n    type: 'action',\n    action: 'incrementNumberToken',\n    isEdit: true,\n    actionArgs: {\n      increase: false,\n      backtrack: false\n    }\n  }, {\n    keys: '<C-t>',\n    type: 'action',\n    action: 'indent',\n    actionArgs: {\n      indentRight: true\n    },\n    context: 'insert'\n  }, {\n    keys: '<C-d>',\n    type: 'action',\n    action: 'indent',\n    actionArgs: {\n      indentRight: false\n    },\n    context: 'insert'\n  }, // Text object motions\n  {\n    keys: 'a<character>',\n    type: 'motion',\n    motion: 'textObjectManipulation'\n  }, {\n    keys: 'i<character>',\n    type: 'motion',\n    motion: 'textObjectManipulation',\n    motionArgs: {\n      textObjectInner: true\n    }\n  }, // Search\n  {\n    keys: '/',\n    type: 'search',\n    searchArgs: {\n      forward: true,\n      querySrc: 'prompt',\n      toJumplist: true\n    }\n  }, {\n    keys: '?',\n    type: 'search',\n    searchArgs: {\n      forward: false,\n      querySrc: 'prompt',\n      toJumplist: true\n    }\n  }, {\n    keys: '*',\n    type: 'search',\n    searchArgs: {\n      forward: true,\n      querySrc: 'wordUnderCursor',\n      wholeWordOnly: true,\n      toJumplist: true\n    }\n  }, {\n    keys: '#',\n    type: 'search',\n    searchArgs: {\n      forward: false,\n      querySrc: 'wordUnderCursor',\n      wholeWordOnly: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'g*',\n    type: 'search',\n    searchArgs: {\n      forward: true,\n      querySrc: 'wordUnderCursor',\n      toJumplist: true\n    }\n  }, {\n    keys: 'g#',\n    type: 'search',\n    searchArgs: {\n      forward: false,\n      querySrc: 'wordUnderCursor',\n      toJumplist: true\n    }\n  }, // Ex command\n  {\n    keys: ':',\n    type: 'ex'\n  }];\n  var defaultKeymapLength = defaultKeymap.length;\n  /**\n   * Ex commands\n   * Care must be taken when adding to the default Ex command map. For any\n   * pair of commands that have a shared prefix, at least one of their\n   * shortNames must not match the prefix of the other command.\n   */\n\n  var defaultExCommandMap = [{\n    name: 'colorscheme',\n    shortName: 'colo'\n  }, {\n    name: 'map'\n  }, {\n    name: 'imap',\n    shortName: 'im'\n  }, {\n    name: 'nmap',\n    shortName: 'nm'\n  }, {\n    name: 'vmap',\n    shortName: 'vm'\n  }, {\n    name: 'unmap'\n  }, {\n    name: 'write',\n    shortName: 'w'\n  }, {\n    name: 'undo',\n    shortName: 'u'\n  }, {\n    name: 'redo',\n    shortName: 'red'\n  }, {\n    name: 'set',\n    shortName: 'se'\n  }, {\n    name: 'setlocal',\n    shortName: 'setl'\n  }, {\n    name: 'setglobal',\n    shortName: 'setg'\n  }, {\n    name: 'sort',\n    shortName: 'sor'\n  }, {\n    name: 'substitute',\n    shortName: 's',\n    possiblyAsync: true\n  }, {\n    name: 'nohlsearch',\n    shortName: 'noh'\n  }, {\n    name: 'yank',\n    shortName: 'y'\n  }, {\n    name: 'delmarks',\n    shortName: 'delm'\n  }, {\n    name: 'registers',\n    shortName: 'reg',\n    excludeFromCommandHistory: true\n  }, {\n    name: 'vglobal',\n    shortName: 'v'\n  }, {\n    name: 'global',\n    shortName: 'g'\n  }];\n  var Pos = CodeMirror.Pos;\n\n  var Vim = function () {\n    function enterVimMode(cm) {\n      cm.setOption('disableInput', true);\n      cm.setOption('showCursorWhenSelecting', false);\n      CodeMirror.signal(cm, \"vim-mode-change\", {\n        mode: \"normal\"\n      });\n      cm.on('cursorActivity', onCursorActivity);\n      maybeInitVimState(cm);\n      CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));\n    }\n\n    function leaveVimMode(cm) {\n      cm.setOption('disableInput', false);\n      cm.off('cursorActivity', onCursorActivity);\n      CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));\n      cm.state.vim = null;\n    }\n\n    function detachVimMap(cm, next) {\n      if (this == CodeMirror.keyMap.vim) {\n        CodeMirror.rmClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n\n        if (cm.getOption(\"inputStyle\") == \"contenteditable\" && document.body.style.caretColor != null) {\n          disableFatCursorMark(cm);\n          cm.getInputField().style.caretColor = \"\";\n        }\n      }\n\n      if (!next || next.attach != attachVimMap) leaveVimMode(cm);\n    }\n\n    function attachVimMap(cm, prev) {\n      if (this == CodeMirror.keyMap.vim) {\n        CodeMirror.addClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n\n        if (cm.getOption(\"inputStyle\") == \"contenteditable\" && document.body.style.caretColor != null) {\n          enableFatCursorMark(cm);\n          cm.getInputField().style.caretColor = \"transparent\";\n        }\n      }\n\n      if (!prev || prev.attach != attachVimMap) enterVimMode(cm);\n    }\n\n    function updateFatCursorMark(cm) {\n      if (!cm.state.fatCursorMarks) return;\n      clearFatCursorMark(cm);\n      var ranges = cm.listSelections(),\n          result = [];\n\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n\n        if (range.empty()) {\n          var lineLength = cm.getLine(range.anchor.line).length;\n\n          if (range.anchor.ch < lineLength) {\n            result.push(cm.markText(range.anchor, Pos(range.anchor.line, range.anchor.ch + 1), {\n              className: \"cm-fat-cursor-mark\"\n            }));\n          } else {\n            result.push(cm.markText(Pos(range.anchor.line, lineLength - 1), Pos(range.anchor.line, lineLength), {\n              className: \"cm-fat-cursor-mark\"\n            }));\n          }\n        }\n      }\n\n      cm.state.fatCursorMarks = result;\n    }\n\n    function clearFatCursorMark(cm) {\n      var marks = cm.state.fatCursorMarks;\n      if (marks) for (var i = 0; i < marks.length; i++) marks[i].clear();\n    }\n\n    function enableFatCursorMark(cm) {\n      cm.state.fatCursorMarks = [];\n      updateFatCursorMark(cm);\n      cm.on(\"cursorActivity\", updateFatCursorMark);\n    }\n\n    function disableFatCursorMark(cm) {\n      clearFatCursorMark(cm);\n      cm.off(\"cursorActivity\", updateFatCursorMark); // explicitly set fatCursorMarks to null because event listener above\n      // can be invoke after removing it, if off is called from operation\n\n      cm.state.fatCursorMarks = null;\n    } // Deprecated, simply setting the keymap works again.\n\n\n    CodeMirror.defineOption('vimMode', false, function (cm, val, prev) {\n      if (val && cm.getOption(\"keyMap\") != \"vim\") cm.setOption(\"keyMap\", \"vim\");else if (!val && prev != CodeMirror.Init && /^vim/.test(cm.getOption(\"keyMap\"))) cm.setOption(\"keyMap\", \"default\");\n    });\n\n    function cmKey(key, cm) {\n      if (!cm) {\n        return undefined;\n      }\n\n      if (this[key]) {\n        return this[key];\n      }\n\n      var vimKey = cmKeyToVimKey(key);\n\n      if (!vimKey) {\n        return false;\n      }\n\n      var cmd = CodeMirror.Vim.findKey(cm, vimKey);\n\n      if (typeof cmd == 'function') {\n        CodeMirror.signal(cm, 'vim-keypress', vimKey);\n      }\n\n      return cmd;\n    }\n\n    var modifiers = {\n      Shift: 'S',\n      Ctrl: 'C',\n      Alt: 'A',\n      Cmd: 'D',\n      Mod: 'A',\n      CapsLock: ''\n    };\n    var specialKeys = {\n      Enter: 'CR',\n      Backspace: 'BS',\n      Delete: 'Del',\n      Insert: 'Ins'\n    };\n\n    function cmKeyToVimKey(key) {\n      if (key.charAt(0) == '\\'') {\n        // Keypress character binding of format \"'a'\"\n        return key.charAt(1);\n      }\n\n      var pieces = key.split(/-(?!$)/);\n      var lastPiece = pieces[pieces.length - 1];\n\n      if (pieces.length == 1 && pieces[0].length == 1) {\n        // No-modifier bindings use literal character bindings above. Skip.\n        return false;\n      } else if (pieces.length == 2 && pieces[0] == 'Shift' && lastPiece.length == 1) {\n        // Ignore Shift+char bindings as they should be handled by literal character.\n        return false;\n      }\n\n      var hasCharacter = false;\n\n      for (var i = 0; i < pieces.length; i++) {\n        var piece = pieces[i];\n\n        if (piece in modifiers) {\n          pieces[i] = modifiers[piece];\n        } else {\n          hasCharacter = true;\n        }\n\n        if (piece in specialKeys) {\n          pieces[i] = specialKeys[piece];\n        }\n      }\n\n      if (!hasCharacter) {\n        // Vim does not support modifier only keys.\n        return false;\n      } // TODO: Current bindings expect the character to be lower case, but\n      // it looks like vim key notation uses upper case.\n\n\n      if (isUpperCase(lastPiece)) {\n        pieces[pieces.length - 1] = lastPiece.toLowerCase();\n      }\n\n      return '<' + pieces.join('-') + '>';\n    }\n\n    function getOnPasteFn(cm) {\n      var vim = cm.state.vim;\n\n      if (!vim.onPasteFn) {\n        vim.onPasteFn = function () {\n          if (!vim.insertMode) {\n            cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));\n            actions.enterInsertMode(cm, {}, vim);\n          }\n        };\n      }\n\n      return vim.onPasteFn;\n    }\n\n    var numberRegex = /[\\d]/;\n    var wordCharTest = [CodeMirror.isWordChar, function (ch) {\n      return ch && !CodeMirror.isWordChar(ch) && !/\\s/.test(ch);\n    }],\n        bigWordCharTest = [function (ch) {\n      return /\\S/.test(ch);\n    }];\n\n    function makeKeyRange(start, size) {\n      var keys = [];\n\n      for (var i = start; i < start + size; i++) {\n        keys.push(String.fromCharCode(i));\n      }\n\n      return keys;\n    }\n\n    var upperCaseAlphabet = makeKeyRange(65, 26);\n    var lowerCaseAlphabet = makeKeyRange(97, 26);\n    var numbers = makeKeyRange(48, 10);\n    var validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['<', '>']);\n    var validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['-', '\"', '.', ':', '_', '/']);\n    var upperCaseChars;\n\n    try {\n      upperCaseChars = new RegExp(\"^[\\\\p{Lu}]$\", \"u\");\n    } catch (_) {\n      upperCaseChars = /^[A-Z]$/;\n    }\n\n    function isLine(cm, line) {\n      return line >= cm.firstLine() && line <= cm.lastLine();\n    }\n\n    function isLowerCase(k) {\n      return /^[a-z]$/.test(k);\n    }\n\n    function isMatchableSymbol(k) {\n      return '()[]{}'.indexOf(k) != -1;\n    }\n\n    function isNumber(k) {\n      return numberRegex.test(k);\n    }\n\n    function isUpperCase(k) {\n      return upperCaseChars.test(k);\n    }\n\n    function isWhiteSpaceString(k) {\n      return /^\\s*$/.test(k);\n    }\n\n    function isEndOfSentenceSymbol(k) {\n      return '.?!'.indexOf(k) != -1;\n    }\n\n    function inArray(val, arr) {\n      for (var i = 0; i < arr.length; i++) {\n        if (arr[i] == val) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    var options = {};\n\n    function defineOption(name, defaultValue, type, aliases, callback) {\n      if (defaultValue === undefined && !callback) {\n        throw Error('defaultValue is required unless callback is provided');\n      }\n\n      if (!type) {\n        type = 'string';\n      }\n\n      options[name] = {\n        type: type,\n        defaultValue: defaultValue,\n        callback: callback\n      };\n\n      if (aliases) {\n        for (var i = 0; i < aliases.length; i++) {\n          options[aliases[i]] = options[name];\n        }\n      }\n\n      if (defaultValue) {\n        setOption(name, defaultValue);\n      }\n    }\n\n    function setOption(name, value, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n\n      if (option.type == 'boolean') {\n        if (value && value !== true) {\n          return new Error('Invalid argument: ' + name + '=' + value);\n        } else if (value !== false) {\n          // Boolean options are set to true if value is not defined.\n          value = true;\n        }\n      }\n\n      if (option.callback) {\n        if (scope !== 'local') {\n          option.callback(value, undefined);\n        }\n\n        if (scope !== 'global' && cm) {\n          option.callback(value, cm);\n        }\n      } else {\n        if (scope !== 'local') {\n          option.value = option.type == 'boolean' ? !!value : value;\n        }\n\n        if (scope !== 'global' && cm) {\n          cm.state.vim.options[name] = {\n            value: value\n          };\n        }\n      }\n    }\n\n    function getOption(name, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n\n      if (option.callback) {\n        var local = cm && option.callback(undefined, cm);\n\n        if (scope !== 'global' && local !== undefined) {\n          return local;\n        }\n\n        if (scope !== 'local') {\n          return option.callback();\n        }\n\n        return;\n      } else {\n        var local = scope !== 'global' && cm && cm.state.vim.options[name];\n        return (local || scope !== 'local' && option || {}).value;\n      }\n    }\n\n    defineOption('filetype', undefined, 'string', ['ft'], function (name, cm) {\n      // Option is local. Do nothing for global.\n      if (cm === undefined) {\n        return;\n      } // The 'filetype' option proxies to the CodeMirror 'mode' option.\n\n\n      if (name === undefined) {\n        var mode = cm.getOption('mode');\n        return mode == 'null' ? '' : mode;\n      } else {\n        var mode = name == '' ? 'null' : name;\n        cm.setOption('mode', mode);\n      }\n    });\n\n    var createCircularJumpList = function () {\n      var size = 100;\n      var pointer = -1;\n      var head = 0;\n      var tail = 0;\n      var buffer = new Array(size);\n\n      function add(cm, oldCur, newCur) {\n        var current = pointer % size;\n        var curMark = buffer[current];\n\n        function useNextSlot(cursor) {\n          var next = ++pointer % size;\n          var trashMark = buffer[next];\n\n          if (trashMark) {\n            trashMark.clear();\n          }\n\n          buffer[next] = cm.setBookmark(cursor);\n        }\n\n        if (curMark) {\n          var markPos = curMark.find(); // avoid recording redundant cursor position\n\n          if (markPos && !cursorEqual(markPos, oldCur)) {\n            useNextSlot(oldCur);\n          }\n        } else {\n          useNextSlot(oldCur);\n        }\n\n        useNextSlot(newCur);\n        head = pointer;\n        tail = pointer - size + 1;\n\n        if (tail < 0) {\n          tail = 0;\n        }\n      }\n\n      function move(cm, offset) {\n        pointer += offset;\n\n        if (pointer > head) {\n          pointer = head;\n        } else if (pointer < tail) {\n          pointer = tail;\n        }\n\n        var mark = buffer[(size + pointer) % size]; // skip marks that are temporarily removed from text buffer\n\n        if (mark && !mark.find()) {\n          var inc = offset > 0 ? 1 : -1;\n          var newCur;\n          var oldCur = cm.getCursor();\n\n          do {\n            pointer += inc;\n            mark = buffer[(size + pointer) % size]; // skip marks that are the same as current position\n\n            if (mark && (newCur = mark.find()) && !cursorEqual(oldCur, newCur)) {\n              break;\n            }\n          } while (pointer < head && pointer > tail);\n        }\n\n        return mark;\n      }\n\n      function find(cm, offset) {\n        var oldPointer = pointer;\n        var mark = move(cm, offset);\n        pointer = oldPointer;\n        return mark && mark.find();\n      }\n\n      return {\n        cachedCursor: undefined,\n        //used for # and * jumps\n        add: add,\n        find: find,\n        move: move\n      };\n    }; // Returns an object to track the changes associated insert mode.  It\n    // clones the object that is passed in, or creates an empty object one if\n    // none is provided.\n\n\n    var createInsertModeChanges = function (c) {\n      if (c) {\n        // Copy construction\n        return {\n          changes: c.changes,\n          expectCursorActivityForChange: c.expectCursorActivityForChange\n        };\n      }\n\n      return {\n        // Change list\n        changes: [],\n        // Set to true on change, false on cursorActivity.\n        expectCursorActivityForChange: false\n      };\n    };\n\n    function MacroModeState() {\n      this.latestRegister = undefined;\n      this.isPlaying = false;\n      this.isRecording = false;\n      this.replaySearchQueries = [];\n      this.onRecordingDone = undefined;\n      this.lastInsertModeChanges = createInsertModeChanges();\n    }\n\n    MacroModeState.prototype = {\n      exitMacroRecordMode: function () {\n        var macroModeState = vimGlobalState.macroModeState;\n\n        if (macroModeState.onRecordingDone) {\n          macroModeState.onRecordingDone(); // close dialog\n        }\n\n        macroModeState.onRecordingDone = undefined;\n        macroModeState.isRecording = false;\n      },\n      enterMacroRecordMode: function (cm, registerName) {\n        var register = vimGlobalState.registerController.getRegister(registerName);\n\n        if (register) {\n          register.clear();\n          this.latestRegister = registerName;\n\n          if (cm.openDialog) {\n            this.onRecordingDone = cm.openDialog(document.createTextNode('(recording)[' + registerName + ']'), null, {\n              bottom: true\n            });\n          }\n\n          this.isRecording = true;\n        }\n      }\n    };\n\n    function maybeInitVimState(cm) {\n      if (!cm.state.vim) {\n        // Store instance state in the CodeMirror object.\n        cm.state.vim = {\n          inputState: new InputState(),\n          // Vim's input state that triggered the last edit, used to repeat\n          // motions and operators with '.'.\n          lastEditInputState: undefined,\n          // Vim's action command before the last edit, used to repeat actions\n          // with '.' and insert mode repeat.\n          lastEditActionCommand: undefined,\n          // When using jk for navigation, if you move from a longer line to a\n          // shorter line, the cursor may clip to the end of the shorter line.\n          // If j is pressed again and cursor goes to the next line, the\n          // cursor should go back to its horizontal position on the longer\n          // line if it can. This is to keep track of the horizontal position.\n          lastHPos: -1,\n          // Doing the same with screen-position for gj/gk\n          lastHSPos: -1,\n          // The last motion command run. Cleared if a non-motion command gets\n          // executed in between.\n          lastMotion: null,\n          marks: {},\n          // Mark for rendering fake cursor for visual mode.\n          fakeCursor: null,\n          insertMode: false,\n          // Repeat count for changes made in insert mode, triggered by key\n          // sequences like 3,i. Only exists when insertMode is true.\n          insertModeRepeat: undefined,\n          visualMode: false,\n          // If we are in visual line mode. No effect if visualMode is false.\n          visualLine: false,\n          visualBlock: false,\n          lastSelection: null,\n          lastPastedText: null,\n          sel: {},\n          // Buffer-local/window-local values of vim options.\n          options: {}\n        };\n      }\n\n      return cm.state.vim;\n    }\n\n    var vimGlobalState;\n\n    function resetVimGlobalState() {\n      vimGlobalState = {\n        // The current search query.\n        searchQuery: null,\n        // Whether we are searching backwards.\n        searchIsReversed: false,\n        // Replace part of the last substituted pattern\n        lastSubstituteReplacePart: undefined,\n        jumpList: createCircularJumpList(),\n        macroModeState: new MacroModeState(),\n        // Recording latest f, t, F or T motion command.\n        lastCharacterSearch: {\n          increment: 0,\n          forward: true,\n          selectedCharacter: ''\n        },\n        registerController: new RegisterController({}),\n        // search history buffer\n        searchHistoryController: new HistoryController(),\n        // ex Command history buffer\n        exCommandHistoryController: new HistoryController()\n      };\n\n      for (var optionName in options) {\n        var option = options[optionName];\n        option.value = option.defaultValue;\n      }\n    }\n\n    var lastInsertModeKeyTimer;\n    var vimApi = {\n      buildKeyMap: function () {// TODO: Convert keymap into dictionary format for fast lookup.\n      },\n      // Testing hook, though it might be useful to expose the register\n      // controller anyway.\n      getRegisterController: function () {\n        return vimGlobalState.registerController;\n      },\n      // Testing hook.\n      resetVimGlobalState_: resetVimGlobalState,\n      // Testing hook.\n      getVimGlobalState_: function () {\n        return vimGlobalState;\n      },\n      // Testing hook.\n      maybeInitVimState_: maybeInitVimState,\n      suppressErrorLogging: false,\n      InsertModeKey: InsertModeKey,\n      map: function (lhs, rhs, ctx) {\n        // Add user defined key bindings.\n        exCommandDispatcher.map(lhs, rhs, ctx);\n      },\n      unmap: function (lhs, ctx) {\n        exCommandDispatcher.unmap(lhs, ctx);\n      },\n      // Non-recursive map function.\n      // NOTE: This will not create mappings to key maps that aren't present\n      // in the default key map. See TODO at bottom of function.\n      noremap: function (lhs, rhs, ctx) {\n        function toCtxArray(ctx) {\n          return ctx ? [ctx] : ['normal', 'insert', 'visual'];\n        }\n\n        var ctxsToMap = toCtxArray(ctx); // Look through all actual defaults to find a map candidate.\n\n        var actualLength = defaultKeymap.length,\n            origLength = defaultKeymapLength;\n\n        for (var i = actualLength - origLength; i < actualLength && ctxsToMap.length; i++) {\n          var mapping = defaultKeymap[i]; // Omit mappings that operate in the wrong context(s) and those of invalid type.\n\n          if (mapping.keys == rhs && (!ctx || !mapping.context || mapping.context === ctx) && mapping.type.substr(0, 2) !== 'ex' && mapping.type.substr(0, 3) !== 'key') {\n            // Make a shallow copy of the original keymap entry.\n            var newMapping = {};\n\n            for (var key in mapping) {\n              newMapping[key] = mapping[key];\n            } // Modify it point to the new mapping with the proper context.\n\n\n            newMapping.keys = lhs;\n\n            if (ctx && !newMapping.context) {\n              newMapping.context = ctx;\n            } // Add it to the keymap with a higher priority than the original.\n\n\n            this._mapCommand(newMapping); // Record the mapped contexts as complete.\n\n\n            var mappedCtxs = toCtxArray(mapping.context);\n            ctxsToMap = ctxsToMap.filter(function (el) {\n              return mappedCtxs.indexOf(el) === -1;\n            });\n          }\n        } // TODO: Create non-recursive keyToKey mappings for the unmapped contexts once those exist.\n\n      },\n      // Remove all user-defined mappings for the provided context.\n      mapclear: function (ctx) {\n        // Partition the existing keymap into user-defined and true defaults.\n        var actualLength = defaultKeymap.length,\n            origLength = defaultKeymapLength;\n        var userKeymap = defaultKeymap.slice(0, actualLength - origLength);\n        defaultKeymap = defaultKeymap.slice(actualLength - origLength);\n\n        if (ctx) {\n          // If a specific context is being cleared, we need to keep mappings\n          // from all other contexts.\n          for (var i = userKeymap.length - 1; i >= 0; i--) {\n            var mapping = userKeymap[i];\n\n            if (ctx !== mapping.context) {\n              if (mapping.context) {\n                this._mapCommand(mapping);\n              } else {\n                // `mapping` applies to all contexts so create keymap copies\n                // for each context except the one being cleared.\n                var contexts = ['normal', 'insert', 'visual'];\n\n                for (var j in contexts) {\n                  if (contexts[j] !== ctx) {\n                    var newMapping = {};\n\n                    for (var key in mapping) {\n                      newMapping[key] = mapping[key];\n                    }\n\n                    newMapping.context = contexts[j];\n\n                    this._mapCommand(newMapping);\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n      // TODO: Expose setOption and getOption as instance methods. Need to decide how to namespace\n      // them, or somehow make them work with the existing CodeMirror setOption/getOption API.\n      setOption: setOption,\n      getOption: getOption,\n      defineOption: defineOption,\n      defineEx: function (name, prefix, func) {\n        if (!prefix) {\n          prefix = name;\n        } else if (name.indexOf(prefix) !== 0) {\n          throw new Error('(Vim.defineEx) \"' + prefix + '\" is not a prefix of \"' + name + '\", command not registered');\n        }\n\n        exCommands[name] = func;\n        exCommandDispatcher.commandMap_[prefix] = {\n          name: name,\n          shortName: prefix,\n          type: 'api'\n        };\n      },\n      handleKey: function (cm, key, origin) {\n        var command = this.findKey(cm, key, origin);\n\n        if (typeof command === 'function') {\n          return command();\n        }\n      },\n\n      /**\n       * This is the outermost function called by CodeMirror, after keys have\n       * been mapped to their Vim equivalents.\n       *\n       * Finds a command based on the key (and cached keys if there is a\n       * multi-key sequence). Returns `undefined` if no key is matched, a noop\n       * function if a partial match is found (multi-key), and a function to\n       * execute the bound command if a a key is matched. The function always\n       * returns true.\n       */\n      findKey: function (cm, key, origin) {\n        var vim = maybeInitVimState(cm);\n\n        function handleMacroRecording() {\n          var macroModeState = vimGlobalState.macroModeState;\n\n          if (macroModeState.isRecording) {\n            if (key == 'q') {\n              macroModeState.exitMacroRecordMode();\n              clearInputState(cm);\n              return true;\n            }\n\n            if (origin != 'mapping') {\n              logKey(macroModeState, key);\n            }\n          }\n        }\n\n        function handleEsc() {\n          if (key == '<Esc>') {\n            // Clear input state and get back to normal mode.\n            clearInputState(cm);\n\n            if (vim.visualMode) {\n              exitVisualMode(cm);\n            } else if (vim.insertMode) {\n              exitInsertMode(cm);\n            }\n\n            return true;\n          }\n        }\n\n        function doKeyToKey(keys) {\n          // TODO: prevent infinite recursion.\n          var match;\n\n          while (keys) {\n            // Pull off one command key, which is either a single character\n            // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n            match = /<\\w+-.+?>|<\\w+>|./.exec(keys);\n            key = match[0];\n            keys = keys.substring(match.index + key.length);\n            CodeMirror.Vim.handleKey(cm, key, 'mapping');\n          }\n        }\n\n        function handleKeyInsertMode() {\n          if (handleEsc()) {\n            return true;\n          }\n\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n          var keysAreChars = key.length == 1;\n          var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert'); // Need to check all key substrings in insert mode.\n\n          while (keys.length > 1 && match.type != 'full') {\n            var keys = vim.inputState.keyBuffer = keys.slice(1);\n            var thisMatch = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n\n            if (thisMatch.type != 'none') {\n              match = thisMatch;\n            }\n          }\n\n          if (match.type == 'none') {\n            clearInputState(cm);\n            return false;\n          } else if (match.type == 'partial') {\n            if (lastInsertModeKeyTimer) {\n              window.clearTimeout(lastInsertModeKeyTimer);\n            }\n\n            lastInsertModeKeyTimer = window.setTimeout(function () {\n              if (vim.insertMode && vim.inputState.keyBuffer) {\n                clearInputState(cm);\n              }\n            }, getOption('insertModeEscKeysTimeout'));\n            return !keysAreChars;\n          }\n\n          if (lastInsertModeKeyTimer) {\n            window.clearTimeout(lastInsertModeKeyTimer);\n          }\n\n          if (keysAreChars) {\n            var selections = cm.listSelections();\n\n            for (var i = 0; i < selections.length; i++) {\n              var here = selections[i].head;\n              cm.replaceRange('', offsetCursor(here, 0, -(keys.length - 1)), here, '+input');\n            }\n\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();\n          }\n\n          clearInputState(cm);\n          return match.command;\n        }\n\n        function handleKeyNonInsertMode() {\n          if (handleMacroRecording() || handleEsc()) {\n            return true;\n          }\n\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n\n          if (/^[1-9]\\d*$/.test(keys)) {\n            return true;\n          }\n\n          var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n\n          if (!keysMatcher) {\n            clearInputState(cm);\n            return false;\n          }\n\n          var context = vim.visualMode ? 'visual' : 'normal';\n          var mainKey = keysMatcher[2] || keysMatcher[1];\n\n          if (vim.inputState.operatorShortcut && vim.inputState.operatorShortcut.slice(-1) == mainKey) {\n            // multikey operators act linewise by repeating only the last character\n            mainKey = vim.inputState.operatorShortcut;\n          }\n\n          var match = commandDispatcher.matchCommand(mainKey, defaultKeymap, vim.inputState, context);\n\n          if (match.type == 'none') {\n            clearInputState(cm);\n            return false;\n          } else if (match.type == 'partial') {\n            return true;\n          }\n\n          vim.inputState.keyBuffer = '';\n          var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n\n          if (keysMatcher[1] && keysMatcher[1] != '0') {\n            vim.inputState.pushRepeatDigit(keysMatcher[1]);\n          }\n\n          return match.command;\n        }\n\n        var command;\n\n        if (vim.insertMode) {\n          command = handleKeyInsertMode();\n        } else {\n          command = handleKeyNonInsertMode();\n        }\n\n        if (command === false) {\n          return !vim.insertMode && key.length === 1 ? function () {\n            return true;\n          } : undefined;\n        } else if (command === true) {\n          // TODO: Look into using CodeMirror's multi-key handling.\n          // Return no-op since we are caching the key. Counts as handled, but\n          // don't want act on it just yet.\n          return function () {\n            return true;\n          };\n        } else {\n          return function () {\n            return cm.operation(function () {\n              cm.curOp.isVimOp = true;\n\n              try {\n                if (command.type == 'keyToKey') {\n                  doKeyToKey(command.toKeys);\n                } else {\n                  commandDispatcher.processCommand(cm, vim, command);\n                }\n              } catch (e) {\n                // clear VIM state in case it's in a bad state.\n                cm.state.vim = undefined;\n                maybeInitVimState(cm);\n\n                if (!CodeMirror.Vim.suppressErrorLogging) {\n                  console['log'](e);\n                }\n\n                throw e;\n              }\n\n              return true;\n            });\n          };\n        }\n      },\n      handleEx: function (cm, input) {\n        exCommandDispatcher.processCommand(cm, input);\n      },\n      defineMotion: defineMotion,\n      defineAction: defineAction,\n      defineOperator: defineOperator,\n      mapCommand: mapCommand,\n      _mapCommand: _mapCommand,\n      defineRegister: defineRegister,\n      exitVisualMode: exitVisualMode,\n      exitInsertMode: exitInsertMode\n    }; // Represents the current input state.\n\n    function InputState() {\n      this.prefixRepeat = [];\n      this.motionRepeat = [];\n      this.operator = null;\n      this.operatorArgs = null;\n      this.motion = null;\n      this.motionArgs = null;\n      this.keyBuffer = []; // For matching multi-key commands.\n\n      this.registerName = null; // Defaults to the unnamed register.\n    }\n\n    InputState.prototype.pushRepeatDigit = function (n) {\n      if (!this.operator) {\n        this.prefixRepeat = this.prefixRepeat.concat(n);\n      } else {\n        this.motionRepeat = this.motionRepeat.concat(n);\n      }\n    };\n\n    InputState.prototype.getRepeat = function () {\n      var repeat = 0;\n\n      if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\n        repeat = 1;\n\n        if (this.prefixRepeat.length > 0) {\n          repeat *= parseInt(this.prefixRepeat.join(''), 10);\n        }\n\n        if (this.motionRepeat.length > 0) {\n          repeat *= parseInt(this.motionRepeat.join(''), 10);\n        }\n      }\n\n      return repeat;\n    };\n\n    function clearInputState(cm, reason) {\n      cm.state.vim.inputState = new InputState();\n      CodeMirror.signal(cm, 'vim-command-done', reason);\n    }\n    /*\n     * Register stores information about copy and paste registers.  Besides\n     * text, a register must store whether it is linewise (i.e., when it is\n     * pasted, should it insert itself into a new line, or should the text be\n     * inserted at the cursor position.)\n     */\n\n\n    function Register(text, linewise, blockwise) {\n      this.clear();\n      this.keyBuffer = [text || ''];\n      this.insertModeChanges = [];\n      this.searchQueries = [];\n      this.linewise = !!linewise;\n      this.blockwise = !!blockwise;\n    }\n\n    Register.prototype = {\n      setText: function (text, linewise, blockwise) {\n        this.keyBuffer = [text || ''];\n        this.linewise = !!linewise;\n        this.blockwise = !!blockwise;\n      },\n      pushText: function (text, linewise) {\n        // if this register has ever been set to linewise, use linewise.\n        if (linewise) {\n          if (!this.linewise) {\n            this.keyBuffer.push('\\n');\n          }\n\n          this.linewise = true;\n        }\n\n        this.keyBuffer.push(text);\n      },\n      pushInsertModeChanges: function (changes) {\n        this.insertModeChanges.push(createInsertModeChanges(changes));\n      },\n      pushSearchQuery: function (query) {\n        this.searchQueries.push(query);\n      },\n      clear: function () {\n        this.keyBuffer = [];\n        this.insertModeChanges = [];\n        this.searchQueries = [];\n        this.linewise = false;\n      },\n      toString: function () {\n        return this.keyBuffer.join('');\n      }\n    };\n    /**\n     * Defines an external register.\n     *\n     * The name should be a single character that will be used to reference the register.\n     * The register should support setText, pushText, clear, and toString(). See Register\n     * for a reference implementation.\n     */\n\n    function defineRegister(name, register) {\n      var registers = vimGlobalState.registerController.registers;\n\n      if (!name || name.length != 1) {\n        throw Error('Register name must be 1 character');\n      }\n\n      if (registers[name]) {\n        throw Error('Register already defined ' + name);\n      }\n\n      registers[name] = register;\n      validRegisters.push(name);\n    }\n    /*\n     * vim registers allow you to keep many independent copy and paste buffers.\n     * See http://usevim.com/2012/04/13/registers/ for an introduction.\n     *\n     * RegisterController keeps the state of all the registers.  An initial\n     * state may be passed in.  The unnamed register '\"' will always be\n     * overridden.\n     */\n\n\n    function RegisterController(registers) {\n      this.registers = registers;\n      this.unnamedRegister = registers['\"'] = new Register();\n      registers['.'] = new Register();\n      registers[':'] = new Register();\n      registers['/'] = new Register();\n    }\n\n    RegisterController.prototype = {\n      pushText: function (registerName, operator, text, linewise, blockwise) {\n        // The black hole register, \"_, means delete/yank to nowhere.\n        if (registerName === '_') return;\n\n        if (linewise && text.charAt(text.length - 1) !== '\\n') {\n          text += '\\n';\n        } // Lowercase and uppercase registers refer to the same register.\n        // Uppercase just means append.\n\n\n        var register = this.isValidRegister(registerName) ? this.getRegister(registerName) : null; // if no register/an invalid register was specified, things go to the\n        // default registers\n\n        if (!register) {\n          switch (operator) {\n            case 'yank':\n              // The 0 register contains the text from the most recent yank.\n              this.registers['0'] = new Register(text, linewise, blockwise);\n              break;\n\n            case 'delete':\n            case 'change':\n              if (text.indexOf('\\n') == -1) {\n                // Delete less than 1 line. Update the small delete register.\n                this.registers['-'] = new Register(text, linewise);\n              } else {\n                // Shift down the contents of the numbered registers and put the\n                // deleted text into register 1.\n                this.shiftNumericRegisters_();\n                this.registers['1'] = new Register(text, linewise);\n              }\n\n              break;\n          } // Make sure the unnamed register is set to what just happened\n\n\n          this.unnamedRegister.setText(text, linewise, blockwise);\n          return;\n        } // If we've gotten to this point, we've actually specified a register\n\n\n        var append = isUpperCase(registerName);\n\n        if (append) {\n          register.pushText(text, linewise);\n        } else {\n          register.setText(text, linewise, blockwise);\n        } // The unnamed register always has the same value as the last used\n        // register.\n\n\n        this.unnamedRegister.setText(register.toString(), linewise);\n      },\n      // Gets the register named @name.  If one of @name doesn't already exist,\n      // create it.  If @name is invalid, return the unnamedRegister.\n      getRegister: function (name) {\n        if (!this.isValidRegister(name)) {\n          return this.unnamedRegister;\n        }\n\n        name = name.toLowerCase();\n\n        if (!this.registers[name]) {\n          this.registers[name] = new Register();\n        }\n\n        return this.registers[name];\n      },\n      isValidRegister: function (name) {\n        return name && inArray(name, validRegisters);\n      },\n      shiftNumericRegisters_: function () {\n        for (var i = 9; i >= 2; i--) {\n          this.registers[i] = this.getRegister('' + (i - 1));\n        }\n      }\n    };\n\n    function HistoryController() {\n      this.historyBuffer = [];\n      this.iterator = 0;\n      this.initialPrefix = null;\n    }\n\n    HistoryController.prototype = {\n      // the input argument here acts a user entered prefix for a small time\n      // until we start autocompletion in which case it is the autocompleted.\n      nextMatch: function (input, up) {\n        var historyBuffer = this.historyBuffer;\n        var dir = up ? -1 : 1;\n        if (this.initialPrefix === null) this.initialPrefix = input;\n\n        for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i += dir) {\n          var element = historyBuffer[i];\n\n          for (var j = 0; j <= element.length; j++) {\n            if (this.initialPrefix == element.substring(0, j)) {\n              this.iterator = i;\n              return element;\n            }\n          }\n        } // should return the user input in case we reach the end of buffer.\n\n\n        if (i >= historyBuffer.length) {\n          this.iterator = historyBuffer.length;\n          return this.initialPrefix;\n        } // return the last autocompleted query or exCommand as it is.\n\n\n        if (i < 0) return input;\n      },\n      pushInput: function (input) {\n        var index = this.historyBuffer.indexOf(input);\n        if (index > -1) this.historyBuffer.splice(index, 1);\n        if (input.length) this.historyBuffer.push(input);\n      },\n      reset: function () {\n        this.initialPrefix = null;\n        this.iterator = this.historyBuffer.length;\n      }\n    };\n    var commandDispatcher = {\n      matchCommand: function (keys, keyMap, inputState, context) {\n        var matches = commandMatches(keys, keyMap, context, inputState);\n\n        if (!matches.full && !matches.partial) {\n          return {\n            type: 'none'\n          };\n        } else if (!matches.full && matches.partial) {\n          return {\n            type: 'partial'\n          };\n        }\n\n        var bestMatch;\n\n        for (var i = 0; i < matches.full.length; i++) {\n          var match = matches.full[i];\n\n          if (!bestMatch) {\n            bestMatch = match;\n          }\n        }\n\n        if (bestMatch.keys.slice(-11) == '<character>') {\n          var character = lastChar(keys);\n          if (!character) return {\n            type: 'none'\n          };\n          inputState.selectedCharacter = character;\n        }\n\n        return {\n          type: 'full',\n          command: bestMatch\n        };\n      },\n      processCommand: function (cm, vim, command) {\n        vim.inputState.repeatOverride = command.repeatOverride;\n\n        switch (command.type) {\n          case 'motion':\n            this.processMotion(cm, vim, command);\n            break;\n\n          case 'operator':\n            this.processOperator(cm, vim, command);\n            break;\n\n          case 'operatorMotion':\n            this.processOperatorMotion(cm, vim, command);\n            break;\n\n          case 'action':\n            this.processAction(cm, vim, command);\n            break;\n\n          case 'search':\n            this.processSearch(cm, vim, command);\n            break;\n\n          case 'ex':\n          case 'keyToEx':\n            this.processEx(cm, vim, command);\n            break;\n\n          default:\n            break;\n        }\n      },\n      processMotion: function (cm, vim, command) {\n        vim.inputState.motion = command.motion;\n        vim.inputState.motionArgs = copyArgs(command.motionArgs);\n        this.evalInput(cm, vim);\n      },\n      processOperator: function (cm, vim, command) {\n        var inputState = vim.inputState;\n\n        if (inputState.operator) {\n          if (inputState.operator == command.operator) {\n            // Typing an operator twice like 'dd' makes the operator operate\n            // linewise\n            inputState.motion = 'expandToLine';\n            inputState.motionArgs = {\n              linewise: true\n            };\n            this.evalInput(cm, vim);\n            return;\n          } else {\n            // 2 different operators in a row doesn't make sense.\n            clearInputState(cm);\n          }\n        }\n\n        inputState.operator = command.operator;\n        inputState.operatorArgs = copyArgs(command.operatorArgs);\n\n        if (command.keys.length > 1) {\n          inputState.operatorShortcut = command.keys;\n        }\n\n        if (command.exitVisualBlock) {\n          vim.visualBlock = false;\n          updateCmSelection(cm);\n        }\n\n        if (vim.visualMode) {\n          // Operating on a selection in visual mode. We don't need a motion.\n          this.evalInput(cm, vim);\n        }\n      },\n      processOperatorMotion: function (cm, vim, command) {\n        var visualMode = vim.visualMode;\n        var operatorMotionArgs = copyArgs(command.operatorMotionArgs);\n\n        if (operatorMotionArgs) {\n          // Operator motions may have special behavior in visual mode.\n          if (visualMode && operatorMotionArgs.visualLine) {\n            vim.visualLine = true;\n          }\n        }\n\n        this.processOperator(cm, vim, command);\n\n        if (!visualMode) {\n          this.processMotion(cm, vim, command);\n        }\n      },\n      processAction: function (cm, vim, command) {\n        var inputState = vim.inputState;\n        var repeat = inputState.getRepeat();\n        var repeatIsExplicit = !!repeat;\n        var actionArgs = copyArgs(command.actionArgs) || {};\n\n        if (inputState.selectedCharacter) {\n          actionArgs.selectedCharacter = inputState.selectedCharacter;\n        } // Actions may or may not have motions and operators. Do these first.\n\n\n        if (command.operator) {\n          this.processOperator(cm, vim, command);\n        }\n\n        if (command.motion) {\n          this.processMotion(cm, vim, command);\n        }\n\n        if (command.motion || command.operator) {\n          this.evalInput(cm, vim);\n        }\n\n        actionArgs.repeat = repeat || 1;\n        actionArgs.repeatIsExplicit = repeatIsExplicit;\n        actionArgs.registerName = inputState.registerName;\n        clearInputState(cm);\n        vim.lastMotion = null;\n\n        if (command.isEdit) {\n          this.recordLastEdit(vim, inputState, command);\n        }\n\n        actions[command.action](cm, actionArgs, vim);\n      },\n      processSearch: function (cm, vim, command) {\n        if (!cm.getSearchCursor) {\n          // Search depends on SearchCursor.\n          return;\n        }\n\n        var forward = command.searchArgs.forward;\n        var wholeWordOnly = command.searchArgs.wholeWordOnly;\n        getSearchState(cm).setReversed(!forward);\n        var promptPrefix = forward ? '/' : '?';\n        var originalQuery = getSearchState(cm).getQuery();\n        var originalScrollPos = cm.getScrollInfo();\n\n        function handleQuery(query, ignoreCase, smartCase) {\n          vimGlobalState.searchHistoryController.pushInput(query);\n          vimGlobalState.searchHistoryController.reset();\n\n          try {\n            updateSearchQuery(cm, query, ignoreCase, smartCase);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + query);\n            clearInputState(cm);\n            return;\n          }\n\n          commandDispatcher.processMotion(cm, vim, {\n            type: 'motion',\n            motion: 'findNext',\n            motionArgs: {\n              forward: true,\n              toJumplist: command.searchArgs.toJumplist\n            }\n          });\n        }\n\n        function onPromptClose(query) {\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          handleQuery(query, true\n          /** ignoreCase */\n          , true\n          /** smartCase */\n          );\n          var macroModeState = vimGlobalState.macroModeState;\n\n          if (macroModeState.isRecording) {\n            logSearchQuery(macroModeState, query);\n          }\n        }\n\n        function onPromptKeyUp(e, query, close) {\n          var keyName = CodeMirror.keyName(e),\n              up,\n              offset;\n\n          if (keyName == 'Up' || keyName == 'Down') {\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';\n            close(query);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else {\n            if (keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift') vimGlobalState.searchHistoryController.reset();\n          }\n\n          var parsedQuery;\n\n          try {\n            parsedQuery = updateSearchQuery(cm, query, true\n            /** ignoreCase */\n            , true\n            /** smartCase */\n            );\n          } catch (e) {// Swallow bad regexes for incremental search.\n          }\n\n          if (parsedQuery) {\n            cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);\n          } else {\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          }\n        }\n\n        function onPromptKeyDown(e, query, close) {\n          var keyName = CodeMirror.keyName(e);\n\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' || keyName == 'Backspace' && query == '') {\n            vimGlobalState.searchHistoryController.pushInput(query);\n            vimGlobalState.searchHistoryController.reset();\n            updateSearchQuery(cm, originalQuery);\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          } else if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          }\n        }\n\n        switch (command.searchArgs.querySrc) {\n          case 'prompt':\n            var macroModeState = vimGlobalState.macroModeState;\n\n            if (macroModeState.isPlaying) {\n              var query = macroModeState.replaySearchQueries.shift();\n              handleQuery(query, true\n              /** ignoreCase */\n              , false\n              /** smartCase */\n              );\n            } else {\n              showPrompt(cm, {\n                onClose: onPromptClose,\n                prefix: promptPrefix,\n                desc: '(JavaScript regexp)',\n                onKeyUp: onPromptKeyUp,\n                onKeyDown: onPromptKeyDown\n              });\n            }\n\n            break;\n\n          case 'wordUnderCursor':\n            var word = expandWordUnderCursor(cm, false\n            /** inclusive */\n            , true\n            /** forward */\n            , false\n            /** bigWord */\n            , true\n            /** noSymbol */\n            );\n            var isKeyword = true;\n\n            if (!word) {\n              word = expandWordUnderCursor(cm, false\n              /** inclusive */\n              , true\n              /** forward */\n              , false\n              /** bigWord */\n              , false\n              /** noSymbol */\n              );\n              isKeyword = false;\n            }\n\n            if (!word) {\n              return;\n            }\n\n            var query = cm.getLine(word.start.line).substring(word.start.ch, word.end.ch);\n\n            if (isKeyword && wholeWordOnly) {\n              query = '\\\\b' + query + '\\\\b';\n            } else {\n              query = escapeRegex(query);\n            } // cachedCursor is used to save the old position of the cursor\n            // when * or # causes vim to seek for the nearest word and shift\n            // the cursor before entering the motion.\n\n\n            vimGlobalState.jumpList.cachedCursor = cm.getCursor();\n            cm.setCursor(word.start);\n            handleQuery(query, true\n            /** ignoreCase */\n            , false\n            /** smartCase */\n            );\n            break;\n        }\n      },\n      processEx: function (cm, vim, command) {\n        function onPromptClose(input) {\n          // Give the prompt some time to close so that if processCommand shows\n          // an error, the elements don't overlap.\n          vimGlobalState.exCommandHistoryController.pushInput(input);\n          vimGlobalState.exCommandHistoryController.reset();\n          exCommandDispatcher.processCommand(cm, input);\n        }\n\n        function onPromptKeyDown(e, input, close) {\n          var keyName = CodeMirror.keyName(e),\n              up,\n              offset;\n\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' || keyName == 'Backspace' && input == '') {\n            vimGlobalState.exCommandHistoryController.pushInput(input);\n            vimGlobalState.exCommandHistoryController.reset();\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          }\n\n          if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';\n            close(input);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          } else {\n            if (keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift') vimGlobalState.exCommandHistoryController.reset();\n          }\n        }\n\n        if (command.type == 'keyToEx') {\n          // Handle user defined Ex to Ex mappings\n          exCommandDispatcher.processCommand(cm, command.exArgs.input);\n        } else {\n          if (vim.visualMode) {\n            showPrompt(cm, {\n              onClose: onPromptClose,\n              prefix: ':',\n              value: '\\'<,\\'>',\n              onKeyDown: onPromptKeyDown,\n              selectValueOnOpen: false\n            });\n          } else {\n            showPrompt(cm, {\n              onClose: onPromptClose,\n              prefix: ':',\n              onKeyDown: onPromptKeyDown\n            });\n          }\n        }\n      },\n      evalInput: function (cm, vim) {\n        // If the motion command is set, execute both the operator and motion.\n        // Otherwise return.\n        var inputState = vim.inputState;\n        var motion = inputState.motion;\n        var motionArgs = inputState.motionArgs || {};\n        var operator = inputState.operator;\n        var operatorArgs = inputState.operatorArgs || {};\n        var registerName = inputState.registerName;\n        var sel = vim.sel; // TODO: Make sure cm and vim selections are identical outside visual mode.\n\n        var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head) : cm.getCursor('head'));\n        var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));\n        var oldHead = copyCursor(origHead);\n        var oldAnchor = copyCursor(origAnchor);\n        var newHead, newAnchor;\n        var repeat;\n\n        if (operator) {\n          this.recordLastEdit(vim, inputState);\n        }\n\n        if (inputState.repeatOverride !== undefined) {\n          // If repeatOverride is specified, that takes precedence over the\n          // input state's repeat. Used by Ex mode and can be user defined.\n          repeat = inputState.repeatOverride;\n        } else {\n          repeat = inputState.getRepeat();\n        }\n\n        if (repeat > 0 && motionArgs.explicitRepeat) {\n          motionArgs.repeatIsExplicit = true;\n        } else if (motionArgs.noRepeat || !motionArgs.explicitRepeat && repeat === 0) {\n          repeat = 1;\n          motionArgs.repeatIsExplicit = false;\n        }\n\n        if (inputState.selectedCharacter) {\n          // If there is a character input, stick it in all of the arg arrays.\n          motionArgs.selectedCharacter = operatorArgs.selectedCharacter = inputState.selectedCharacter;\n        }\n\n        motionArgs.repeat = repeat;\n        clearInputState(cm);\n\n        if (motion) {\n          var motionResult = motions[motion](cm, origHead, motionArgs, vim, inputState);\n          vim.lastMotion = motions[motion];\n\n          if (!motionResult) {\n            return;\n          }\n\n          if (motionArgs.toJumplist) {\n            var jumpList = vimGlobalState.jumpList; // if the current motion is # or *, use cachedCursor\n\n            var cachedCursor = jumpList.cachedCursor;\n\n            if (cachedCursor) {\n              recordJumpPosition(cm, cachedCursor, motionResult);\n              delete jumpList.cachedCursor;\n            } else {\n              recordJumpPosition(cm, origHead, motionResult);\n            }\n          }\n\n          if (motionResult instanceof Array) {\n            newAnchor = motionResult[0];\n            newHead = motionResult[1];\n          } else {\n            newHead = motionResult;\n          } // TODO: Handle null returns from motion commands better.\n\n\n          if (!newHead) {\n            newHead = copyCursor(origHead);\n          }\n\n          if (vim.visualMode) {\n            if (!(vim.visualBlock && newHead.ch === Infinity)) {\n              newHead = clipCursorToContent(cm, newHead);\n            }\n\n            if (newAnchor) {\n              newAnchor = clipCursorToContent(cm, newAnchor);\n            }\n\n            newAnchor = newAnchor || oldAnchor;\n            sel.anchor = newAnchor;\n            sel.head = newHead;\n            updateCmSelection(cm);\n            updateMark(cm, vim, '<', cursorIsBefore(newAnchor, newHead) ? newAnchor : newHead);\n            updateMark(cm, vim, '>', cursorIsBefore(newAnchor, newHead) ? newHead : newAnchor);\n          } else if (!operator) {\n            newHead = clipCursorToContent(cm, newHead);\n            cm.setCursor(newHead.line, newHead.ch);\n          }\n        }\n\n        if (operator) {\n          if (operatorArgs.lastSel) {\n            // Replaying a visual mode operation\n            newAnchor = oldAnchor;\n            var lastSel = operatorArgs.lastSel;\n            var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);\n            var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);\n\n            if (lastSel.visualLine) {\n              // Linewise Visual mode: The same number of lines.\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            } else if (lastSel.visualBlock) {\n              // Blockwise Visual mode: The same number of lines and columns.\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);\n            } else if (lastSel.head.line == lastSel.anchor.line) {\n              // Normal Visual mode within one line: The same number of characters.\n              newHead = Pos(oldAnchor.line, oldAnchor.ch + chOffset);\n            } else {\n              // Normal Visual mode with several lines: The same number of lines, in the\n              // last line the same number of characters as in the last line the last time.\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            }\n\n            vim.visualMode = true;\n            vim.visualLine = lastSel.visualLine;\n            vim.visualBlock = lastSel.visualBlock;\n            sel = vim.sel = {\n              anchor: newAnchor,\n              head: newHead\n            };\n            updateCmSelection(cm);\n          } else if (vim.visualMode) {\n            operatorArgs.lastSel = {\n              anchor: copyCursor(sel.anchor),\n              head: copyCursor(sel.head),\n              visualBlock: vim.visualBlock,\n              visualLine: vim.visualLine\n            };\n          }\n\n          var curStart, curEnd, linewise, mode;\n          var cmSel;\n\n          if (vim.visualMode) {\n            // Init visual op\n            curStart = cursorMin(sel.head, sel.anchor);\n            curEnd = cursorMax(sel.head, sel.anchor);\n            linewise = vim.visualLine || operatorArgs.linewise;\n            mode = vim.visualBlock ? 'block' : linewise ? 'line' : 'char';\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode);\n\n            if (linewise) {\n              var ranges = cmSel.ranges;\n\n              if (mode == 'block') {\n                // Linewise operators in visual block mode extend to end of line\n                for (var i = 0; i < ranges.length; i++) {\n                  ranges[i].head.ch = lineLength(cm, ranges[i].head.line);\n                }\n              } else if (mode == 'line') {\n                ranges[0].head = Pos(ranges[0].head.line + 1, 0);\n              }\n            }\n          } else {\n            // Init motion op\n            curStart = copyCursor(newAnchor || oldAnchor);\n            curEnd = copyCursor(newHead || oldHead);\n\n            if (cursorIsBefore(curEnd, curStart)) {\n              var tmp = curStart;\n              curStart = curEnd;\n              curEnd = tmp;\n            }\n\n            linewise = motionArgs.linewise || operatorArgs.linewise;\n\n            if (linewise) {\n              // Expand selection to entire line.\n              expandSelectionToLine(cm, curStart, curEnd);\n            } else if (motionArgs.forward) {\n              // Clip to trailing newlines only if the motion goes forward.\n              clipToLine(cm, curStart, curEnd);\n            }\n\n            mode = 'char';\n            var exclusive = !motionArgs.inclusive || linewise;\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode, exclusive);\n          }\n\n          cm.setSelections(cmSel.ranges, cmSel.primary);\n          vim.lastMotion = null;\n          operatorArgs.repeat = repeat; // For indent in visual mode.\n\n          operatorArgs.registerName = registerName; // Keep track of linewise as it affects how paste and change behave.\n\n          operatorArgs.linewise = linewise;\n          var operatorMoveTo = operators[operator](cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);\n\n          if (vim.visualMode) {\n            exitVisualMode(cm, operatorMoveTo != null);\n          }\n\n          if (operatorMoveTo) {\n            cm.setCursor(operatorMoveTo);\n          }\n        }\n      },\n      recordLastEdit: function (vim, inputState, actionCommand) {\n        var macroModeState = vimGlobalState.macroModeState;\n\n        if (macroModeState.isPlaying) {\n          return;\n        }\n\n        vim.lastEditInputState = inputState;\n        vim.lastEditActionCommand = actionCommand;\n        macroModeState.lastInsertModeChanges.changes = [];\n        macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;\n        macroModeState.lastInsertModeChanges.visualBlock = vim.visualBlock ? vim.sel.head.line - vim.sel.anchor.line : 0;\n      }\n    };\n    /**\n     * typedef {Object{line:number,ch:number}} Cursor An object containing the\n     *     position of the cursor.\n     */\n    // All of the functions below return Cursor objects.\n\n    var motions = {\n      moveToTopLine: function (cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).top + motionArgs.repeat - 1;\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToMiddleLine: function (cm) {\n        var range = getUserVisibleLines(cm);\n        var line = Math.floor((range.top + range.bottom) * 0.5);\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToBottomLine: function (cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).bottom - motionArgs.repeat + 1;\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      expandToLine: function (_cm, head, motionArgs) {\n        // Expands forward to end of line, and then to next line if repeat is\n        // >1. Does not handle backward motion!\n        var cur = head;\n        return Pos(cur.line + motionArgs.repeat - 1, Infinity);\n      },\n      findNext: function (cm, _head, motionArgs) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n\n        if (!query) {\n          return;\n        }\n\n        var prev = !motionArgs.forward; // If search is initiated with ? instead of /, negate direction.\n\n        prev = state.isReversed() ? !prev : prev;\n        highlightSearchMatches(cm, query);\n        return findNext(cm, prev\n        /** prev */\n        , query, motionArgs.repeat);\n      },\n\n      /**\n       * Find and select the next occurrence of the search query. If the cursor is currently\n       * within a match, then find and select the current match. Otherwise, find the next occurrence in the\n       * appropriate direction.\n       *\n       * This differs from `findNext` in the following ways:\n       *\n       * 1. Instead of only returning the \"from\", this returns a \"from\", \"to\" range.\n       * 2. If the cursor is currently inside a search match, this selects the current match\n       *    instead of the next match.\n       * 3. If there is no associated operator, this will turn on visual mode.\n       */\n      findAndSelectNextInclusive: function (cm, _head, motionArgs, vim, prevInputState) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n\n        if (!query) {\n          return;\n        }\n\n        var prev = !motionArgs.forward;\n        prev = state.isReversed() ? !prev : prev; // next: [from, to] | null\n\n        var next = findNextFromAndToInclusive(cm, prev, query, motionArgs.repeat, vim); // No matches.\n\n        if (!next) {\n          return;\n        } // If there's an operator that will be executed, return the selection.\n\n\n        if (prevInputState.operator) {\n          return next;\n        } // At this point, we know that there is no accompanying operator -- let's\n        // deal with visual mode in order to select an appropriate match.\n\n\n        var from = next[0]; // For whatever reason, when we use the \"to\" as returned by searchcursor.js directly,\n        // the resulting selection is extended by 1 char. Let's shrink it so that only the\n        // match is selected.\n\n        var to = Pos(next[1].line, next[1].ch - 1);\n\n        if (vim.visualMode) {\n          // If we were in visualLine or visualBlock mode, get out of it.\n          if (vim.visualLine || vim.visualBlock) {\n            vim.visualLine = false;\n            vim.visualBlock = false;\n            CodeMirror.signal(cm, \"vim-mode-change\", {\n              mode: \"visual\",\n              subMode: \"\"\n            });\n          } // If we're currently in visual mode, we should extend the selection to include\n          // the search result.\n\n\n          var anchor = vim.sel.anchor;\n\n          if (anchor) {\n            if (state.isReversed()) {\n              if (motionArgs.forward) {\n                return [anchor, from];\n              }\n\n              return [anchor, to];\n            } else {\n              if (motionArgs.forward) {\n                return [anchor, to];\n              }\n\n              return [anchor, from];\n            }\n          }\n        } else {\n          // Let's turn visual mode on.\n          vim.visualMode = true;\n          vim.visualLine = false;\n          vim.visualBlock = false;\n          CodeMirror.signal(cm, \"vim-mode-change\", {\n            mode: \"visual\",\n            subMode: \"\"\n          });\n        }\n\n        return prev ? [to, from] : [from, to];\n      },\n      goToMark: function (cm, _head, motionArgs, vim) {\n        var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);\n\n        if (pos) {\n          return motionArgs.linewise ? {\n            line: pos.line,\n            ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line))\n          } : pos;\n        }\n\n        return null;\n      },\n      moveToOtherHighlightedEnd: function (cm, _head, motionArgs, vim) {\n        if (vim.visualBlock && motionArgs.sameLine) {\n          var sel = vim.sel;\n          return [clipCursorToContent(cm, Pos(sel.anchor.line, sel.head.ch)), clipCursorToContent(cm, Pos(sel.head.line, sel.anchor.ch))];\n        } else {\n          return [vim.sel.head, vim.sel.anchor];\n        }\n      },\n      jumpToMark: function (cm, head, motionArgs, vim) {\n        var best = head;\n\n        for (var i = 0; i < motionArgs.repeat; i++) {\n          var cursor = best;\n\n          for (var key in vim.marks) {\n            if (!isLowerCase(key)) {\n              continue;\n            }\n\n            var mark = vim.marks[key].find();\n            var isWrongDirection = motionArgs.forward ? cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);\n\n            if (isWrongDirection) {\n              continue;\n            }\n\n            if (motionArgs.linewise && mark.line == cursor.line) {\n              continue;\n            }\n\n            var equal = cursorEqual(cursor, best);\n            var between = motionArgs.forward ? cursorIsBetween(cursor, mark, best) : cursorIsBetween(best, mark, cursor);\n\n            if (equal || between) {\n              best = mark;\n            }\n          }\n        }\n\n        if (motionArgs.linewise) {\n          // Vim places the cursor on the first non-whitespace character of\n          // the line if there is one, else it places the cursor at the end\n          // of the line, regardless of whether a mark was found.\n          best = Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));\n        }\n\n        return best;\n      },\n      moveByCharacters: function (_cm, head, motionArgs) {\n        var cur = head;\n        var repeat = motionArgs.repeat;\n        var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;\n        return Pos(cur.line, ch);\n      },\n      moveByLines: function (cm, head, motionArgs, vim) {\n        var cur = head;\n        var endCh = cur.ch; // Depending what our last motion was, we may want to do different\n        // things. If our last motion was moving vertically, we want to\n        // preserve the HPos from our last horizontal move.  If our last motion\n        // was going to the end of a line, moving vertically we should go to\n        // the end of the line, etc.\n\n        switch (vim.lastMotion) {\n          case this.moveByLines:\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveToColumn:\n          case this.moveToEol:\n            endCh = vim.lastHPos;\n            break;\n\n          default:\n            vim.lastHPos = endCh;\n        }\n\n        var repeat = motionArgs.repeat + (motionArgs.repeatOffset || 0);\n        var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\n        var first = cm.firstLine();\n        var last = cm.lastLine();\n        var posV = cm.findPosV(cur, motionArgs.forward ? repeat : -repeat, 'line', vim.lastHSPos);\n        var hasMarkedText = motionArgs.forward ? posV.line > line : posV.line < line;\n\n        if (hasMarkedText) {\n          line = posV.line;\n          endCh = posV.ch;\n        } // Vim go to line begin or line end when cursor at first/last line and\n        // move to previous/next line is triggered.\n\n\n        if (line < first && cur.line == first) {\n          return this.moveToStartOfLine(cm, head, motionArgs, vim);\n        } else if (line > last && cur.line == last) {\n          return moveToEol(cm, head, motionArgs, vim, true);\n        }\n\n        if (motionArgs.toFirstChar) {\n          endCh = findFirstNonWhiteSpaceCharacter(cm.getLine(line));\n          vim.lastHPos = endCh;\n        }\n\n        vim.lastHSPos = cm.charCoords(Pos(line, endCh), 'div').left;\n        return Pos(line, endCh);\n      },\n      moveByDisplayLines: function (cm, head, motionArgs, vim) {\n        var cur = head;\n\n        switch (vim.lastMotion) {\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveByLines:\n          case this.moveToColumn:\n          case this.moveToEol:\n            break;\n\n          default:\n            vim.lastHSPos = cm.charCoords(cur, 'div').left;\n        }\n\n        var repeat = motionArgs.repeat;\n        var res = cm.findPosV(cur, motionArgs.forward ? repeat : -repeat, 'line', vim.lastHSPos);\n\n        if (res.hitSide) {\n          if (motionArgs.forward) {\n            var lastCharCoords = cm.charCoords(res, 'div');\n            var goalCoords = {\n              top: lastCharCoords.top + 8,\n              left: vim.lastHSPos\n            };\n            var res = cm.coordsChar(goalCoords, 'div');\n          } else {\n            var resCoords = cm.charCoords(Pos(cm.firstLine(), 0), 'div');\n            resCoords.left = vim.lastHSPos;\n            res = cm.coordsChar(resCoords, 'div');\n          }\n        }\n\n        vim.lastHPos = res.ch;\n        return res;\n      },\n      moveByPage: function (cm, head, motionArgs) {\n        // CodeMirror only exposes functions that move the cursor page down, so\n        // doing this bad hack to move the cursor and move it back. evalInput\n        // will move the cursor to where it should be in the end.\n        var curStart = head;\n        var repeat = motionArgs.repeat;\n        return cm.findPosV(curStart, motionArgs.forward ? repeat : -repeat, 'page');\n      },\n      moveByParagraph: function (cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findParagraph(cm, head, motionArgs.repeat, dir);\n      },\n      moveBySentence: function (cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findSentence(cm, head, motionArgs.repeat, dir);\n      },\n      moveByScroll: function (cm, head, motionArgs, vim) {\n        var scrollbox = cm.getScrollInfo();\n        var curEnd = null;\n        var repeat = motionArgs.repeat;\n\n        if (!repeat) {\n          repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());\n        }\n\n        var orig = cm.charCoords(head, 'local');\n        motionArgs.repeat = repeat;\n        var curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);\n\n        if (!curEnd) {\n          return null;\n        }\n\n        var dest = cm.charCoords(curEnd, 'local');\n        cm.scrollTo(null, scrollbox.top + dest.top - orig.top);\n        return curEnd;\n      },\n      moveByWords: function (cm, head, motionArgs) {\n        return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward, !!motionArgs.wordEnd, !!motionArgs.bigWord);\n      },\n      moveTillCharacter: function (cm, _head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        var curEnd = moveToCharacter(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter);\n        var increment = motionArgs.forward ? -1 : 1;\n        recordLastCharacterSearch(increment, motionArgs);\n        if (!curEnd) return null;\n        curEnd.ch += increment;\n        return curEnd;\n      },\n      moveToCharacter: function (cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        recordLastCharacterSearch(0, motionArgs);\n        return moveToCharacter(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter) || head;\n      },\n      moveToSymbol: function (cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        return findSymbol(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter) || head;\n      },\n      moveToColumn: function (cm, head, motionArgs, vim) {\n        var repeat = motionArgs.repeat; // repeat is equivalent to which column we want to move to!\n\n        vim.lastHPos = repeat - 1;\n        vim.lastHSPos = cm.charCoords(head, 'div').left;\n        return moveToColumn(cm, repeat);\n      },\n      moveToEol: function (cm, head, motionArgs, vim) {\n        return moveToEol(cm, head, motionArgs, vim, false);\n      },\n      moveToFirstNonWhiteSpaceCharacter: function (cm, head) {\n        // Go to the start of the line where the text begins, or the end for\n        // whitespace-only lines\n        var cursor = head;\n        return Pos(cursor.line, findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));\n      },\n      moveToMatchedSymbol: function (cm, head) {\n        var cursor = head;\n        var line = cursor.line;\n        var ch = cursor.ch;\n        var lineText = cm.getLine(line);\n        var symbol;\n\n        for (; ch < lineText.length; ch++) {\n          symbol = lineText.charAt(ch);\n\n          if (symbol && isMatchableSymbol(symbol)) {\n            var style = cm.getTokenTypeAt(Pos(line, ch + 1));\n\n            if (style !== \"string\" && style !== \"comment\") {\n              break;\n            }\n          }\n        }\n\n        if (ch < lineText.length) {\n          // Only include angle brackets in analysis if they are being matched.\n          var re = ch === '<' || ch === '>' ? /[(){}[\\]<>]/ : /[(){}[\\]]/;\n          var matched = cm.findMatchingBracket(Pos(line, ch), {\n            bracketRegex: re\n          });\n          return matched.to;\n        } else {\n          return cursor;\n        }\n      },\n      moveToStartOfLine: function (_cm, head) {\n        return Pos(head.line, 0);\n      },\n      moveToLineOrEdgeOfDocument: function (cm, _head, motionArgs) {\n        var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();\n\n        if (motionArgs.repeatIsExplicit) {\n          lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');\n        }\n\n        return Pos(lineNum, findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));\n      },\n      textObjectManipulation: function (cm, head, motionArgs, vim) {\n        // TODO: lots of possible exceptions that can be thrown here. Try da(\n        //     outside of a () block.\n        var mirroredPairs = {\n          '(': ')',\n          ')': '(',\n          '{': '}',\n          '}': '{',\n          '[': ']',\n          ']': '[',\n          '<': '>',\n          '>': '<'\n        };\n        var selfPaired = {\n          '\\'': true,\n          '\"': true,\n          '`': true\n        };\n        var character = motionArgs.selectedCharacter; // 'b' refers to  '()' block.\n        // 'B' refers to  '{}' block.\n\n        if (character == 'b') {\n          character = '(';\n        } else if (character == 'B') {\n          character = '{';\n        } // Inclusive is the difference between a and i\n        // TODO: Instead of using the additional text object map to perform text\n        //     object operations, merge the map into the defaultKeyMap and use\n        //     motionArgs to define behavior. Define separate entries for 'aw',\n        //     'iw', 'a[', 'i[', etc.\n\n\n        var inclusive = !motionArgs.textObjectInner;\n        var tmp;\n\n        if (mirroredPairs[character]) {\n          tmp = selectCompanionObject(cm, head, character, inclusive);\n        } else if (selfPaired[character]) {\n          tmp = findBeginningAndEnd(cm, head, character, inclusive);\n        } else if (character === 'W') {\n          tmp = expandWordUnderCursor(cm, inclusive, true\n          /** forward */\n          , true\n          /** bigWord */\n          );\n        } else if (character === 'w') {\n          tmp = expandWordUnderCursor(cm, inclusive, true\n          /** forward */\n          , false\n          /** bigWord */\n          );\n        } else if (character === 'p') {\n          tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);\n          motionArgs.linewise = true;\n\n          if (vim.visualMode) {\n            if (!vim.visualLine) {\n              vim.visualLine = true;\n            }\n          } else {\n            var operatorArgs = vim.inputState.operatorArgs;\n\n            if (operatorArgs) {\n              operatorArgs.linewise = true;\n            }\n\n            tmp.end.line--;\n          }\n        } else if (character === 't') {\n          tmp = expandTagUnderCursor(cm, head, inclusive);\n        } else {\n          // No text object defined for this, don't move.\n          return null;\n        }\n\n        if (!cm.state.vim.visualMode) {\n          return [tmp.start, tmp.end];\n        } else {\n          return expandSelection(cm, tmp.start, tmp.end);\n        }\n      },\n      repeatLastCharacterSearch: function (cm, head, motionArgs) {\n        var lastSearch = vimGlobalState.lastCharacterSearch;\n        var repeat = motionArgs.repeat;\n        var forward = motionArgs.forward === lastSearch.forward;\n        var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);\n        cm.moveH(-increment, 'char');\n        motionArgs.inclusive = forward ? true : false;\n        var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);\n\n        if (!curEnd) {\n          cm.moveH(increment, 'char');\n          return head;\n        }\n\n        curEnd.ch += increment;\n        return curEnd;\n      }\n    };\n\n    function defineMotion(name, fn) {\n      motions[name] = fn;\n    }\n\n    function fillArray(val, times) {\n      var arr = [];\n\n      for (var i = 0; i < times; i++) {\n        arr.push(val);\n      }\n\n      return arr;\n    }\n    /**\n     * An operator acts on a text selection. It receives the list of selections\n     * as input. The corresponding CodeMirror selection is guaranteed to\n    * match the input selection.\n     */\n\n\n    var operators = {\n      change: function (cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        var anchor = ranges[0].anchor,\n            head = ranges[0].head;\n\n        if (!vim.visualMode) {\n          text = cm.getRange(anchor, head);\n          var lastState = vim.lastEditInputState || {};\n\n          if (lastState.motion == \"moveByWords\" && !isWhiteSpaceString(text)) {\n            // Exclude trailing whitespace if the range is not all whitespace.\n            var match = /\\s+$/.exec(text);\n\n            if (match && lastState.motionArgs && lastState.motionArgs.forward) {\n              head = offsetCursor(head, 0, -match[0].length);\n              text = text.slice(0, -match[0].length);\n            }\n          }\n\n          var prevLineEnd = new Pos(anchor.line - 1, Number.MAX_VALUE);\n          var wasLastLine = cm.firstLine() == cm.lastLine();\n\n          if (head.line > cm.lastLine() && args.linewise && !wasLastLine) {\n            cm.replaceRange('', prevLineEnd, head);\n          } else {\n            cm.replaceRange('', anchor, head);\n          }\n\n          if (args.linewise) {\n            // Push the next line back down, if there is a next line.\n            if (!wasLastLine) {\n              cm.setCursor(prevLineEnd);\n              CodeMirror.commands.newlineAndIndent(cm);\n            } // make sure cursor ends up at the end of the line.\n\n\n            anchor.ch = Number.MAX_VALUE;\n          }\n\n          finalHead = anchor;\n        } else if (args.fullLine) {\n          head.ch = Number.MAX_VALUE;\n          head.line--;\n          cm.setSelection(anchor, head);\n          text = cm.getSelection();\n          cm.replaceSelection(\"\");\n          finalHead = anchor;\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n        }\n\n        vimGlobalState.registerController.pushText(args.registerName, 'change', text, args.linewise, ranges.length > 1);\n        actions.enterInsertMode(cm, {\n          head: finalHead\n        }, cm.state.vim);\n      },\n      // delete is a javascript keyword.\n      'delete': function (cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n\n        if (!vim.visualBlock) {\n          var anchor = ranges[0].anchor,\n              head = ranges[0].head;\n\n          if (args.linewise && head.line != cm.firstLine() && anchor.line == cm.lastLine() && anchor.line == head.line - 1) {\n            // Special case for dd on last line (and first line).\n            if (anchor.line == cm.firstLine()) {\n              anchor.ch = 0;\n            } else {\n              anchor = Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));\n            }\n          }\n\n          text = cm.getRange(anchor, head);\n          cm.replaceRange('', anchor, head);\n          finalHead = anchor;\n\n          if (args.linewise) {\n            finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);\n          }\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = ranges[0].anchor;\n        }\n\n        vimGlobalState.registerController.pushText(args.registerName, 'delete', text, args.linewise, vim.visualBlock);\n        return clipCursorToContent(cm, finalHead);\n      },\n      indent: function (cm, args, ranges) {\n        var vim = cm.state.vim;\n        var startLine = ranges[0].anchor.line;\n        var endLine = vim.visualBlock ? ranges[ranges.length - 1].anchor.line : ranges[0].head.line; // In visual mode, n> shifts the selection right n times, instead of\n        // shifting n lines right once.\n\n        var repeat = vim.visualMode ? args.repeat : 1;\n\n        if (args.linewise) {\n          // The only way to delete a newline is to delete until the start of\n          // the next line, so in linewise mode evalInput will include the next\n          // line. We don't want this in indent, so we go back a line.\n          endLine--;\n        }\n\n        for (var i = startLine; i <= endLine; i++) {\n          for (var j = 0; j < repeat; j++) {\n            cm.indentLine(i, args.indentRight);\n          }\n        }\n\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n      },\n      indentAuto: function (cm, _args, ranges) {\n        cm.execCommand(\"indentAuto\");\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n      },\n      changeCase: function (cm, args, ranges, oldAnchor, newHead) {\n        var selections = cm.getSelections();\n        var swapped = [];\n        var toLower = args.toLower;\n\n        for (var j = 0; j < selections.length; j++) {\n          var toSwap = selections[j];\n          var text = '';\n\n          if (toLower === true) {\n            text = toSwap.toLowerCase();\n          } else if (toLower === false) {\n            text = toSwap.toUpperCase();\n          } else {\n            for (var i = 0; i < toSwap.length; i++) {\n              var character = toSwap.charAt(i);\n              text += isUpperCase(character) ? character.toLowerCase() : character.toUpperCase();\n            }\n          }\n\n          swapped.push(text);\n        }\n\n        cm.replaceSelections(swapped);\n\n        if (args.shouldMoveCursor) {\n          return newHead;\n        } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {\n          return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);\n        } else if (args.linewise) {\n          return oldAnchor;\n        } else {\n          return cursorMin(ranges[0].anchor, ranges[0].head);\n        }\n      },\n      yank: function (cm, args, ranges, oldAnchor) {\n        var vim = cm.state.vim;\n        var text = cm.getSelection();\n        var endPos = vim.visualMode ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor) : oldAnchor;\n        vimGlobalState.registerController.pushText(args.registerName, 'yank', text, args.linewise, vim.visualBlock);\n        return endPos;\n      }\n    };\n\n    function defineOperator(name, fn) {\n      operators[name] = fn;\n    }\n\n    var actions = {\n      jumpListWalk: function (cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n\n        var repeat = actionArgs.repeat;\n        var forward = actionArgs.forward;\n        var jumpList = vimGlobalState.jumpList;\n        var mark = jumpList.move(cm, forward ? repeat : -repeat);\n        var markPos = mark ? mark.find() : undefined;\n        markPos = markPos ? markPos : cm.getCursor();\n        cm.setCursor(markPos);\n      },\n      scroll: function (cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n\n        var repeat = actionArgs.repeat || 1;\n        var lineHeight = cm.defaultTextHeight();\n        var top = cm.getScrollInfo().top;\n        var delta = lineHeight * repeat;\n        var newPos = actionArgs.forward ? top + delta : top - delta;\n        var cursor = copyCursor(cm.getCursor());\n        var cursorCoords = cm.charCoords(cursor, 'local');\n\n        if (actionArgs.forward) {\n          if (newPos > cursorCoords.top) {\n            cursor.line += (newPos - cursorCoords.top) / lineHeight;\n            cursor.line = Math.ceil(cursor.line);\n            cm.setCursor(cursor);\n            cursorCoords = cm.charCoords(cursor, 'local');\n            cm.scrollTo(null, cursorCoords.top);\n          } else {\n            // Cursor stays within bounds.  Just reposition the scroll window.\n            cm.scrollTo(null, newPos);\n          }\n        } else {\n          var newBottom = newPos + cm.getScrollInfo().clientHeight;\n\n          if (newBottom < cursorCoords.bottom) {\n            cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;\n            cursor.line = Math.floor(cursor.line);\n            cm.setCursor(cursor);\n            cursorCoords = cm.charCoords(cursor, 'local');\n            cm.scrollTo(null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);\n          } else {\n            // Cursor stays within bounds.  Just reposition the scroll window.\n            cm.scrollTo(null, newPos);\n          }\n        }\n      },\n      scrollToCursor: function (cm, actionArgs) {\n        var lineNum = cm.getCursor().line;\n        var charCoords = cm.charCoords(Pos(lineNum, 0), 'local');\n        var height = cm.getScrollInfo().clientHeight;\n        var y = charCoords.top;\n        var lineHeight = charCoords.bottom - y;\n\n        switch (actionArgs.position) {\n          case 'center':\n            y = y - height / 2 + lineHeight;\n            break;\n\n          case 'bottom':\n            y = y - height + lineHeight;\n            break;\n        }\n\n        cm.scrollTo(null, y);\n      },\n      replayMacro: function (cm, actionArgs, vim) {\n        var registerName = actionArgs.selectedCharacter;\n        var repeat = actionArgs.repeat;\n        var macroModeState = vimGlobalState.macroModeState;\n\n        if (registerName == '@') {\n          registerName = macroModeState.latestRegister;\n        } else {\n          macroModeState.latestRegister = registerName;\n        }\n\n        while (repeat--) {\n          executeMacroRegister(cm, vim, macroModeState, registerName);\n        }\n      },\n      enterMacroRecordMode: function (cm, actionArgs) {\n        var macroModeState = vimGlobalState.macroModeState;\n        var registerName = actionArgs.selectedCharacter;\n\n        if (vimGlobalState.registerController.isValidRegister(registerName)) {\n          macroModeState.enterMacroRecordMode(cm, registerName);\n        }\n      },\n      toggleOverwrite: function (cm) {\n        if (!cm.state.overwrite) {\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {\n            mode: \"replace\"\n          });\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {\n            mode: \"insert\"\n          });\n        }\n      },\n      enterInsertMode: function (cm, actionArgs, vim) {\n        if (cm.getOption('readOnly')) {\n          return;\n        }\n\n        vim.insertMode = true;\n        vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;\n        var insertAt = actionArgs ? actionArgs.insertAt : null;\n        var sel = vim.sel;\n        var head = actionArgs.head || cm.getCursor('head');\n        var height = cm.listSelections().length;\n\n        if (insertAt == 'eol') {\n          head = Pos(head.line, lineLength(cm, head.line));\n        } else if (insertAt == 'bol') {\n          head = Pos(head.line, 0);\n        } else if (insertAt == 'charAfter') {\n          head = offsetCursor(head, 0, 1);\n        } else if (insertAt == 'firstNonBlank') {\n          head = motions.moveToFirstNonWhiteSpaceCharacter(cm, head);\n        } else if (insertAt == 'startOfSelectedArea') {\n          if (!vim.visualMode) return;\n\n          if (!vim.visualBlock) {\n            if (sel.head.line < sel.anchor.line) {\n              head = sel.head;\n            } else {\n              head = Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = Pos(Math.min(sel.head.line, sel.anchor.line), Math.min(sel.head.ch, sel.anchor.ch));\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'endOfSelectedArea') {\n          if (!vim.visualMode) return;\n\n          if (!vim.visualBlock) {\n            if (sel.head.line >= sel.anchor.line) {\n              head = offsetCursor(sel.head, 0, 1);\n            } else {\n              head = Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = Pos(Math.min(sel.head.line, sel.anchor.line), Math.max(sel.head.ch + 1, sel.anchor.ch));\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'inplace') {\n          if (vim.visualMode) {\n            return;\n          }\n        } else if (insertAt == 'lastEdit') {\n          head = getLastEditPos(cm) || head;\n        }\n\n        cm.setOption('disableInput', false);\n\n        if (actionArgs && actionArgs.replace) {\n          // Handle Replace-mode as a special case of insert mode.\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {\n            mode: \"replace\"\n          });\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {\n            mode: \"insert\"\n          });\n        }\n\n        if (!vimGlobalState.macroModeState.isPlaying) {\n          // Only record if not replaying.\n          cm.on('change', onChange);\n          CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n        }\n\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n\n        selectForInsert(cm, head, height);\n      },\n      toggleVisualMode: function (cm, actionArgs, vim) {\n        var repeat = actionArgs.repeat;\n        var anchor = cm.getCursor();\n        var head; // TODO: The repeat should actually select number of characters/lines\n        //     equal to the repeat times the size of the previous visual\n        //     operation.\n\n        if (!vim.visualMode) {\n          // Entering visual mode\n          vim.visualMode = true;\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          head = clipCursorToContent(cm, Pos(anchor.line, anchor.ch + repeat - 1));\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          CodeMirror.signal(cm, \"vim-mode-change\", {\n            mode: \"visual\",\n            subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"\n          });\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n        } else if (vim.visualLine ^ actionArgs.linewise || vim.visualBlock ^ actionArgs.blockwise) {\n          // Toggling between modes\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          CodeMirror.signal(cm, \"vim-mode-change\", {\n            mode: \"visual\",\n            subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"\n          });\n          updateCmSelection(cm);\n        } else {\n          exitVisualMode(cm);\n        }\n      },\n      reselectLastSelection: function (cm, _actionArgs, vim) {\n        var lastSelection = vim.lastSelection;\n\n        if (vim.visualMode) {\n          updateLastSelection(cm, vim);\n        }\n\n        if (lastSelection) {\n          var anchor = lastSelection.anchorMark.find();\n          var head = lastSelection.headMark.find();\n\n          if (!anchor || !head) {\n            // If the marks have been destroyed due to edits, do nothing.\n            return;\n          }\n\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          vim.visualMode = true;\n          vim.visualLine = lastSelection.visualLine;\n          vim.visualBlock = lastSelection.visualBlock;\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n          CodeMirror.signal(cm, 'vim-mode-change', {\n            mode: 'visual',\n            subMode: vim.visualLine ? 'linewise' : vim.visualBlock ? 'blockwise' : ''\n          });\n        }\n      },\n      joinLines: function (cm, actionArgs, vim) {\n        var curStart, curEnd;\n\n        if (vim.visualMode) {\n          curStart = cm.getCursor('anchor');\n          curEnd = cm.getCursor('head');\n\n          if (cursorIsBefore(curEnd, curStart)) {\n            var tmp = curEnd;\n            curEnd = curStart;\n            curStart = tmp;\n          }\n\n          curEnd.ch = lineLength(cm, curEnd.line) - 1;\n        } else {\n          // Repeat is the number of lines to join. Minimum 2 lines.\n          var repeat = Math.max(actionArgs.repeat, 2);\n          curStart = cm.getCursor();\n          curEnd = clipCursorToContent(cm, Pos(curStart.line + repeat - 1, Infinity));\n        }\n\n        var finalCh = 0;\n\n        for (var i = curStart.line; i < curEnd.line; i++) {\n          finalCh = lineLength(cm, curStart.line);\n          var tmp = Pos(curStart.line + 1, lineLength(cm, curStart.line + 1));\n          var text = cm.getRange(curStart, tmp);\n          text = actionArgs.keepSpaces ? text.replace(/\\n\\r?/g, '') : text.replace(/\\n\\s*/g, ' ');\n          cm.replaceRange(text, curStart, tmp);\n        }\n\n        var curFinalPos = Pos(curStart.line, finalCh);\n\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n\n        cm.setCursor(curFinalPos);\n      },\n      newLineAndEnterInsertMode: function (cm, actionArgs, vim) {\n        vim.insertMode = true;\n        var insertAt = copyCursor(cm.getCursor());\n\n        if (insertAt.line === cm.firstLine() && !actionArgs.after) {\n          // Special case for inserting newline before start of document.\n          cm.replaceRange('\\n', Pos(cm.firstLine(), 0));\n          cm.setCursor(cm.firstLine(), 0);\n        } else {\n          insertAt.line = actionArgs.after ? insertAt.line : insertAt.line - 1;\n          insertAt.ch = lineLength(cm, insertAt.line);\n          cm.setCursor(insertAt);\n          var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent;\n          newlineFn(cm);\n        }\n\n        this.enterInsertMode(cm, {\n          repeat: actionArgs.repeat\n        }, vim);\n      },\n      paste: function (cm, actionArgs, vim) {\n        var cur = copyCursor(cm.getCursor());\n        var register = vimGlobalState.registerController.getRegister(actionArgs.registerName);\n        var text = register.toString();\n\n        if (!text) {\n          return;\n        }\n\n        if (actionArgs.matchIndent) {\n          var tabSize = cm.getOption(\"tabSize\"); // length that considers tabs and tabSize\n\n          var whitespaceLength = function (str) {\n            var tabs = str.split(\"\\t\").length - 1;\n            var spaces = str.split(\" \").length - 1;\n            return tabs * tabSize + spaces * 1;\n          };\n\n          var currentLine = cm.getLine(cm.getCursor().line);\n          var indent = whitespaceLength(currentLine.match(/^\\s*/)[0]); // chomp last newline b/c don't want it to match /^\\s*/gm\n\n          var chompedText = text.replace(/\\n$/, '');\n          var wasChomped = text !== chompedText;\n          var firstIndent = whitespaceLength(text.match(/^\\s*/)[0]);\n          var text = chompedText.replace(/^\\s*/gm, function (wspace) {\n            var newIndent = indent + (whitespaceLength(wspace) - firstIndent);\n\n            if (newIndent < 0) {\n              return \"\";\n            } else if (cm.getOption(\"indentWithTabs\")) {\n              var quotient = Math.floor(newIndent / tabSize);\n              return Array(quotient + 1).join('\\t');\n            } else {\n              return Array(newIndent + 1).join(' ');\n            }\n          });\n          text += wasChomped ? \"\\n\" : \"\";\n        }\n\n        if (actionArgs.repeat > 1) {\n          var text = Array(actionArgs.repeat + 1).join(text);\n        }\n\n        var linewise = register.linewise;\n        var blockwise = register.blockwise;\n\n        if (blockwise) {\n          text = text.split('\\n');\n\n          if (linewise) {\n            text.pop();\n          }\n\n          for (var i = 0; i < text.length; i++) {\n            text[i] = text[i] == '' ? ' ' : text[i];\n          }\n\n          cur.ch += actionArgs.after ? 1 : 0;\n          cur.ch = Math.min(lineLength(cm, cur.line), cur.ch);\n        } else if (linewise) {\n          if (vim.visualMode) {\n            text = vim.visualLine ? text.slice(0, -1) : '\\n' + text.slice(0, text.length - 1) + '\\n';\n          } else if (actionArgs.after) {\n            // Move the newline at the end to the start instead, and paste just\n            // before the newline character of the line we are on right now.\n            text = '\\n' + text.slice(0, text.length - 1);\n            cur.ch = lineLength(cm, cur.line);\n          } else {\n            cur.ch = 0;\n          }\n        } else {\n          cur.ch += actionArgs.after ? 1 : 0;\n        }\n\n        var curPosFinal;\n        var idx;\n\n        if (vim.visualMode) {\n          //  save the pasted text for reselection if the need arises\n          vim.lastPastedText = text;\n          var lastSelectionCurEnd;\n          var selectedArea = getSelectedAreaRange(cm, vim);\n          var selectionStart = selectedArea[0];\n          var selectionEnd = selectedArea[1];\n          var selectedText = cm.getSelection();\n          var selections = cm.listSelections();\n          var emptyStrings = new Array(selections.length).join('1').split('1'); // save the curEnd marker before it get cleared due to cm.replaceRange.\n\n          if (vim.lastSelection) {\n            lastSelectionCurEnd = vim.lastSelection.headMark.find();\n          } // push the previously selected text to unnamed register\n\n\n          vimGlobalState.registerController.unnamedRegister.setText(selectedText);\n\n          if (blockwise) {\n            // first delete the selected text\n            cm.replaceSelections(emptyStrings); // Set new selections as per the block length of the yanked text\n\n            selectionEnd = Pos(selectionStart.line + text.length - 1, selectionStart.ch);\n            cm.setCursor(selectionStart);\n            selectBlock(cm, selectionEnd);\n            cm.replaceSelections(text);\n            curPosFinal = selectionStart;\n          } else if (vim.visualBlock) {\n            cm.replaceSelections(emptyStrings);\n            cm.setCursor(selectionStart);\n            cm.replaceRange(text, selectionStart, selectionStart);\n            curPosFinal = selectionStart;\n          } else {\n            cm.replaceRange(text, selectionStart, selectionEnd);\n            curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);\n          } // restore the the curEnd marker\n\n\n          if (lastSelectionCurEnd) {\n            vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);\n          }\n\n          if (linewise) {\n            curPosFinal.ch = 0;\n          }\n        } else {\n          if (blockwise) {\n            cm.setCursor(cur);\n\n            for (var i = 0; i < text.length; i++) {\n              var line = cur.line + i;\n\n              if (line > cm.lastLine()) {\n                cm.replaceRange('\\n', Pos(line, 0));\n              }\n\n              var lastCh = lineLength(cm, line);\n\n              if (lastCh < cur.ch) {\n                extendLineToColumn(cm, line, cur.ch);\n              }\n            }\n\n            cm.setCursor(cur);\n            selectBlock(cm, Pos(cur.line + text.length - 1, cur.ch));\n            cm.replaceSelections(text);\n            curPosFinal = cur;\n          } else {\n            cm.replaceRange(text, cur); // Now fine tune the cursor to where we want it.\n\n            if (linewise && actionArgs.after) {\n              curPosFinal = Pos(cur.line + 1, findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line + 1)));\n            } else if (linewise && !actionArgs.after) {\n              curPosFinal = Pos(cur.line, findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line)));\n            } else if (!linewise && actionArgs.after) {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length - 1);\n            } else {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length);\n            }\n          }\n        }\n\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n\n        cm.setCursor(curPosFinal);\n      },\n      undo: function (cm, actionArgs) {\n        cm.operation(function () {\n          repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();\n          cm.setCursor(cm.getCursor('anchor'));\n        });\n      },\n      redo: function (cm, actionArgs) {\n        repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();\n      },\n      setRegister: function (_cm, actionArgs, vim) {\n        vim.inputState.registerName = actionArgs.selectedCharacter;\n      },\n      setMark: function (cm, actionArgs, vim) {\n        var markName = actionArgs.selectedCharacter;\n        updateMark(cm, vim, markName, cm.getCursor());\n      },\n      replace: function (cm, actionArgs, vim) {\n        var replaceWith = actionArgs.selectedCharacter;\n        var curStart = cm.getCursor();\n        var replaceTo;\n        var curEnd;\n        var selections = cm.listSelections();\n\n        if (vim.visualMode) {\n          curStart = cm.getCursor('start');\n          curEnd = cm.getCursor('end');\n        } else {\n          var line = cm.getLine(curStart.line);\n          replaceTo = curStart.ch + actionArgs.repeat;\n\n          if (replaceTo > line.length) {\n            replaceTo = line.length;\n          }\n\n          curEnd = Pos(curStart.line, replaceTo);\n        }\n\n        if (replaceWith == '\\n') {\n          if (!vim.visualMode) cm.replaceRange('', curStart, curEnd); // special case, where vim help says to replace by just one line-break\n\n          (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);\n        } else {\n          var replaceWithStr = cm.getRange(curStart, curEnd); //replace all characters in range by selected, but keep linebreaks\n\n          replaceWithStr = replaceWithStr.replace(/[^\\n]/g, replaceWith);\n\n          if (vim.visualBlock) {\n            // Tabs are split in visua block before replacing\n            var spaces = new Array(cm.getOption(\"tabSize\") + 1).join(' ');\n            replaceWithStr = cm.getSelection();\n            replaceWithStr = replaceWithStr.replace(/\\t/g, spaces).replace(/[^\\n]/g, replaceWith).split('\\n');\n            cm.replaceSelections(replaceWithStr);\n          } else {\n            cm.replaceRange(replaceWithStr, curStart, curEnd);\n          }\n\n          if (vim.visualMode) {\n            curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ? selections[0].anchor : selections[0].head;\n            cm.setCursor(curStart);\n            exitVisualMode(cm, false);\n          } else {\n            cm.setCursor(offsetCursor(curEnd, 0, -1));\n          }\n        }\n      },\n      incrementNumberToken: function (cm, actionArgs) {\n        var cur = cm.getCursor();\n        var lineStr = cm.getLine(cur.line);\n        var re = /(-?)(?:(0x)([\\da-f]+)|(0b|0|)(\\d+))/gi;\n        var match;\n        var start;\n        var end;\n        var numberStr;\n\n        while ((match = re.exec(lineStr)) !== null) {\n          start = match.index;\n          end = start + match[0].length;\n          if (cur.ch < end) break;\n        }\n\n        if (!actionArgs.backtrack && end <= cur.ch) return;\n\n        if (match) {\n          var baseStr = match[2] || match[4];\n          var digits = match[3] || match[5];\n          var increment = actionArgs.increase ? 1 : -1;\n          var base = {\n            '0b': 2,\n            '0': 8,\n            '': 10,\n            '0x': 16\n          }[baseStr.toLowerCase()];\n          var number = parseInt(match[1] + digits, base) + increment * actionArgs.repeat;\n          numberStr = number.toString(base);\n          var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join('0') : '';\n\n          if (numberStr.charAt(0) === '-') {\n            numberStr = '-' + baseStr + zeroPadding + numberStr.substr(1);\n          } else {\n            numberStr = baseStr + zeroPadding + numberStr;\n          }\n\n          var from = Pos(cur.line, start);\n          var to = Pos(cur.line, end);\n          cm.replaceRange(numberStr, from, to);\n        } else {\n          return;\n        }\n\n        cm.setCursor(Pos(cur.line, start + numberStr.length - 1));\n      },\n      repeatLastEdit: function (cm, actionArgs, vim) {\n        var lastEditInputState = vim.lastEditInputState;\n\n        if (!lastEditInputState) {\n          return;\n        }\n\n        var repeat = actionArgs.repeat;\n\n        if (repeat && actionArgs.repeatIsExplicit) {\n          vim.lastEditInputState.repeatOverride = repeat;\n        } else {\n          repeat = vim.lastEditInputState.repeatOverride || repeat;\n        }\n\n        repeatLastEdit(cm, vim, repeat, false\n        /** repeatForInsert */\n        );\n      },\n      indent: function (cm, actionArgs) {\n        cm.indentLine(cm.getCursor().line, actionArgs.indentRight);\n      },\n      exitInsertMode: exitInsertMode\n    };\n\n    function defineAction(name, fn) {\n      actions[name] = fn;\n    }\n    /*\n     * Below are miscellaneous utility functions used by vim.js\n     */\n\n    /**\n     * Clips cursor to ensure that line is within the buffer's range\n     * If includeLineBreak is true, then allow cur.ch == lineLength.\n     */\n\n\n    function clipCursorToContent(cm, cur) {\n      var vim = cm.state.vim;\n      var includeLineBreak = vim.insertMode || vim.visualMode;\n      var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine());\n      var maxCh = lineLength(cm, line) - 1 + !!includeLineBreak;\n      var ch = Math.min(Math.max(0, cur.ch), maxCh);\n      return Pos(line, ch);\n    }\n\n    function copyArgs(args) {\n      var ret = {};\n\n      for (var prop in args) {\n        if (args.hasOwnProperty(prop)) {\n          ret[prop] = args[prop];\n        }\n      }\n\n      return ret;\n    }\n\n    function offsetCursor(cur, offsetLine, offsetCh) {\n      if (typeof offsetLine === 'object') {\n        offsetCh = offsetLine.ch;\n        offsetLine = offsetLine.line;\n      }\n\n      return Pos(cur.line + offsetLine, cur.ch + offsetCh);\n    }\n\n    function commandMatches(keys, keyMap, context, inputState) {\n      // Partial matches are not applied. They inform the key handler\n      // that the current key sequence is a subsequence of a valid key\n      // sequence, so that the key buffer is not cleared.\n      var match,\n          partial = [],\n          full = [];\n\n      for (var i = 0; i < keyMap.length; i++) {\n        var command = keyMap[i];\n\n        if (context == 'insert' && command.context != 'insert' || command.context && command.context != context || inputState.operator && command.type == 'action' || !(match = commandMatch(keys, command.keys))) {\n          continue;\n        }\n\n        if (match == 'partial') {\n          partial.push(command);\n        }\n\n        if (match == 'full') {\n          full.push(command);\n        }\n      }\n\n      return {\n        partial: partial.length && partial,\n        full: full.length && full\n      };\n    }\n\n    function commandMatch(pressed, mapped) {\n      if (mapped.slice(-11) == '<character>') {\n        // Last character matches anything.\n        var prefixLen = mapped.length - 11;\n        var pressedPrefix = pressed.slice(0, prefixLen);\n        var mappedPrefix = mapped.slice(0, prefixLen);\n        return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' : mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;\n      } else {\n        return pressed == mapped ? 'full' : mapped.indexOf(pressed) == 0 ? 'partial' : false;\n      }\n    }\n\n    function lastChar(keys) {\n      var match = /^.*(<[^>]+>)$/.exec(keys);\n      var selectedCharacter = match ? match[1] : keys.slice(-1);\n\n      if (selectedCharacter.length > 1) {\n        switch (selectedCharacter) {\n          case '<CR>':\n            selectedCharacter = '\\n';\n            break;\n\n          case '<Space>':\n            selectedCharacter = ' ';\n            break;\n\n          default:\n            selectedCharacter = '';\n            break;\n        }\n      }\n\n      return selectedCharacter;\n    }\n\n    function repeatFn(cm, fn, repeat) {\n      return function () {\n        for (var i = 0; i < repeat; i++) {\n          fn(cm);\n        }\n      };\n    }\n\n    function copyCursor(cur) {\n      return Pos(cur.line, cur.ch);\n    }\n\n    function cursorEqual(cur1, cur2) {\n      return cur1.ch == cur2.ch && cur1.line == cur2.line;\n    }\n\n    function cursorIsBefore(cur1, cur2) {\n      if (cur1.line < cur2.line) {\n        return true;\n      }\n\n      if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\n        return true;\n      }\n\n      return false;\n    }\n\n    function cursorMin(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n\n      return cursorIsBefore(cur1, cur2) ? cur1 : cur2;\n    }\n\n    function cursorMax(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n\n      return cursorIsBefore(cur1, cur2) ? cur2 : cur1;\n    }\n\n    function cursorIsBetween(cur1, cur2, cur3) {\n      // returns true if cur2 is between cur1 and cur3.\n      var cur1before2 = cursorIsBefore(cur1, cur2);\n      var cur2before3 = cursorIsBefore(cur2, cur3);\n      return cur1before2 && cur2before3;\n    }\n\n    function lineLength(cm, lineNum) {\n      return cm.getLine(lineNum).length;\n    }\n\n    function trim(s) {\n      if (s.trim) {\n        return s.trim();\n      }\n\n      return s.replace(/^\\s+|\\s+$/g, '');\n    }\n\n    function escapeRegex(s) {\n      return s.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g, '\\\\$1');\n    }\n\n    function extendLineToColumn(cm, lineNum, column) {\n      var endCh = lineLength(cm, lineNum);\n      var spaces = new Array(column - endCh + 1).join(' ');\n      cm.setCursor(Pos(lineNum, endCh));\n      cm.replaceRange(spaces, cm.getCursor());\n    } // This functions selects a rectangular block\n    // of text with selectionEnd as any of its corner\n    // Height of block:\n    // Difference in selectionEnd.line and first/last selection.line\n    // Width of the block:\n    // Distance between selectionEnd.ch and any(first considered here) selection.ch\n\n\n    function selectBlock(cm, selectionEnd) {\n      var selections = [],\n          ranges = cm.listSelections();\n      var head = copyCursor(cm.clipPos(selectionEnd));\n      var isClipped = !cursorEqual(selectionEnd, head);\n      var curHead = cm.getCursor('head');\n      var primIndex = getIndex(ranges, curHead);\n      var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);\n      var max = ranges.length - 1;\n      var index = max - primIndex > primIndex ? max : 0;\n      var base = ranges[index].anchor;\n      var firstLine = Math.min(base.line, head.line);\n      var lastLine = Math.max(base.line, head.line);\n      var baseCh = base.ch,\n          headCh = head.ch;\n      var dir = ranges[index].head.ch - baseCh;\n      var newDir = headCh - baseCh;\n\n      if (dir > 0 && newDir <= 0) {\n        baseCh++;\n\n        if (!isClipped) {\n          headCh--;\n        }\n      } else if (dir < 0 && newDir >= 0) {\n        baseCh--;\n\n        if (!wasClipped) {\n          headCh++;\n        }\n      } else if (dir < 0 && newDir == -1) {\n        baseCh--;\n        headCh++;\n      }\n\n      for (var line = firstLine; line <= lastLine; line++) {\n        var range = {\n          anchor: new Pos(line, baseCh),\n          head: new Pos(line, headCh)\n        };\n        selections.push(range);\n      }\n\n      cm.setSelections(selections);\n      selectionEnd.ch = headCh;\n      base.ch = baseCh;\n      return base;\n    }\n\n    function selectForInsert(cm, head, height) {\n      var sel = [];\n\n      for (var i = 0; i < height; i++) {\n        var lineHead = offsetCursor(head, i, 0);\n        sel.push({\n          anchor: lineHead,\n          head: lineHead\n        });\n      }\n\n      cm.setSelections(sel, 0);\n    } // getIndex returns the index of the cursor in the selections.\n\n\n    function getIndex(ranges, cursor, end) {\n      for (var i = 0; i < ranges.length; i++) {\n        var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor);\n        var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor);\n\n        if (atAnchor || atHead) {\n          return i;\n        }\n      }\n\n      return -1;\n    }\n\n    function getSelectedAreaRange(cm, vim) {\n      var lastSelection = vim.lastSelection;\n\n      var getCurrentSelectedAreaRange = function () {\n        var selections = cm.listSelections();\n        var start = selections[0];\n        var end = selections[selections.length - 1];\n        var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;\n        var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;\n        return [selectionStart, selectionEnd];\n      };\n\n      var getLastSelectedAreaRange = function () {\n        var selectionStart = cm.getCursor();\n        var selectionEnd = cm.getCursor();\n        var block = lastSelection.visualBlock;\n\n        if (block) {\n          var width = block.width;\n          var height = block.height;\n          selectionEnd = Pos(selectionStart.line + height, selectionStart.ch + width);\n          var selections = []; // selectBlock creates a 'proper' rectangular block.\n          // We do not want that in all cases, so we manually set selections.\n\n          for (var i = selectionStart.line; i < selectionEnd.line; i++) {\n            var anchor = Pos(i, selectionStart.ch);\n            var head = Pos(i, selectionEnd.ch);\n            var range = {\n              anchor: anchor,\n              head: head\n            };\n            selections.push(range);\n          }\n\n          cm.setSelections(selections);\n        } else {\n          var start = lastSelection.anchorMark.find();\n          var end = lastSelection.headMark.find();\n          var line = end.line - start.line;\n          var ch = end.ch - start.ch;\n          selectionEnd = {\n            line: selectionEnd.line + line,\n            ch: line ? selectionEnd.ch : ch + selectionEnd.ch\n          };\n\n          if (lastSelection.visualLine) {\n            selectionStart = Pos(selectionStart.line, 0);\n            selectionEnd = Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));\n          }\n\n          cm.setSelection(selectionStart, selectionEnd);\n        }\n\n        return [selectionStart, selectionEnd];\n      };\n\n      if (!vim.visualMode) {\n        // In case of replaying the action.\n        return getLastSelectedAreaRange();\n      } else {\n        return getCurrentSelectedAreaRange();\n      }\n    } // Updates the previous selection with the current selection's values. This\n    // should only be called in visual mode.\n\n\n    function updateLastSelection(cm, vim) {\n      var anchor = vim.sel.anchor;\n      var head = vim.sel.head; // To accommodate the effect of lastPastedText in the last selection\n\n      if (vim.lastPastedText) {\n        head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);\n        vim.lastPastedText = null;\n      }\n\n      vim.lastSelection = {\n        'anchorMark': cm.setBookmark(anchor),\n        'headMark': cm.setBookmark(head),\n        'anchor': copyCursor(anchor),\n        'head': copyCursor(head),\n        'visualMode': vim.visualMode,\n        'visualLine': vim.visualLine,\n        'visualBlock': vim.visualBlock\n      };\n    }\n\n    function expandSelection(cm, start, end) {\n      var sel = cm.state.vim.sel;\n      var head = sel.head;\n      var anchor = sel.anchor;\n      var tmp;\n\n      if (cursorIsBefore(end, start)) {\n        tmp = end;\n        end = start;\n        start = tmp;\n      }\n\n      if (cursorIsBefore(head, anchor)) {\n        head = cursorMin(start, head);\n        anchor = cursorMax(anchor, end);\n      } else {\n        anchor = cursorMin(start, anchor);\n        head = cursorMax(head, end);\n        head = offsetCursor(head, 0, -1);\n\n        if (head.ch == -1 && head.line != cm.firstLine()) {\n          head = Pos(head.line - 1, lineLength(cm, head.line - 1));\n        }\n      }\n\n      return [anchor, head];\n    }\n    /**\n     * Updates the CodeMirror selection to match the provided vim selection.\n     * If no arguments are given, it uses the current vim selection state.\n     */\n\n\n    function updateCmSelection(cm, sel, mode) {\n      var vim = cm.state.vim;\n      sel = sel || vim.sel;\n      var mode = mode || vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';\n      var cmSel = makeCmSelection(cm, sel, mode);\n      cm.setSelections(cmSel.ranges, cmSel.primary);\n      updateFakeCursor(cm);\n    }\n\n    function makeCmSelection(cm, sel, mode, exclusive) {\n      var head = copyCursor(sel.head);\n      var anchor = copyCursor(sel.anchor);\n\n      if (mode == 'char') {\n        var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        head = offsetCursor(sel.head, 0, headOffset);\n        anchor = offsetCursor(sel.anchor, 0, anchorOffset);\n        return {\n          ranges: [{\n            anchor: anchor,\n            head: head\n          }],\n          primary: 0\n        };\n      } else if (mode == 'line') {\n        if (!cursorIsBefore(sel.head, sel.anchor)) {\n          anchor.ch = 0;\n          var lastLine = cm.lastLine();\n\n          if (head.line > lastLine) {\n            head.line = lastLine;\n          }\n\n          head.ch = lineLength(cm, head.line);\n        } else {\n          head.ch = 0;\n          anchor.ch = lineLength(cm, anchor.line);\n        }\n\n        return {\n          ranges: [{\n            anchor: anchor,\n            head: head\n          }],\n          primary: 0\n        };\n      } else if (mode == 'block') {\n        var top = Math.min(anchor.line, head.line),\n            left = Math.min(anchor.ch, head.ch),\n            bottom = Math.max(anchor.line, head.line),\n            right = Math.max(anchor.ch, head.ch) + 1;\n        var height = bottom - top + 1;\n        var primary = head.line == top ? 0 : height - 1;\n        var ranges = [];\n\n        for (var i = 0; i < height; i++) {\n          ranges.push({\n            anchor: Pos(top + i, left),\n            head: Pos(top + i, right)\n          });\n        }\n\n        return {\n          ranges: ranges,\n          primary: primary\n        };\n      }\n    }\n\n    function getHead(cm) {\n      var cur = cm.getCursor('head');\n\n      if (cm.getSelection().length == 1) {\n        // Small corner case when only 1 character is selected. The \"real\"\n        // head is the left of head and anchor.\n        cur = cursorMin(cur, cm.getCursor('anchor'));\n      }\n\n      return cur;\n    }\n    /**\n     * If moveHead is set to false, the CodeMirror selection will not be\n     * touched. The caller assumes the responsibility of putting the cursor\n    * in the right place.\n     */\n\n\n    function exitVisualMode(cm, moveHead) {\n      var vim = cm.state.vim;\n\n      if (moveHead !== false) {\n        cm.setCursor(clipCursorToContent(cm, vim.sel.head));\n      }\n\n      updateLastSelection(cm, vim);\n      vim.visualMode = false;\n      vim.visualLine = false;\n      vim.visualBlock = false;\n      if (!vim.insertMode) CodeMirror.signal(cm, \"vim-mode-change\", {\n        mode: \"normal\"\n      });\n      clearFakeCursor(vim);\n    } // Remove any trailing newlines from the selection. For\n    // example, with the caret at the start of the last word on the line,\n    // 'dw' should word, but not the newline, while 'w' should advance the\n    // caret to the first character of the next line.\n\n\n    function clipToLine(cm, curStart, curEnd) {\n      var selection = cm.getRange(curStart, curEnd); // Only clip if the selection ends with trailing newline + whitespace\n\n      if (/\\n\\s*$/.test(selection)) {\n        var lines = selection.split('\\n'); // We know this is all whitespace.\n\n        lines.pop(); // Cases:\n        // 1. Last word is an empty line - do not clip the trailing '\\n'\n        // 2. Last word is not an empty line - clip the trailing '\\n'\n\n        var line; // Find the line containing the last word, and clip all whitespace up\n        // to it.\n\n        for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {\n          curEnd.line--;\n          curEnd.ch = 0;\n        } // If the last word is not an empty line, clip an additional newline\n\n\n        if (line) {\n          curEnd.line--;\n          curEnd.ch = lineLength(cm, curEnd.line);\n        } else {\n          curEnd.ch = 0;\n        }\n      }\n    } // Expand the selection to line ends.\n\n\n    function expandSelectionToLine(_cm, curStart, curEnd) {\n      curStart.ch = 0;\n      curEnd.ch = 0;\n      curEnd.line++;\n    }\n\n    function findFirstNonWhiteSpaceCharacter(text) {\n      if (!text) {\n        return 0;\n      }\n\n      var firstNonWS = text.search(/\\S/);\n      return firstNonWS == -1 ? text.length : firstNonWS;\n    }\n\n    function expandWordUnderCursor(cm, inclusive, _forward, bigWord, noSymbol) {\n      var cur = getHead(cm);\n      var line = cm.getLine(cur.line);\n      var idx = cur.ch; // Seek to first word or non-whitespace character, depending on if\n      // noSymbol is true.\n\n      var test = noSymbol ? wordCharTest[0] : bigWordCharTest[0];\n\n      while (!test(line.charAt(idx))) {\n        idx++;\n\n        if (idx >= line.length) {\n          return null;\n        }\n      }\n\n      if (bigWord) {\n        test = bigWordCharTest[0];\n      } else {\n        test = wordCharTest[0];\n\n        if (!test(line.charAt(idx))) {\n          test = wordCharTest[1];\n        }\n      }\n\n      var end = idx,\n          start = idx;\n\n      while (test(line.charAt(end)) && end < line.length) {\n        end++;\n      }\n\n      while (test(line.charAt(start)) && start >= 0) {\n        start--;\n      }\n\n      start++;\n\n      if (inclusive) {\n        // If present, include all whitespace after word.\n        // Otherwise, include all whitespace before word, except indentation.\n        var wordEnd = end;\n\n        while (/\\s/.test(line.charAt(end)) && end < line.length) {\n          end++;\n        }\n\n        if (wordEnd == end) {\n          var wordStart = start;\n\n          while (/\\s/.test(line.charAt(start - 1)) && start > 0) {\n            start--;\n          }\n\n          if (!start) {\n            start = wordStart;\n          }\n        }\n      }\n\n      return {\n        start: Pos(cur.line, start),\n        end: Pos(cur.line, end)\n      };\n    }\n    /**\n     * Depends on the following:\n     *\n     * - editor mode should be htmlmixedmode / xml\n     * - mode/xml/xml.js should be loaded\n     * - addon/fold/xml-fold.js should be loaded\n     *\n     * If any of the above requirements are not true, this function noops.\n     *\n     * This is _NOT_ a 100% accurate implementation of vim tag text objects.\n     * The following caveats apply (based off cursory testing, I'm sure there\n     * are other discrepancies):\n     *\n     * - Does not work inside comments:\n     *   ```\n     *   <!-- <div>broken</div> -->\n     *   ```\n     * - Does not work when tags have different cases:\n     *   ```\n     *   <div>broken</DIV>\n     *   ```\n     * - Does not work when cursor is inside a broken tag:\n     *   ```\n     *   <div><brok><en></div>\n     *   ```\n     */\n\n\n    function expandTagUnderCursor(cm, head, inclusive) {\n      var cur = head;\n\n      if (!CodeMirror.findMatchingTag || !CodeMirror.findEnclosingTag) {\n        return {\n          start: cur,\n          end: cur\n        };\n      }\n\n      var tags = CodeMirror.findMatchingTag(cm, head) || CodeMirror.findEnclosingTag(cm, head);\n\n      if (!tags || !tags.open || !tags.close) {\n        return {\n          start: cur,\n          end: cur\n        };\n      }\n\n      if (inclusive) {\n        return {\n          start: tags.open.from,\n          end: tags.close.to\n        };\n      }\n\n      return {\n        start: tags.open.to,\n        end: tags.close.from\n      };\n    }\n\n    function recordJumpPosition(cm, oldCur, newCur) {\n      if (!cursorEqual(oldCur, newCur)) {\n        vimGlobalState.jumpList.add(cm, oldCur, newCur);\n      }\n    }\n\n    function recordLastCharacterSearch(increment, args) {\n      vimGlobalState.lastCharacterSearch.increment = increment;\n      vimGlobalState.lastCharacterSearch.forward = args.forward;\n      vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;\n    }\n\n    var symbolToMode = {\n      '(': 'bracket',\n      ')': 'bracket',\n      '{': 'bracket',\n      '}': 'bracket',\n      '[': 'section',\n      ']': 'section',\n      '*': 'comment',\n      '/': 'comment',\n      'm': 'method',\n      'M': 'method',\n      '#': 'preprocess'\n    };\n    var findSymbolModes = {\n      bracket: {\n        isComplete: function (state) {\n          if (state.nextCh === state.symb) {\n            state.depth++;\n            if (state.depth >= 1) return true;\n          } else if (state.nextCh === state.reverseSymb) {\n            state.depth--;\n          }\n\n          return false;\n        }\n      },\n      section: {\n        init: function (state) {\n          state.curMoveThrough = true;\n          state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';\n        },\n        isComplete: function (state) {\n          return state.index === 0 && state.nextCh === state.symb;\n        }\n      },\n      comment: {\n        isComplete: function (state) {\n          var found = state.lastCh === '*' && state.nextCh === '/';\n          state.lastCh = state.nextCh;\n          return found;\n        }\n      },\n      // TODO: The original Vim implementation only operates on level 1 and 2.\n      // The current implementation doesn't check for code block level and\n      // therefore it operates on any levels.\n      method: {\n        init: function (state) {\n          state.symb = state.symb === 'm' ? '{' : '}';\n          state.reverseSymb = state.symb === '{' ? '}' : '{';\n        },\n        isComplete: function (state) {\n          if (state.nextCh === state.symb) return true;\n          return false;\n        }\n      },\n      preprocess: {\n        init: function (state) {\n          state.index = 0;\n        },\n        isComplete: function (state) {\n          if (state.nextCh === '#') {\n            var token = state.lineText.match(/^#(\\w+)/)[1];\n\n            if (token === 'endif') {\n              if (state.forward && state.depth === 0) {\n                return true;\n              }\n\n              state.depth++;\n            } else if (token === 'if') {\n              if (!state.forward && state.depth === 0) {\n                return true;\n              }\n\n              state.depth--;\n            }\n\n            if (token === 'else' && state.depth === 0) return true;\n          }\n\n          return false;\n        }\n      }\n    };\n\n    function findSymbol(cm, repeat, forward, symb) {\n      var cur = copyCursor(cm.getCursor());\n      var increment = forward ? 1 : -1;\n      var endLine = forward ? cm.lineCount() : -1;\n      var curCh = cur.ch;\n      var line = cur.line;\n      var lineText = cm.getLine(line);\n      var state = {\n        lineText: lineText,\n        nextCh: lineText.charAt(curCh),\n        lastCh: null,\n        index: curCh,\n        symb: symb,\n        reverseSymb: (forward ? {\n          ')': '(',\n          '}': '{'\n        } : {\n          '(': ')',\n          '{': '}'\n        })[symb],\n        forward: forward,\n        depth: 0,\n        curMoveThrough: false\n      };\n      var mode = symbolToMode[symb];\n      if (!mode) return cur;\n      var init = findSymbolModes[mode].init;\n      var isComplete = findSymbolModes[mode].isComplete;\n\n      if (init) {\n        init(state);\n      }\n\n      while (line !== endLine && repeat) {\n        state.index += increment;\n        state.nextCh = state.lineText.charAt(state.index);\n\n        if (!state.nextCh) {\n          line += increment;\n          state.lineText = cm.getLine(line) || '';\n\n          if (increment > 0) {\n            state.index = 0;\n          } else {\n            var lineLen = state.lineText.length;\n            state.index = lineLen > 0 ? lineLen - 1 : 0;\n          }\n\n          state.nextCh = state.lineText.charAt(state.index);\n        }\n\n        if (isComplete(state)) {\n          cur.line = line;\n          cur.ch = state.index;\n          repeat--;\n        }\n      }\n\n      if (state.nextCh || state.curMoveThrough) {\n        return Pos(line, state.index);\n      }\n\n      return cur;\n    }\n    /*\n     * Returns the boundaries of the next word. If the cursor in the middle of\n     * the word, then returns the boundaries of the current word, starting at\n     * the cursor. If the cursor is at the start/end of a word, and we are going\n     * forward/backward, respectively, find the boundaries of the next word.\n     *\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Cursor} cur The cursor position.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only [a-zA-Z0-9] characters count as part of the word.\n     * @param {boolean} emptyLineIsWord True if empty lines should be treated\n     *     as words.\n     * @return {Object{from:number, to:number, line: number}} The boundaries of\n     *     the word, or null if there are no more words.\n     */\n\n\n    function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {\n      var lineNum = cur.line;\n      var pos = cur.ch;\n      var line = cm.getLine(lineNum);\n      var dir = forward ? 1 : -1;\n      var charTests = bigWord ? bigWordCharTest : wordCharTest;\n\n      if (emptyLineIsWord && line == '') {\n        lineNum += dir;\n        line = cm.getLine(lineNum);\n\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n\n        pos = forward ? 0 : line.length;\n      }\n\n      while (true) {\n        if (emptyLineIsWord && line == '') {\n          return {\n            from: 0,\n            to: 0,\n            line: lineNum\n          };\n        }\n\n        var stop = dir > 0 ? line.length : -1;\n        var wordStart = stop,\n            wordEnd = stop; // Find bounds of next word.\n\n        while (pos != stop) {\n          var foundWord = false;\n\n          for (var i = 0; i < charTests.length && !foundWord; ++i) {\n            if (charTests[i](line.charAt(pos))) {\n              wordStart = pos; // Advance to end of word.\n\n              while (pos != stop && charTests[i](line.charAt(pos))) {\n                pos += dir;\n              }\n\n              wordEnd = pos;\n              foundWord = wordStart != wordEnd;\n\n              if (wordStart == cur.ch && lineNum == cur.line && wordEnd == wordStart + dir) {\n                // We started at the end of a word. Find the next one.\n                continue;\n              } else {\n                return {\n                  from: Math.min(wordStart, wordEnd + 1),\n                  to: Math.max(wordStart, wordEnd),\n                  line: lineNum\n                };\n              }\n            }\n          }\n\n          if (!foundWord) {\n            pos += dir;\n          }\n        } // Advance to next/prev line.\n\n\n        lineNum += dir;\n\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n\n        line = cm.getLine(lineNum);\n        pos = dir > 0 ? 0 : line.length;\n      }\n    }\n    /**\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Pos} cur The position to start from.\n     * @param {int} repeat Number of words to move past.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} wordEnd True to move to end of word. False to move to\n     *     beginning of word.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only alphabet characters count as part of the word.\n     * @return {Cursor} The position the cursor should move to.\n     */\n\n\n    function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {\n      var curStart = copyCursor(cur);\n      var words = [];\n\n      if (forward && !wordEnd || !forward && wordEnd) {\n        repeat++;\n      } // For 'e', empty lines are not considered words, go figure.\n\n\n      var emptyLineIsWord = !(forward && wordEnd);\n\n      for (var i = 0; i < repeat; i++) {\n        var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);\n\n        if (!word) {\n          var eodCh = lineLength(cm, cm.lastLine());\n          words.push(forward ? {\n            line: cm.lastLine(),\n            from: eodCh,\n            to: eodCh\n          } : {\n            line: 0,\n            from: 0,\n            to: 0\n          });\n          break;\n        }\n\n        words.push(word);\n        cur = Pos(word.line, forward ? word.to - 1 : word.from);\n      }\n\n      var shortCircuit = words.length != repeat;\n      var firstWord = words[0];\n      var lastWord = words.pop();\n\n      if (forward && !wordEnd) {\n        // w\n        if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n\n        return Pos(lastWord.line, lastWord.from);\n      } else if (forward && wordEnd) {\n        return Pos(lastWord.line, lastWord.to - 1);\n      } else if (!forward && wordEnd) {\n        // ge\n        if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n\n        return Pos(lastWord.line, lastWord.to);\n      } else {\n        // b\n        return Pos(lastWord.line, lastWord.from);\n      }\n    }\n\n    function moveToEol(cm, head, motionArgs, vim, keepHPos) {\n      var cur = head;\n      var retval = Pos(cur.line + motionArgs.repeat - 1, Infinity);\n      var end = cm.clipPos(retval);\n      end.ch--;\n\n      if (!keepHPos) {\n        vim.lastHPos = Infinity;\n        vim.lastHSPos = cm.charCoords(end, 'div').left;\n      }\n\n      return retval;\n    }\n\n    function moveToCharacter(cm, repeat, forward, character) {\n      var cur = cm.getCursor();\n      var start = cur.ch;\n      var idx;\n\n      for (var i = 0; i < repeat; i++) {\n        var line = cm.getLine(cur.line);\n        idx = charIdxInLine(start, line, character, forward, true);\n\n        if (idx == -1) {\n          return null;\n        }\n\n        start = idx;\n      }\n\n      return Pos(cm.getCursor().line, idx);\n    }\n\n    function moveToColumn(cm, repeat) {\n      // repeat is always >= 1, so repeat - 1 always corresponds\n      // to the column we want to go to.\n      var line = cm.getCursor().line;\n      return clipCursorToContent(cm, Pos(line, repeat - 1));\n    }\n\n    function updateMark(cm, vim, markName, pos) {\n      if (!inArray(markName, validMarks)) {\n        return;\n      }\n\n      if (vim.marks[markName]) {\n        vim.marks[markName].clear();\n      }\n\n      vim.marks[markName] = cm.setBookmark(pos);\n    }\n\n    function charIdxInLine(start, line, character, forward, includeChar) {\n      // Search for char in line.\n      // motion_options: {forward, includeChar}\n      // If includeChar = true, include it too.\n      // If forward = true, search forward, else search backwards.\n      // If char is not found on this line, do nothing\n      var idx;\n\n      if (forward) {\n        idx = line.indexOf(character, start + 1);\n\n        if (idx != -1 && !includeChar) {\n          idx -= 1;\n        }\n      } else {\n        idx = line.lastIndexOf(character, start - 1);\n\n        if (idx != -1 && !includeChar) {\n          idx += 1;\n        }\n      }\n\n      return idx;\n    }\n\n    function findParagraph(cm, head, repeat, dir, inclusive) {\n      var line = head.line;\n      var min = cm.firstLine();\n      var max = cm.lastLine();\n      var start,\n          end,\n          i = line;\n\n      function isEmpty(i) {\n        return !cm.getLine(i);\n      }\n\n      function isBoundary(i, dir, any) {\n        if (any) {\n          return isEmpty(i) != isEmpty(i + dir);\n        }\n\n        return !isEmpty(i) && isEmpty(i + dir);\n      }\n\n      if (dir) {\n        while (min <= i && i <= max && repeat > 0) {\n          if (isBoundary(i, dir)) {\n            repeat--;\n          }\n\n          i += dir;\n        }\n\n        return new Pos(i, 0);\n      }\n\n      var vim = cm.state.vim;\n\n      if (vim.visualLine && isBoundary(line, 1, true)) {\n        var anchor = vim.sel.anchor;\n\n        if (isBoundary(anchor.line, -1, true)) {\n          if (!inclusive || anchor.line != line) {\n            line += 1;\n          }\n        }\n      }\n\n      var startState = isEmpty(line);\n\n      for (i = line; i <= max && repeat; i++) {\n        if (isBoundary(i, 1, true)) {\n          if (!inclusive || isEmpty(i) != startState) {\n            repeat--;\n          }\n        }\n      }\n\n      end = new Pos(i, 0); // select boundary before paragraph for the last one\n\n      if (i > max && !startState) {\n        startState = true;\n      } else {\n        inclusive = false;\n      }\n\n      for (i = line; i > min; i--) {\n        if (!inclusive || isEmpty(i) == startState || i == line) {\n          if (isBoundary(i, -1, true)) {\n            break;\n          }\n        }\n      }\n\n      start = new Pos(i, 0);\n      return {\n        start: start,\n        end: end\n      };\n    }\n\n    function findSentence(cm, cur, repeat, dir) {\n      /*\n        Takes an index object\n        {\n          line: the line string,\n          ln: line number,\n          pos: index in line,\n          dir: direction of traversal (-1 or 1)\n        }\n        and modifies the line, ln, and pos members to represent the\n        next valid position or sets them to null if there are\n        no more valid positions.\n       */\n      function nextChar(cm, idx) {\n        if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {\n          idx.ln += idx.dir;\n\n          if (!isLine(cm, idx.ln)) {\n            idx.line = null;\n            idx.ln = null;\n            idx.pos = null;\n            return;\n          }\n\n          idx.line = cm.getLine(idx.ln);\n          idx.pos = idx.dir > 0 ? 0 : idx.line.length - 1;\n        } else {\n          idx.pos += idx.dir;\n        }\n      }\n      /*\n        Performs one iteration of traversal in forward direction\n        Returns an index object of the new location\n       */\n\n\n      function forward(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n        var stop = line === \"\";\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir\n        };\n        var last_valid = {\n          ln: curr.ln,\n          pos: curr.pos\n        };\n        var skip_empty_lines = curr.line === \"\"; // Move one step to skip character we start on\n\n        nextChar(cm, curr);\n\n        while (curr.line !== null) {\n          last_valid.ln = curr.ln;\n          last_valid.pos = curr.pos;\n\n          if (curr.line === \"\" && !skip_empty_lines) {\n            return {\n              ln: curr.ln,\n              pos: curr.pos\n            };\n          } else if (stop && curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n            return {\n              ln: curr.ln,\n              pos: curr.pos\n            };\n          } else if (isEndOfSentenceSymbol(curr.line[curr.pos]) && !stop && (curr.pos === curr.line.length - 1 || isWhiteSpaceString(curr.line[curr.pos + 1]))) {\n            stop = true;\n          }\n\n          nextChar(cm, curr);\n        }\n        /*\n          Set the position to the last non whitespace character on the last\n          valid line in the case that we reach the end of the document.\n        */\n\n\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n\n        for (var i = line.length - 1; i >= 0; --i) {\n          if (!isWhiteSpaceString(line[i])) {\n            last_valid.pos = i;\n            break;\n          }\n        }\n\n        return last_valid;\n      }\n      /*\n        Performs one iteration of traversal in reverse direction\n        Returns an index object of the new location\n       */\n\n\n      function reverse(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir\n        };\n        var last_valid = {\n          ln: curr.ln,\n          pos: null\n        };\n        var skip_empty_lines = curr.line === \"\"; // Move one step to skip character we start on\n\n        nextChar(cm, curr);\n\n        while (curr.line !== null) {\n          if (curr.line === \"\" && !skip_empty_lines) {\n            if (last_valid.pos !== null) {\n              return last_valid;\n            } else {\n              return {\n                ln: curr.ln,\n                pos: curr.pos\n              };\n            }\n          } else if (isEndOfSentenceSymbol(curr.line[curr.pos]) && last_valid.pos !== null && !(curr.ln === last_valid.ln && curr.pos + 1 === last_valid.pos)) {\n            return last_valid;\n          } else if (curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n            skip_empty_lines = false;\n            last_valid = {\n              ln: curr.ln,\n              pos: curr.pos\n            };\n          }\n\n          nextChar(cm, curr);\n        }\n        /*\n          Set the position to the first non whitespace character on the last\n          valid line in the case that we reach the beginning of the document.\n        */\n\n\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n\n        for (var i = 0; i < line.length; ++i) {\n          if (!isWhiteSpaceString(line[i])) {\n            last_valid.pos = i;\n            break;\n          }\n        }\n\n        return last_valid;\n      }\n\n      var curr_index = {\n        ln: cur.line,\n        pos: cur.ch\n      };\n\n      while (repeat > 0) {\n        if (dir < 0) {\n          curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n        } else {\n          curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n        }\n\n        repeat--;\n      }\n\n      return Pos(curr_index.ln, curr_index.pos);\n    } // TODO: perhaps this finagling of start and end positions belongs\n    // in codemirror/replaceRange?\n\n\n    function selectCompanionObject(cm, head, symb, inclusive) {\n      var cur = head,\n          start,\n          end;\n      var bracketRegexp = {\n        '(': /[()]/,\n        ')': /[()]/,\n        '[': /[[\\]]/,\n        ']': /[[\\]]/,\n        '{': /[{}]/,\n        '}': /[{}]/,\n        '<': /[<>]/,\n        '>': /[<>]/\n      }[symb];\n      var openSym = {\n        '(': '(',\n        ')': '(',\n        '[': '[',\n        ']': '[',\n        '{': '{',\n        '}': '{',\n        '<': '<',\n        '>': '<'\n      }[symb];\n      var curChar = cm.getLine(cur.line).charAt(cur.ch); // Due to the behavior of scanForBracket, we need to add an offset if the\n      // cursor is on a matching open bracket.\n\n      var offset = curChar === openSym ? 1 : 0;\n      start = cm.scanForBracket(Pos(cur.line, cur.ch + offset), -1, undefined, {\n        'bracketRegex': bracketRegexp\n      });\n      end = cm.scanForBracket(Pos(cur.line, cur.ch + offset), 1, undefined, {\n        'bracketRegex': bracketRegexp\n      });\n\n      if (!start || !end) {\n        return {\n          start: cur,\n          end: cur\n        };\n      }\n\n      start = start.pos;\n      end = end.pos;\n\n      if (start.line == end.line && start.ch > end.ch || start.line > end.line) {\n        var tmp = start;\n        start = end;\n        end = tmp;\n      }\n\n      if (inclusive) {\n        end.ch += 1;\n      } else {\n        start.ch += 1;\n      }\n\n      return {\n        start: start,\n        end: end\n      };\n    } // Takes in a symbol and a cursor and tries to simulate text objects that\n    // have identical opening and closing symbols\n    // TODO support across multiple lines\n\n\n    function findBeginningAndEnd(cm, head, symb, inclusive) {\n      var cur = copyCursor(head);\n      var line = cm.getLine(cur.line);\n      var chars = line.split('');\n      var start, end, i, len;\n      var firstIndex = chars.indexOf(symb); // the decision tree is to always look backwards for the beginning first,\n      // but if the cursor is in front of the first instance of the symb,\n      // then move the cursor forward\n\n      if (cur.ch < firstIndex) {\n        cur.ch = firstIndex; // Why is this line even here???\n        // cm.setCursor(cur.line, firstIndex+1);\n      } // otherwise if the cursor is currently on the closing symbol\n      else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\n        end = cur.ch; // assign end to the current cursor\n\n        --cur.ch; // make sure to look backwards\n      } // if we're currently on the symbol, we've got a start\n\n\n      if (chars[cur.ch] == symb && !end) {\n        start = cur.ch + 1; // assign start to ahead of the cursor\n      } else {\n        // go backwards to find the start\n        for (i = cur.ch; i > -1 && !start; i--) {\n          if (chars[i] == symb) {\n            start = i + 1;\n          }\n        }\n      } // look forwards for the end symbol\n\n\n      if (start && !end) {\n        for (i = start, len = chars.length; i < len && !end; i++) {\n          if (chars[i] == symb) {\n            end = i;\n          }\n        }\n      } // nothing found\n\n\n      if (!start || !end) {\n        return {\n          start: cur,\n          end: cur\n        };\n      } // include the symbols\n\n\n      if (inclusive) {\n        --start;\n        ++end;\n      }\n\n      return {\n        start: Pos(cur.line, start),\n        end: Pos(cur.line, end)\n      };\n    } // Search functions\n\n\n    defineOption('pcre', true, 'boolean');\n\n    function SearchState() {}\n\n    SearchState.prototype = {\n      getQuery: function () {\n        return vimGlobalState.query;\n      },\n      setQuery: function (query) {\n        vimGlobalState.query = query;\n      },\n      getOverlay: function () {\n        return this.searchOverlay;\n      },\n      setOverlay: function (overlay) {\n        this.searchOverlay = overlay;\n      },\n      isReversed: function () {\n        return vimGlobalState.isReversed;\n      },\n      setReversed: function (reversed) {\n        vimGlobalState.isReversed = reversed;\n      },\n      getScrollbarAnnotate: function () {\n        return this.annotate;\n      },\n      setScrollbarAnnotate: function (annotate) {\n        this.annotate = annotate;\n      }\n    };\n\n    function getSearchState(cm) {\n      var vim = cm.state.vim;\n      return vim.searchState_ || (vim.searchState_ = new SearchState());\n    }\n\n    function splitBySlash(argString) {\n      return splitBySeparator(argString, '/');\n    }\n\n    function findUnescapedSlashes(argString) {\n      return findUnescapedSeparators(argString, '/');\n    }\n\n    function splitBySeparator(argString, separator) {\n      var slashes = findUnescapedSeparators(argString, separator) || [];\n      if (!slashes.length) return [];\n      var tokens = []; // in case of strings like foo/bar\n\n      if (slashes[0] !== 0) return;\n\n      for (var i = 0; i < slashes.length; i++) {\n        if (typeof slashes[i] == 'number') tokens.push(argString.substring(slashes[i] + 1, slashes[i + 1]));\n      }\n\n      return tokens;\n    }\n\n    function findUnescapedSeparators(str, separator) {\n      if (!separator) separator = '/';\n      var escapeNextChar = false;\n      var slashes = [];\n\n      for (var i = 0; i < str.length; i++) {\n        var c = str.charAt(i);\n\n        if (!escapeNextChar && c == separator) {\n          slashes.push(i);\n        }\n\n        escapeNextChar = !escapeNextChar && c == '\\\\';\n      }\n\n      return slashes;\n    } // Translates a search string from ex (vim) syntax into javascript form.\n\n\n    function translateRegex(str) {\n      // When these match, add a '\\' if unescaped or remove one if escaped.\n      var specials = '|(){'; // Remove, but never add, a '\\' for these.\n\n      var unescape = '}';\n      var escapeNextChar = false;\n      var out = [];\n\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i + 1) || '';\n        var specialComesNext = n && specials.indexOf(n) != -1;\n\n        if (escapeNextChar) {\n          if (c !== '\\\\' || !specialComesNext) {\n            out.push(c);\n          }\n\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true; // Treat the unescape list as special for removing, but not adding '\\'.\n\n            if (n && unescape.indexOf(n) != -1) {\n              specialComesNext = true;\n            } // Not passing this test means removing a '\\'.\n\n\n            if (!specialComesNext || n === '\\\\') {\n              out.push(c);\n            }\n          } else {\n            out.push(c);\n\n            if (specialComesNext && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n\n      return out.join('');\n    } // Translates the replace part of a search and replace from ex (vim) syntax into\n    // javascript form.  Similar to translateRegex, but additionally fixes back references\n    // (translates '\\[0..9]' to '$[0..9]') and follows different rules for escaping '$'.\n\n\n    var charUnescapes = {\n      '\\\\n': '\\n',\n      '\\\\r': '\\r',\n      '\\\\t': '\\t'\n    };\n\n    function translateRegexReplace(str) {\n      var escapeNextChar = false;\n      var out = [];\n\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i + 1) || '';\n\n        if (charUnescapes[c + n]) {\n          out.push(charUnescapes[c + n]);\n          i++;\n        } else if (escapeNextChar) {\n          // At any point in the loop, escapeNextChar is true if the previous\n          // character was a '\\' and was not escaped.\n          out.push(c);\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n\n            if (isNumber(n) || n === '$') {\n              out.push('$');\n            } else if (n !== '/' && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          } else {\n            if (c === '$') {\n              out.push('$');\n            }\n\n            out.push(c);\n\n            if (n === '/') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n\n      return out.join('');\n    } // Unescape \\ and / in the replace part, for PCRE mode.\n\n\n    var unescapes = {\n      '\\\\/': '/',\n      '\\\\\\\\': '\\\\',\n      '\\\\n': '\\n',\n      '\\\\r': '\\r',\n      '\\\\t': '\\t',\n      '\\\\&': '&'\n    };\n\n    function unescapeRegexReplace(str) {\n      var stream = new CodeMirror.StringStream(str);\n      var output = [];\n\n      while (!stream.eol()) {\n        // Search for \\.\n        while (stream.peek() && stream.peek() != '\\\\') {\n          output.push(stream.next());\n        }\n\n        var matched = false;\n\n        for (var matcher in unescapes) {\n          if (stream.match(matcher, true)) {\n            matched = true;\n            output.push(unescapes[matcher]);\n            break;\n          }\n        }\n\n        if (!matched) {\n          // Don't change anything\n          output.push(stream.next());\n        }\n      }\n\n      return output.join('');\n    }\n    /**\n     * Extract the regular expression from the query and return a Regexp object.\n     * Returns null if the query is blank.\n     * If ignoreCase is passed in, the Regexp object will have the 'i' flag set.\n     * If smartCase is passed in, and the query contains upper case letters,\n     *   then ignoreCase is overridden, and the 'i' flag will not be set.\n     * If the query contains the /i in the flag part of the regular expression,\n     *   then both ignoreCase and smartCase are ignored, and 'i' will be passed\n     *   through to the Regex object.\n     */\n\n\n    function parseQuery(query, ignoreCase, smartCase) {\n      // First update the last search register\n      var lastSearchRegister = vimGlobalState.registerController.getRegister('/');\n      lastSearchRegister.setText(query); // Check if the query is already a regex.\n\n      if (query instanceof RegExp) {\n        return query;\n      } // First try to extract regex + flags from the input. If no flags found,\n      // extract just the regex. IE does not accept flags directly defined in\n      // the regex string in the form /regex/flags\n\n\n      var slashes = findUnescapedSlashes(query);\n      var regexPart;\n      var forceIgnoreCase;\n\n      if (!slashes.length) {\n        // Query looks like 'regexp'\n        regexPart = query;\n      } else {\n        // Query looks like 'regexp/...'\n        regexPart = query.substring(0, slashes[0]);\n        var flagsPart = query.substring(slashes[0]);\n        forceIgnoreCase = flagsPart.indexOf('i') != -1;\n      }\n\n      if (!regexPart) {\n        return null;\n      }\n\n      if (!getOption('pcre')) {\n        regexPart = translateRegex(regexPart);\n      }\n\n      if (smartCase) {\n        ignoreCase = /^[^A-Z]*$/.test(regexPart);\n      }\n\n      var regexp = new RegExp(regexPart, ignoreCase || forceIgnoreCase ? 'im' : 'm');\n      return regexp;\n    }\n    /**\n     * dom - Document Object Manipulator\n     * Usage:\n     *   dom('<tag>'|<node>[, ...{<attributes>|<$styles>}|<child-node>|'<text>'])\n     * Examples:\n     *   dom('div', {id:'xyz'}, dom('p', 'CM rocks!', {$color:'red'}))\n     *   dom(document.head, dom('script', 'alert(\"hello!\")'))\n     * Not supported:\n     *   dom('p', ['arrays are objects'], Error('objects specify attributes'))\n     */\n\n\n    function dom(n) {\n      if (typeof n === 'string') n = document.createElement(n);\n\n      for (var a, i = 1; i < arguments.length; i++) {\n        if (!(a = arguments[i])) continue;\n        if (typeof a !== 'object') a = document.createTextNode(a);\n        if (a.nodeType) n.appendChild(a);else for (var key in a) {\n          if (!Object.prototype.hasOwnProperty.call(a, key)) continue;\n          if (key[0] === '$') n.style[key.slice(1)] = a[key];else n.setAttribute(key, a[key]);\n        }\n      }\n\n      return n;\n    }\n\n    function showConfirm(cm, template) {\n      var pre = dom('pre', {\n        $color: 'red'\n      }, template);\n\n      if (cm.openNotification) {\n        cm.openNotification(pre, {\n          bottom: true,\n          duration: 5000\n        });\n      } else {\n        alert(pre.innerText);\n      }\n    }\n\n    function makePrompt(prefix, desc) {\n      return dom(document.createDocumentFragment(), dom('span', {\n        $fontFamily: 'monospace',\n        $whiteSpace: 'pre'\n      }, prefix, dom('input', {\n        type: 'text',\n        autocorrect: 'off',\n        autocapitalize: 'off',\n        spellcheck: 'false'\n      })), desc && dom('span', {\n        $color: '#888'\n      }, desc));\n    }\n\n    function showPrompt(cm, options) {\n      var shortText = (options.prefix || '') + ' ' + (options.desc || '');\n      var template = makePrompt(options.prefix, options.desc);\n\n      if (cm.openDialog) {\n        cm.openDialog(template, options.onClose, {\n          onKeyDown: options.onKeyDown,\n          onKeyUp: options.onKeyUp,\n          bottom: true,\n          selectValueOnOpen: false,\n          value: options.value\n        });\n      } else {\n        options.onClose(prompt(shortText, ''));\n      }\n    }\n\n    function regexEqual(r1, r2) {\n      if (r1 instanceof RegExp && r2 instanceof RegExp) {\n        var props = ['global', 'multiline', 'ignoreCase', 'source'];\n\n        for (var i = 0; i < props.length; i++) {\n          var prop = props[i];\n\n          if (r1[prop] !== r2[prop]) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      return false;\n    } // Returns true if the query is valid.\n\n\n    function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {\n      if (!rawQuery) {\n        return;\n      }\n\n      var state = getSearchState(cm);\n      var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);\n\n      if (!query) {\n        return;\n      }\n\n      highlightSearchMatches(cm, query);\n\n      if (regexEqual(query, state.getQuery())) {\n        return query;\n      }\n\n      state.setQuery(query);\n      return query;\n    }\n\n    function searchOverlay(query) {\n      if (query.source.charAt(0) == '^') {\n        var matchSol = true;\n      }\n\n      return {\n        token: function (stream) {\n          if (matchSol && !stream.sol()) {\n            stream.skipToEnd();\n            return;\n          }\n\n          var match = stream.match(query, false);\n\n          if (match) {\n            if (match[0].length == 0) {\n              // Matched empty string, skip to next.\n              stream.next();\n              return 'searching';\n            }\n\n            if (!stream.sol()) {\n              // Backtrack 1 to match \\b\n              stream.backUp(1);\n\n              if (!query.exec(stream.next() + match[0])) {\n                stream.next();\n                return null;\n              }\n            }\n\n            stream.match(query);\n            return 'searching';\n          }\n\n          while (!stream.eol()) {\n            stream.next();\n            if (stream.match(query, false)) break;\n          }\n        },\n        query: query\n      };\n    }\n\n    var highlightTimeout = 0;\n\n    function highlightSearchMatches(cm, query) {\n      clearTimeout(highlightTimeout);\n      highlightTimeout = setTimeout(function () {\n        var searchState = getSearchState(cm);\n        var overlay = searchState.getOverlay();\n\n        if (!overlay || query != overlay.query) {\n          if (overlay) {\n            cm.removeOverlay(overlay);\n          }\n\n          overlay = searchOverlay(query);\n          cm.addOverlay(overlay);\n\n          if (cm.showMatchesOnScrollbar) {\n            if (searchState.getScrollbarAnnotate()) {\n              searchState.getScrollbarAnnotate().clear();\n            }\n\n            searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));\n          }\n\n          searchState.setOverlay(overlay);\n        }\n      }, 50);\n    }\n\n    function findNext(cm, prev, query, repeat) {\n      if (repeat === undefined) {\n        repeat = 1;\n      }\n\n      return cm.operation(function () {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n\n        for (var i = 0; i < repeat; i++) {\n          var found = cursor.find(prev);\n\n          if (i == 0 && found && cursorEqual(cursor.from(), pos)) {\n            var lastEndPos = prev ? cursor.from() : cursor.to();\n            found = cursor.find(prev);\n\n            if (found && !found[0] && cursorEqual(cursor.from(), lastEndPos)) {\n              if (cm.getLine(lastEndPos.line).length == lastEndPos.ch) found = cursor.find(prev);\n            }\n          }\n\n          if (!found) {\n            // SearchCursor may have returned null because it hit EOF, wrap\n            // around and try again.\n            cursor = cm.getSearchCursor(query, prev ? Pos(cm.lastLine()) : Pos(cm.firstLine(), 0));\n\n            if (!cursor.find(prev)) {\n              return;\n            }\n          }\n        }\n\n        return cursor.from();\n      });\n    }\n    /**\n     * Pretty much the same as `findNext`, except for the following differences:\n     *\n     * 1. Before starting the search, move to the previous search. This way if our cursor is\n     * already inside a match, we should return the current match.\n     * 2. Rather than only returning the cursor's from, we return the cursor's from and to as a tuple.\n     */\n\n\n    function findNextFromAndToInclusive(cm, prev, query, repeat, vim) {\n      if (repeat === undefined) {\n        repeat = 1;\n      }\n\n      return cm.operation(function () {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos); // Go back one result to ensure that if the cursor is currently a match, we keep it.\n\n        var found = cursor.find(!prev); // If we haven't moved, go back one more (similar to if i==0 logic in findNext).\n\n        if (!vim.visualMode && found && cursorEqual(cursor.from(), pos)) {\n          cursor.find(!prev);\n        }\n\n        for (var i = 0; i < repeat; i++) {\n          found = cursor.find(prev);\n\n          if (!found) {\n            // SearchCursor may have returned null because it hit EOF, wrap\n            // around and try again.\n            cursor = cm.getSearchCursor(query, prev ? Pos(cm.lastLine()) : Pos(cm.firstLine(), 0));\n\n            if (!cursor.find(prev)) {\n              return;\n            }\n          }\n        }\n\n        return [cursor.from(), cursor.to()];\n      });\n    }\n\n    function clearSearchHighlight(cm) {\n      var state = getSearchState(cm);\n      cm.removeOverlay(getSearchState(cm).getOverlay());\n      state.setOverlay(null);\n\n      if (state.getScrollbarAnnotate()) {\n        state.getScrollbarAnnotate().clear();\n        state.setScrollbarAnnotate(null);\n      }\n    }\n    /**\n     * Check if pos is in the specified range, INCLUSIVE.\n     * Range can be specified with 1 or 2 arguments.\n     * If the first range argument is an array, treat it as an array of line\n     * numbers. Match pos against any of the lines.\n     * If the first range argument is a number,\n     *   if there is only 1 range argument, check if pos has the same line\n     *       number\n     *   if there are 2 range arguments, then check if pos is in between the two\n     *       range arguments.\n     */\n\n\n    function isInRange(pos, start, end) {\n      if (typeof pos != 'number') {\n        // Assume it is a cursor position. Get the line number.\n        pos = pos.line;\n      }\n\n      if (start instanceof Array) {\n        return inArray(pos, start);\n      } else {\n        if (typeof end == 'number') {\n          return pos >= start && pos <= end;\n        } else {\n          return pos == start;\n        }\n      }\n    }\n\n    function getUserVisibleLines(cm) {\n      var scrollInfo = cm.getScrollInfo();\n      var occludeToleranceTop = 6;\n      var occludeToleranceBottom = 10;\n      var from = cm.coordsChar({\n        left: 0,\n        top: occludeToleranceTop + scrollInfo.top\n      }, 'local');\n      var bottomY = scrollInfo.clientHeight - occludeToleranceBottom + scrollInfo.top;\n      var to = cm.coordsChar({\n        left: 0,\n        top: bottomY\n      }, 'local');\n      return {\n        top: from.line,\n        bottom: to.line\n      };\n    }\n\n    function getMarkPos(cm, vim, markName) {\n      if (markName == '\\'' || markName == '`') {\n        return vimGlobalState.jumpList.find(cm, -1) || Pos(0, 0);\n      } else if (markName == '.') {\n        return getLastEditPos(cm);\n      }\n\n      var mark = vim.marks[markName];\n      return mark && mark.find();\n    }\n\n    function getLastEditPos(cm) {\n      var done = cm.doc.history.done;\n\n      for (var i = done.length; i--;) {\n        if (done[i].changes) {\n          return copyCursor(done[i].changes[0].to);\n        }\n      }\n    }\n\n    var ExCommandDispatcher = function () {\n      this.buildCommandMap_();\n    };\n\n    ExCommandDispatcher.prototype = {\n      processCommand: function (cm, input, opt_params) {\n        var that = this;\n        cm.operation(function () {\n          cm.curOp.isVimOp = true;\n\n          that._processCommand(cm, input, opt_params);\n        });\n      },\n      _processCommand: function (cm, input, opt_params) {\n        var vim = cm.state.vim;\n        var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');\n        var previousCommand = commandHistoryRegister.toString();\n\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n\n        var inputStream = new CodeMirror.StringStream(input); // update \": with the latest command whether valid or invalid\n\n        commandHistoryRegister.setText(input);\n        var params = opt_params || {};\n        params.input = input;\n\n        try {\n          this.parseInput_(cm, inputStream, params);\n        } catch (e) {\n          showConfirm(cm, e.toString());\n          throw e;\n        }\n\n        var command;\n        var commandName;\n\n        if (!params.commandName) {\n          // If only a line range is defined, move to the line.\n          if (params.line !== undefined) {\n            commandName = 'move';\n          }\n        } else {\n          command = this.matchCommand_(params.commandName);\n\n          if (command) {\n            commandName = command.name;\n\n            if (command.excludeFromCommandHistory) {\n              commandHistoryRegister.setText(previousCommand);\n            }\n\n            this.parseCommandArgs_(inputStream, params, command);\n\n            if (command.type == 'exToKey') {\n              // Handle Ex to Key mapping.\n              for (var i = 0; i < command.toKeys.length; i++) {\n                CodeMirror.Vim.handleKey(cm, command.toKeys[i], 'mapping');\n              }\n\n              return;\n            } else if (command.type == 'exToEx') {\n              // Handle Ex to Ex mapping.\n              this.processCommand(cm, command.toInput);\n              return;\n            }\n          }\n        }\n\n        if (!commandName) {\n          showConfirm(cm, 'Not an editor command \":' + input + '\"');\n          return;\n        }\n\n        try {\n          exCommands[commandName](cm, params); // Possibly asynchronous commands (e.g. substitute, which might have a\n          // user confirmation), are responsible for calling the callback when\n          // done. All others have it taken care of for them here.\n\n          if ((!command || !command.possiblyAsync) && params.callback) {\n            params.callback();\n          }\n        } catch (e) {\n          showConfirm(cm, e.toString());\n          throw e;\n        }\n      },\n      parseInput_: function (cm, inputStream, result) {\n        inputStream.eatWhile(':'); // Parse range.\n\n        if (inputStream.eat('%')) {\n          result.line = cm.firstLine();\n          result.lineEnd = cm.lastLine();\n        } else {\n          result.line = this.parseLineSpec_(cm, inputStream);\n\n          if (result.line !== undefined && inputStream.eat(',')) {\n            result.lineEnd = this.parseLineSpec_(cm, inputStream);\n          }\n        } // Parse command name.\n\n\n        var commandMatch = inputStream.match(/^(\\w+|!!|@@|[!#&*<=>@~])/);\n\n        if (commandMatch) {\n          result.commandName = commandMatch[1];\n        } else {\n          result.commandName = inputStream.match(/.*/)[0];\n        }\n\n        return result;\n      },\n      parseLineSpec_: function (cm, inputStream) {\n        var numberMatch = inputStream.match(/^(\\d+)/);\n\n        if (numberMatch) {\n          // Absolute line number plus offset (N+M or N-M) is probably a typo,\n          // not something the user actually wanted. (NB: vim does allow this.)\n          return parseInt(numberMatch[1], 10) - 1;\n        }\n\n        switch (inputStream.next()) {\n          case '.':\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n\n          case '$':\n            return this.parseLineSpecOffset_(inputStream, cm.lastLine());\n\n          case '\\'':\n            var markName = inputStream.next();\n            var markPos = getMarkPos(cm, cm.state.vim, markName);\n            if (!markPos) throw new Error('Mark not set');\n            return this.parseLineSpecOffset_(inputStream, markPos.line);\n\n          case '-':\n          case '+':\n            inputStream.backUp(1); // Offset is relative to current line if not otherwise specified.\n\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n\n          default:\n            inputStream.backUp(1);\n            return undefined;\n        }\n      },\n      parseLineSpecOffset_: function (inputStream, line) {\n        var offsetMatch = inputStream.match(/^([+-])?(\\d+)/);\n\n        if (offsetMatch) {\n          var offset = parseInt(offsetMatch[2], 10);\n\n          if (offsetMatch[1] == \"-\") {\n            line -= offset;\n          } else {\n            line += offset;\n          }\n        }\n\n        return line;\n      },\n      parseCommandArgs_: function (inputStream, params, command) {\n        if (inputStream.eol()) {\n          return;\n        }\n\n        params.argString = inputStream.match(/.*/)[0]; // Parse command-line arguments\n\n        var delim = command.argDelimiter || /\\s+/;\n        var args = trim(params.argString).split(delim);\n\n        if (args.length && args[0]) {\n          params.args = args;\n        }\n      },\n      matchCommand_: function (commandName) {\n        // Return the command in the command map that matches the shortest\n        // prefix of the passed in command name. The match is guaranteed to be\n        // unambiguous if the defaultExCommandMap's shortNames are set up\n        // correctly. (see @code{defaultExCommandMap}).\n        for (var i = commandName.length; i > 0; i--) {\n          var prefix = commandName.substring(0, i);\n\n          if (this.commandMap_[prefix]) {\n            var command = this.commandMap_[prefix];\n\n            if (command.name.indexOf(commandName) === 0) {\n              return command;\n            }\n          }\n        }\n\n        return null;\n      },\n      buildCommandMap_: function () {\n        this.commandMap_ = {};\n\n        for (var i = 0; i < defaultExCommandMap.length; i++) {\n          var command = defaultExCommandMap[i];\n          var key = command.shortName || command.name;\n          this.commandMap_[key] = command;\n        }\n      },\n      map: function (lhs, rhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          if (ctx) {\n            throw Error('Mode not supported for ex mappings');\n          }\n\n          var commandName = lhs.substring(1);\n\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Ex to Ex mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToEx',\n              toInput: rhs.substring(1),\n              user: true\n            };\n          } else {\n            // Ex to key mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToKey',\n              toKeys: rhs,\n              user: true\n            };\n          }\n        } else {\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Key to Ex mapping.\n            var mapping = {\n              keys: lhs,\n              type: 'keyToEx',\n              exArgs: {\n                input: rhs.substring(1)\n              }\n            };\n\n            if (ctx) {\n              mapping.context = ctx;\n            }\n\n            defaultKeymap.unshift(mapping);\n          } else {\n            // Key to key mapping\n            var mapping = {\n              keys: lhs,\n              type: 'keyToKey',\n              toKeys: rhs\n            };\n\n            if (ctx) {\n              mapping.context = ctx;\n            }\n\n            defaultKeymap.unshift(mapping);\n          }\n        }\n      },\n      unmap: function (lhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          // Ex to Ex or Ex to key mapping\n          if (ctx) {\n            throw Error('Mode not supported for ex mappings');\n          }\n\n          var commandName = lhs.substring(1);\n\n          if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {\n            delete this.commandMap_[commandName];\n            return;\n          }\n        } else {\n          // Key to Ex or key to key mapping\n          var keys = lhs;\n\n          for (var i = 0; i < defaultKeymap.length; i++) {\n            if (keys == defaultKeymap[i].keys && defaultKeymap[i].context === ctx) {\n              defaultKeymap.splice(i, 1);\n              return;\n            }\n          }\n        }\n\n        throw Error('No such mapping.');\n      }\n    };\n    var exCommands = {\n      colorscheme: function (cm, params) {\n        if (!params.args || params.args.length < 1) {\n          showConfirm(cm, cm.getOption('theme'));\n          return;\n        }\n\n        cm.setOption('theme', params.args[0]);\n      },\n      map: function (cm, params, ctx) {\n        var mapArgs = params.args;\n\n        if (!mapArgs || mapArgs.length < 2) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n\n          return;\n        }\n\n        exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx);\n      },\n      imap: function (cm, params) {\n        this.map(cm, params, 'insert');\n      },\n      nmap: function (cm, params) {\n        this.map(cm, params, 'normal');\n      },\n      vmap: function (cm, params) {\n        this.map(cm, params, 'visual');\n      },\n      unmap: function (cm, params, ctx) {\n        var mapArgs = params.args;\n\n        if (!mapArgs || mapArgs.length < 1) {\n          if (cm) {\n            showConfirm(cm, 'No such mapping: ' + params.input);\n          }\n\n          return;\n        }\n\n        exCommandDispatcher.unmap(mapArgs[0], ctx);\n      },\n      move: function (cm, params) {\n        commandDispatcher.processCommand(cm, cm.state.vim, {\n          type: 'motion',\n          motion: 'moveToLineOrEdgeOfDocument',\n          motionArgs: {\n            forward: false,\n            explicitRepeat: true,\n            linewise: true\n          },\n          repeatOverride: params.line + 1\n        });\n      },\n      set: function (cm, params) {\n        var setArgs = params.args; // Options passed through to the setOption/getOption calls. May be passed in by the\n        // local/global versions of the set command\n\n        var setCfg = params.setCfg || {};\n\n        if (!setArgs || setArgs.length < 1) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n\n          return;\n        }\n\n        var expr = setArgs[0].split('=');\n        var optionName = expr[0];\n        var value = expr[1];\n        var forceGet = false;\n\n        if (optionName.charAt(optionName.length - 1) == '?') {\n          // If post-fixed with ?, then the set is actually a get.\n          if (value) {\n            throw Error('Trailing characters: ' + params.argString);\n          }\n\n          optionName = optionName.substring(0, optionName.length - 1);\n          forceGet = true;\n        }\n\n        if (value === undefined && optionName.substring(0, 2) == 'no') {\n          // To set boolean options to false, the option name is prefixed with\n          // 'no'.\n          optionName = optionName.substring(2);\n          value = false;\n        }\n\n        var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';\n\n        if (optionIsBoolean && value == undefined) {\n          // Calling set with a boolean option sets it to true.\n          value = true;\n        } // If no value is provided, then we assume this is a get.\n\n\n        if (!optionIsBoolean && value === undefined || forceGet) {\n          var oldValue = getOption(optionName, cm, setCfg);\n\n          if (oldValue instanceof Error) {\n            showConfirm(cm, oldValue.message);\n          } else if (oldValue === true || oldValue === false) {\n            showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);\n          } else {\n            showConfirm(cm, '  ' + optionName + '=' + oldValue);\n          }\n        } else {\n          var setOptionReturn = setOption(optionName, value, cm, setCfg);\n\n          if (setOptionReturn instanceof Error) {\n            showConfirm(cm, setOptionReturn.message);\n          }\n        }\n      },\n      setlocal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {\n          scope: 'local'\n        };\n        this.set(cm, params);\n      },\n      setglobal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {\n          scope: 'global'\n        };\n        this.set(cm, params);\n      },\n      registers: function (cm, params) {\n        var regArgs = params.args;\n        var registers = vimGlobalState.registerController.registers;\n        var regInfo = '----------Registers----------\\n\\n';\n\n        if (!regArgs) {\n          for (var registerName in registers) {\n            var text = registers[registerName].toString();\n\n            if (text.length) {\n              regInfo += '\"' + registerName + '    ' + text + '\\n';\n            }\n          }\n        } else {\n          var registerName;\n          regArgs = regArgs.join('');\n\n          for (var i = 0; i < regArgs.length; i++) {\n            registerName = regArgs.charAt(i);\n\n            if (!vimGlobalState.registerController.isValidRegister(registerName)) {\n              continue;\n            }\n\n            var register = registers[registerName] || new Register();\n            regInfo += '\"' + registerName + '    ' + register.toString() + '\\n';\n          }\n        }\n\n        showConfirm(cm, regInfo);\n      },\n      sort: function (cm, params) {\n        var reverse, ignoreCase, unique, number, pattern;\n\n        function parseArgs() {\n          if (params.argString) {\n            var args = new CodeMirror.StringStream(params.argString);\n\n            if (args.eat('!')) {\n              reverse = true;\n            }\n\n            if (args.eol()) {\n              return;\n            }\n\n            if (!args.eatSpace()) {\n              return 'Invalid arguments';\n            }\n\n            var opts = args.match(/([dinuox]+)?\\s*(\\/.+\\/)?\\s*/);\n\n            if (!opts && !args.eol()) {\n              return 'Invalid arguments';\n            }\n\n            if (opts[1]) {\n              ignoreCase = opts[1].indexOf('i') != -1;\n              unique = opts[1].indexOf('u') != -1;\n              var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1 && 1;\n              var hex = opts[1].indexOf('x') != -1 && 1;\n              var octal = opts[1].indexOf('o') != -1 && 1;\n\n              if (decimal + hex + octal > 1) {\n                return 'Invalid arguments';\n              }\n\n              number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';\n            }\n\n            if (opts[2]) {\n              pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '');\n            }\n          }\n        }\n\n        var err = parseArgs();\n\n        if (err) {\n          showConfirm(cm, err + ': ' + params.argString);\n          return;\n        }\n\n        var lineStart = params.line || cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n\n        if (lineStart == lineEnd) {\n          return;\n        }\n\n        var curStart = Pos(lineStart, 0);\n        var curEnd = Pos(lineEnd, lineLength(cm, lineEnd));\n        var text = cm.getRange(curStart, curEnd).split('\\n');\n        var numberRegex = pattern ? pattern : number == 'decimal' ? /(-?)([\\d]+)/ : number == 'hex' ? /(-?)(?:0x)?([0-9a-f]+)/i : number == 'octal' ? /([0-7]+)/ : null;\n        var radix = number == 'decimal' ? 10 : number == 'hex' ? 16 : number == 'octal' ? 8 : null;\n        var numPart = [],\n            textPart = [];\n\n        if (number || pattern) {\n          for (var i = 0; i < text.length; i++) {\n            var matchPart = pattern ? text[i].match(pattern) : null;\n\n            if (matchPart && matchPart[0] != '') {\n              numPart.push(matchPart);\n            } else if (!pattern && numberRegex.exec(text[i])) {\n              numPart.push(text[i]);\n            } else {\n              textPart.push(text[i]);\n            }\n          }\n        } else {\n          textPart = text;\n        }\n\n        function compareFn(a, b) {\n          if (reverse) {\n            var tmp;\n            tmp = a;\n            a = b;\n            b = tmp;\n          }\n\n          if (ignoreCase) {\n            a = a.toLowerCase();\n            b = b.toLowerCase();\n          }\n\n          var anum = number && numberRegex.exec(a);\n          var bnum = number && numberRegex.exec(b);\n\n          if (!anum) {\n            return a < b ? -1 : 1;\n          }\n\n          anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);\n          bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);\n          return anum - bnum;\n        }\n\n        function comparePatternFn(a, b) {\n          if (reverse) {\n            var tmp;\n            tmp = a;\n            a = b;\n            b = tmp;\n          }\n\n          if (ignoreCase) {\n            a[0] = a[0].toLowerCase();\n            b[0] = b[0].toLowerCase();\n          }\n\n          return a[0] < b[0] ? -1 : 1;\n        }\n\n        numPart.sort(pattern ? comparePatternFn : compareFn);\n\n        if (pattern) {\n          for (var i = 0; i < numPart.length; i++) {\n            numPart[i] = numPart[i].input;\n          }\n        } else if (!number) {\n          textPart.sort(compareFn);\n        }\n\n        text = !reverse ? textPart.concat(numPart) : numPart.concat(textPart);\n\n        if (unique) {\n          // Remove duplicate lines\n          var textOld = text;\n          var lastLine;\n          text = [];\n\n          for (var i = 0; i < textOld.length; i++) {\n            if (textOld[i] != lastLine) {\n              text.push(textOld[i]);\n            }\n\n            lastLine = textOld[i];\n          }\n        }\n\n        cm.replaceRange(text.join('\\n'), curStart, curEnd);\n      },\n      vglobal: function (cm, params) {\n        // global inspects params.commandName\n        this.global(cm, params);\n      },\n      global: function (cm, params) {\n        // a global command is of the form\n        // :[range]g/pattern/[cmd]\n        // argString holds the string /pattern/[cmd]\n        var argString = params.argString;\n\n        if (!argString) {\n          showConfirm(cm, 'Regular Expression missing from global');\n          return;\n        }\n\n        var inverted = params.commandName[0] === 'v'; // range is specified here\n\n        var lineStart = params.line !== undefined ? params.line : cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine(); // get the tokens from argString\n\n        var tokens = splitBySlash(argString);\n        var regexPart = argString,\n            cmd;\n\n        if (tokens.length) {\n          regexPart = tokens[0];\n          cmd = tokens.slice(1, tokens.length).join('/');\n        }\n\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise\n          // use the regex part as the new query.\n          try {\n            updateSearchQuery(cm, regexPart, true\n            /** ignoreCase */\n            , true\n            /** smartCase */\n            );\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + regexPart);\n            return;\n          }\n        } // now that we have the regexPart, search for regex matches in the\n        // specified range of lines\n\n\n        var query = getSearchState(cm).getQuery();\n        var matchedLines = [];\n\n        for (var i = lineStart; i <= lineEnd; i++) {\n          var line = cm.getLineHandle(i);\n          var matched = query.test(line.text);\n\n          if (matched !== inverted) {\n            matchedLines.push(cmd ? line : line.text);\n          }\n        } // if there is no [cmd], just display the list of matched lines\n\n\n        if (!cmd) {\n          showConfirm(cm, matchedLines.join('\\n'));\n          return;\n        }\n\n        var index = 0;\n\n        var nextCommand = function () {\n          if (index < matchedLines.length) {\n            var line = matchedLines[index++];\n            var lineNum = cm.getLineNumber(line);\n\n            if (lineNum == null) {\n              nextCommand();\n              return;\n            }\n\n            var command = lineNum + 1 + cmd;\n            exCommandDispatcher.processCommand(cm, command, {\n              callback: nextCommand\n            });\n          }\n        };\n\n        nextCommand();\n      },\n      substitute: function (cm, params) {\n        if (!cm.getSearchCursor) {\n          throw new Error('Search feature not available. Requires searchcursor.js or ' + 'any other getSearchCursor implementation.');\n        }\n\n        var argString = params.argString;\n        var tokens = argString ? splitBySeparator(argString, argString[0]) : [];\n        var regexPart,\n            replacePart = '',\n            trailing,\n            flagsPart,\n            count;\n        var confirm = false; // Whether to confirm each replace.\n\n        var global = false; // True to replace all instances on a line, false to replace only 1.\n\n        if (tokens.length) {\n          regexPart = tokens[0];\n\n          if (getOption('pcre') && regexPart !== '') {\n            regexPart = new RegExp(regexPart).source; //normalize not escaped characters\n          }\n\n          replacePart = tokens[1];\n\n          if (replacePart !== undefined) {\n            if (getOption('pcre')) {\n              replacePart = unescapeRegexReplace(replacePart.replace(/([^\\\\])&/g, \"$1$$&\"));\n            } else {\n              replacePart = translateRegexReplace(replacePart);\n            }\n\n            vimGlobalState.lastSubstituteReplacePart = replacePart;\n          }\n\n          trailing = tokens[2] ? tokens[2].split(' ') : [];\n        } else {\n          // either the argString is empty or its of the form ' hello/world'\n          // actually splitBySlash returns a list of tokens\n          // only if the string starts with a '/'\n          if (argString && argString.length) {\n            showConfirm(cm, 'Substitutions should be of the form ' + ':s/pattern/replace/');\n            return;\n          }\n        } // After the 3rd slash, we can have flags followed by a space followed\n        // by count.\n\n\n        if (trailing) {\n          flagsPart = trailing[0];\n          count = parseInt(trailing[1]);\n\n          if (flagsPart) {\n            if (flagsPart.indexOf('c') != -1) {\n              confirm = true;\n            }\n\n            if (flagsPart.indexOf('g') != -1) {\n              global = true;\n            }\n\n            if (getOption('pcre')) {\n              regexPart = regexPart + '/' + flagsPart;\n            } else {\n              regexPart = regexPart.replace(/\\//g, \"\\\\/\") + '/' + flagsPart;\n            }\n          }\n        }\n\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise use\n          // the regex part as the new query.\n          try {\n            updateSearchQuery(cm, regexPart, true\n            /** ignoreCase */\n            , true\n            /** smartCase */\n            );\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + regexPart);\n            return;\n          }\n        }\n\n        replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;\n\n        if (replacePart === undefined) {\n          showConfirm(cm, 'No previous substitute regular expression');\n          return;\n        }\n\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        var lineStart = params.line !== undefined ? params.line : cm.getCursor().line;\n        var lineEnd = params.lineEnd || lineStart;\n\n        if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {\n          lineEnd = Infinity;\n        }\n\n        if (count) {\n          lineStart = lineEnd;\n          lineEnd = lineStart + count - 1;\n        }\n\n        var startPos = clipCursorToContent(cm, Pos(lineStart, 0));\n        var cursor = cm.getSearchCursor(query, startPos);\n        doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);\n      },\n      redo: CodeMirror.commands.redo,\n      undo: CodeMirror.commands.undo,\n      write: function (cm) {\n        if (CodeMirror.commands.save) {\n          // If a save command is defined, call it.\n          CodeMirror.commands.save(cm);\n        } else if (cm.save) {\n          // Saves to text area if no save command is defined and cm.save() is available.\n          cm.save();\n        }\n      },\n      nohlsearch: function (cm) {\n        clearSearchHighlight(cm);\n      },\n      yank: function (cm) {\n        var cur = copyCursor(cm.getCursor());\n        var line = cur.line;\n        var lineText = cm.getLine(line);\n        vimGlobalState.registerController.pushText('0', 'yank', lineText, true, true);\n      },\n      delmarks: function (cm, params) {\n        if (!params.argString || !trim(params.argString)) {\n          showConfirm(cm, 'Argument required');\n          return;\n        }\n\n        var state = cm.state.vim;\n        var stream = new CodeMirror.StringStream(trim(params.argString));\n\n        while (!stream.eol()) {\n          stream.eatSpace(); // Record the streams position at the beginning of the loop for use\n          // in error messages.\n\n          var count = stream.pos;\n\n          if (!stream.match(/[a-zA-Z]/, false)) {\n            showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n            return;\n          }\n\n          var sym = stream.next(); // Check if this symbol is part of a range\n\n          if (stream.match('-', true)) {\n            // This symbol is part of a range.\n            // The range must terminate at an alphabetic character.\n            if (!stream.match(/[a-zA-Z]/, false)) {\n              showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n              return;\n            }\n\n            var startMark = sym;\n            var finishMark = stream.next(); // The range must terminate at an alphabetic character which\n            // shares the same case as the start of the range.\n\n            if (isLowerCase(startMark) && isLowerCase(finishMark) || isUpperCase(startMark) && isUpperCase(finishMark)) {\n              var start = startMark.charCodeAt(0);\n              var finish = finishMark.charCodeAt(0);\n\n              if (start >= finish) {\n                showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n                return;\n              } // Because marks are always ASCII values, and we have\n              // determined that they are the same case, we can use\n              // their char codes to iterate through the defined range.\n\n\n              for (var j = 0; j <= finish - start; j++) {\n                var mark = String.fromCharCode(start + j);\n                delete state.marks[mark];\n              }\n            } else {\n              showConfirm(cm, 'Invalid argument: ' + startMark + '-');\n              return;\n            }\n          } else {\n            // This symbol is a valid mark, and is not part of a range.\n            delete state.marks[sym];\n          }\n        }\n      }\n    };\n    var exCommandDispatcher = new ExCommandDispatcher();\n    /**\n    * @param {CodeMirror} cm CodeMirror instance we are in.\n    * @param {boolean} confirm Whether to confirm each replace.\n    * @param {Cursor} lineStart Line to start replacing from.\n    * @param {Cursor} lineEnd Line to stop replacing at.\n    * @param {RegExp} query Query for performing matches with.\n    * @param {string} replaceWith Text to replace matches with. May contain $1,\n    *     $2, etc for replacing captured groups using JavaScript replace.\n    * @param {function()} callback A callback for when the replace is done.\n    */\n\n    function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query, replaceWith, callback) {\n      // Set up all the functions.\n      cm.state.vim.exMode = true;\n      var done = false;\n      var lastPos, modifiedLineNumber, joined;\n\n      function replaceAll() {\n        cm.operation(function () {\n          while (!done) {\n            replace();\n            next();\n          }\n\n          stop();\n        });\n      }\n\n      function replace() {\n        var text = cm.getRange(searchCursor.from(), searchCursor.to());\n        var newText = text.replace(query, replaceWith);\n        var unmodifiedLineNumber = searchCursor.to().line;\n        searchCursor.replace(newText);\n        modifiedLineNumber = searchCursor.to().line;\n        lineEnd += modifiedLineNumber - unmodifiedLineNumber;\n        joined = modifiedLineNumber < unmodifiedLineNumber;\n      }\n\n      function findNextValidMatch() {\n        var lastMatchTo = lastPos && copyCursor(searchCursor.to());\n        var match = searchCursor.findNext();\n\n        if (match && !match[0] && lastMatchTo && cursorEqual(searchCursor.from(), lastMatchTo)) {\n          match = searchCursor.findNext();\n        }\n\n        return match;\n      }\n\n      function next() {\n        // The below only loops to skip over multiple occurrences on the same\n        // line when 'global' is not true.\n        while (findNextValidMatch() && isInRange(searchCursor.from(), lineStart, lineEnd)) {\n          if (!global && searchCursor.from().line == modifiedLineNumber && !joined) {\n            continue;\n          }\n\n          cm.scrollIntoView(searchCursor.from(), 30);\n          cm.setSelection(searchCursor.from(), searchCursor.to());\n          lastPos = searchCursor.from();\n          done = false;\n          return;\n        }\n\n        done = true;\n      }\n\n      function stop(close) {\n        if (close) {\n          close();\n        }\n\n        cm.focus();\n\n        if (lastPos) {\n          cm.setCursor(lastPos);\n          var vim = cm.state.vim;\n          vim.exMode = false;\n          vim.lastHPos = vim.lastHSPos = lastPos.ch;\n        }\n\n        if (callback) {\n          callback();\n        }\n      }\n\n      function onPromptKeyDown(e, _value, close) {\n        // Swallow all keys.\n        CodeMirror.e_stop(e);\n        var keyName = CodeMirror.keyName(e);\n\n        switch (keyName) {\n          case 'Y':\n            replace();\n            next();\n            break;\n\n          case 'N':\n            next();\n            break;\n\n          case 'A':\n            // replaceAll contains a call to close of its own. We don't want it\n            // to fire too early or multiple times.\n            var savedCallback = callback;\n            callback = undefined;\n            cm.operation(replaceAll);\n            callback = savedCallback;\n            break;\n\n          case 'L':\n            replace();\n          // fall through and exit.\n\n          case 'Q':\n          case 'Esc':\n          case 'Ctrl-C':\n          case 'Ctrl-[':\n            stop(close);\n            break;\n        }\n\n        if (done) {\n          stop(close);\n        }\n\n        return true;\n      } // Actually do replace.\n\n\n      next();\n\n      if (done) {\n        showConfirm(cm, 'No matches for ' + query.source);\n        return;\n      }\n\n      if (!confirm) {\n        replaceAll();\n\n        if (callback) {\n          callback();\n        }\n\n        return;\n      }\n\n      showPrompt(cm, {\n        prefix: dom('span', 'replace with ', dom('strong', replaceWith), ' (y/n/a/q/l)'),\n        onKeyDown: onPromptKeyDown\n      });\n    }\n\n    CodeMirror.keyMap.vim = {\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function exitInsertMode(cm) {\n      var vim = cm.state.vim;\n      var macroModeState = vimGlobalState.macroModeState;\n      var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');\n      var isPlaying = macroModeState.isPlaying;\n      var lastChange = macroModeState.lastInsertModeChanges;\n\n      if (!isPlaying) {\n        cm.off('change', onChange);\n        CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n      }\n\n      if (!isPlaying && vim.insertModeRepeat > 1) {\n        // Perform insert mode repeat for commands like 3,a and 3,o.\n        repeatLastEdit(cm, vim, vim.insertModeRepeat - 1, true\n        /** repeatForInsert */\n        );\n        vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;\n      }\n\n      delete vim.insertModeRepeat;\n      vim.insertMode = false;\n      cm.setCursor(cm.getCursor().line, cm.getCursor().ch - 1);\n      cm.setOption('keyMap', 'vim');\n      cm.setOption('disableInput', true);\n      cm.toggleOverwrite(false); // exit replace mode if we were in it.\n      // update the \". register before exiting insert mode\n\n      insertModeChangeRegister.setText(lastChange.changes.join(''));\n      CodeMirror.signal(cm, \"vim-mode-change\", {\n        mode: \"normal\"\n      });\n\n      if (macroModeState.isRecording) {\n        logInsertModeChange(macroModeState);\n      }\n    }\n\n    function _mapCommand(command) {\n      defaultKeymap.unshift(command);\n    }\n\n    function mapCommand(keys, type, name, args, extra) {\n      var command = {\n        keys: keys,\n        type: type\n      };\n      command[type] = name;\n      command[type + \"Args\"] = args;\n\n      for (var key in extra) command[key] = extra[key];\n\n      _mapCommand(command);\n    } // The timeout in milliseconds for the two-character ESC keymap should be\n    // adjusted according to your typing speed to prevent false positives.\n\n\n    defineOption('insertModeEscKeysTimeout', 200, 'number');\n    CodeMirror.keyMap['vim-insert'] = {\n      // TODO: override navigation keys so that Esc will cancel automatic\n      // indentation from o, O, i_<CR>\n      fallthrough: ['default'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n    CodeMirror.keyMap['vim-replace'] = {\n      'Backspace': 'goCharLeft',\n      fallthrough: ['vim-insert'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function executeMacroRegister(cm, vim, macroModeState, registerName) {\n      var register = vimGlobalState.registerController.getRegister(registerName);\n\n      if (registerName == ':') {\n        // Read-only register containing last Ex command.\n        if (register.keyBuffer[0]) {\n          exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);\n        }\n\n        macroModeState.isPlaying = false;\n        return;\n      }\n\n      var keyBuffer = register.keyBuffer;\n      var imc = 0;\n      macroModeState.isPlaying = true;\n      macroModeState.replaySearchQueries = register.searchQueries.slice(0);\n\n      for (var i = 0; i < keyBuffer.length; i++) {\n        var text = keyBuffer[i];\n        var match, key;\n\n        while (text) {\n          // Pull off one command key, which is either a single character\n          // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n          match = /<\\w+-.+?>|<\\w+>|./.exec(text);\n          key = match[0];\n          text = text.substring(match.index + key.length);\n          CodeMirror.Vim.handleKey(cm, key, 'macro');\n\n          if (vim.insertMode) {\n            var changes = register.insertModeChanges[imc++].changes;\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes = changes;\n            repeatInsertModeChanges(cm, changes, 1);\n            exitInsertMode(cm);\n          }\n        }\n      }\n\n      macroModeState.isPlaying = false;\n    }\n\n    function logKey(macroModeState, key) {\n      if (macroModeState.isPlaying) {\n        return;\n      }\n\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n\n      if (register) {\n        register.pushText(key);\n      }\n    }\n\n    function logInsertModeChange(macroModeState) {\n      if (macroModeState.isPlaying) {\n        return;\n      }\n\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n\n      if (register && register.pushInsertModeChanges) {\n        register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);\n      }\n    }\n\n    function logSearchQuery(macroModeState, query) {\n      if (macroModeState.isPlaying) {\n        return;\n      }\n\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n\n      if (register && register.pushSearchQuery) {\n        register.pushSearchQuery(query);\n      }\n    }\n    /**\n     * Listens for changes made in insert mode.\n     * Should only be active in insert mode.\n     */\n\n\n    function onChange(cm, changeObj) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n\n      if (!macroModeState.isPlaying) {\n        while (changeObj) {\n          lastChange.expectCursorActivityForChange = true;\n\n          if (lastChange.ignoreCount > 1) {\n            lastChange.ignoreCount--;\n          } else if (changeObj.origin == '+input' || changeObj.origin == 'paste' || changeObj.origin === undefined\n          /* only in testing */\n          ) {\n            var selectionCount = cm.listSelections().length;\n            if (selectionCount > 1) lastChange.ignoreCount = selectionCount;\n            var text = changeObj.text.join('\\n');\n\n            if (lastChange.maybeReset) {\n              lastChange.changes = [];\n              lastChange.maybeReset = false;\n            }\n\n            if (text) {\n              if (cm.state.overwrite && !/\\n/.test(text)) {\n                lastChange.changes.push([text]);\n              } else {\n                lastChange.changes.push(text);\n              }\n            }\n          } // Change objects may be chained with next.\n\n\n          changeObj = changeObj.next;\n        }\n      }\n    }\n    /**\n    * Listens for any kind of cursor activity on CodeMirror.\n    */\n\n\n    function onCursorActivity(cm) {\n      var vim = cm.state.vim;\n\n      if (vim.insertMode) {\n        // Tracking cursor activity in insert mode (for macro support).\n        var macroModeState = vimGlobalState.macroModeState;\n\n        if (macroModeState.isPlaying) {\n          return;\n        }\n\n        var lastChange = macroModeState.lastInsertModeChanges;\n\n        if (lastChange.expectCursorActivityForChange) {\n          lastChange.expectCursorActivityForChange = false;\n        } else {\n          // Cursor moved outside the context of an edit. Reset the change.\n          lastChange.maybeReset = true;\n        }\n      } else if (!cm.curOp.isVimOp) {\n        handleExternalSelection(cm, vim);\n      }\n\n      if (vim.visualMode) {\n        updateFakeCursor(cm);\n      }\n    }\n    /**\n     * Keeps track of a fake cursor to support visual mode cursor behavior.\n     */\n\n\n    function updateFakeCursor(cm) {\n      var className = 'cm-animate-fat-cursor';\n      var vim = cm.state.vim;\n      var from = clipCursorToContent(cm, copyCursor(vim.sel.head));\n      var to = offsetCursor(from, 0, 1);\n      clearFakeCursor(vim); // In visual mode, the cursor may be positioned over EOL.\n\n      if (from.ch == cm.getLine(from.line).length) {\n        var widget = dom('span', {\n          'class': className\n        }, '\\u00a0');\n        vim.fakeCursorBookmark = cm.setBookmark(from, {\n          widget: widget\n        });\n      } else {\n        vim.fakeCursor = cm.markText(from, to, {\n          className: className\n        });\n      }\n    }\n\n    function clearFakeCursor(vim) {\n      if (vim.fakeCursor) {\n        vim.fakeCursor.clear();\n        vim.fakeCursor = null;\n      }\n\n      if (vim.fakeCursorBookmark) {\n        vim.fakeCursorBookmark.clear();\n        vim.fakeCursorBookmark = null;\n      }\n    }\n\n    function handleExternalSelection(cm, vim) {\n      var anchor = cm.getCursor('anchor');\n      var head = cm.getCursor('head'); // Enter or exit visual mode to match mouse selection.\n\n      if (vim.visualMode && !cm.somethingSelected()) {\n        exitVisualMode(cm, false);\n      } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {\n        vim.visualMode = true;\n        vim.visualLine = false;\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"visual\"\n        });\n      }\n\n      if (vim.visualMode) {\n        // Bind CodeMirror selection model to vim selection model.\n        // Mouse selections are considered visual characterwise.\n        var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n        var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n        head = offsetCursor(head, 0, headOffset);\n        anchor = offsetCursor(anchor, 0, anchorOffset);\n        vim.sel = {\n          anchor: anchor,\n          head: head\n        };\n        updateMark(cm, vim, '<', cursorMin(head, anchor));\n        updateMark(cm, vim, '>', cursorMax(head, anchor));\n      } else if (!vim.insertMode) {\n        // Reset lastHPos if selection was modified by something outside of vim mode e.g. by mouse.\n        vim.lastHPos = cm.getCursor().ch;\n      }\n    }\n    /** Wrapper for special keys pressed in insert mode */\n\n\n    function InsertModeKey(keyName) {\n      this.keyName = keyName;\n    }\n    /**\n    * Handles raw key down events from the text area.\n    * - Should only be active in insert mode.\n    * - For recording deletes in insert mode.\n    */\n\n\n    function onKeyEventTargetKeyDown(e) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      var keyName = CodeMirror.keyName(e);\n\n      if (!keyName) {\n        return;\n      }\n\n      function onKeyFound() {\n        if (lastChange.maybeReset) {\n          lastChange.changes = [];\n          lastChange.maybeReset = false;\n        }\n\n        lastChange.changes.push(new InsertModeKey(keyName));\n        return true;\n      }\n\n      if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {\n        CodeMirror.lookupKey(keyName, 'vim-insert', onKeyFound);\n      }\n    }\n    /**\n     * Repeats the last edit, which includes exactly 1 command and at most 1\n     * insert. Operator and motion commands are read from lastEditInputState,\n     * while action commands are read from lastEditActionCommand.\n     *\n     * If repeatForInsert is true, then the function was called by\n     * exitInsertMode to repeat the insert mode changes the user just made. The\n     * corresponding enterInsertMode call was made with a count.\n     */\n\n\n    function repeatLastEdit(cm, vim, repeat, repeatForInsert) {\n      var macroModeState = vimGlobalState.macroModeState;\n      macroModeState.isPlaying = true;\n      var isAction = !!vim.lastEditActionCommand;\n      var cachedInputState = vim.inputState;\n\n      function repeatCommand() {\n        if (isAction) {\n          commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);\n        } else {\n          commandDispatcher.evalInput(cm, vim);\n        }\n      }\n\n      function repeatInsert(repeat) {\n        if (macroModeState.lastInsertModeChanges.changes.length > 0) {\n          // For some reason, repeat cw in desktop VIM does not repeat\n          // insert mode changes. Will conform to that behavior.\n          repeat = !vim.lastEditActionCommand ? 1 : repeat;\n          var changeObject = macroModeState.lastInsertModeChanges;\n          repeatInsertModeChanges(cm, changeObject.changes, repeat);\n        }\n      }\n\n      vim.inputState = vim.lastEditInputState;\n\n      if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {\n        // o and O repeat have to be interlaced with insert repeats so that the\n        // insertions appear on separate lines instead of the last line.\n        for (var i = 0; i < repeat; i++) {\n          repeatCommand();\n          repeatInsert(1);\n        }\n      } else {\n        if (!repeatForInsert) {\n          // Hack to get the cursor to end up at the right place. If I is\n          // repeated in insert mode repeat, cursor will be 1 insert\n          // change set left of where it should be.\n          repeatCommand();\n        }\n\n        repeatInsert(repeat);\n      }\n\n      vim.inputState = cachedInputState;\n\n      if (vim.insertMode && !repeatForInsert) {\n        // Don't exit insert mode twice. If repeatForInsert is set, then we\n        // were called by an exitInsertMode call lower on the stack.\n        exitInsertMode(cm);\n      }\n\n      macroModeState.isPlaying = false;\n    }\n\n    function repeatInsertModeChanges(cm, changes, repeat) {\n      function keyHandler(binding) {\n        if (typeof binding == 'string') {\n          CodeMirror.commands[binding](cm);\n        } else {\n          binding(cm);\n        }\n\n        return true;\n      }\n\n      var head = cm.getCursor('head');\n      var visualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.visualBlock;\n\n      if (visualBlock) {\n        // Set up block selection again for repeating the changes.\n        selectForInsert(cm, head, visualBlock + 1);\n        repeat = cm.listSelections().length;\n        cm.setCursor(head);\n      }\n\n      for (var i = 0; i < repeat; i++) {\n        if (visualBlock) {\n          cm.setCursor(offsetCursor(head, i, 0));\n        }\n\n        for (var j = 0; j < changes.length; j++) {\n          var change = changes[j];\n\n          if (change instanceof InsertModeKey) {\n            CodeMirror.lookupKey(change.keyName, 'vim-insert', keyHandler);\n          } else if (typeof change == \"string\") {\n            var cur = cm.getCursor();\n            cm.replaceRange(change, cur, cur);\n          } else {\n            var start = cm.getCursor();\n            var end = offsetCursor(start, 0, change[0].length);\n            cm.replaceRange(change[0], start, end);\n          }\n        }\n      }\n\n      if (visualBlock) {\n        cm.setCursor(offsetCursor(head, 0, 1));\n      }\n    }\n\n    resetVimGlobalState();\n    return vimApi;\n  }; // Initialize Vim and make it available as an API.\n\n\n  CodeMirror.Vim = Vim();\n});","map":{"version":3,"sources":["/Users/wubo/Desktop/card-design/card-design/node_modules/codemirror/keymap/vim.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","defaultKeymap","keys","type","toKeys","context","action","motion","motionArgs","linewise","toJumplist","forward","wordEnd","bigWord","inclusive","explicitRepeat","toFirstChar","repeatOffset","isEdit","actionArgs","after","matchIndent","sameLine","operator","operatorArgs","indentRight","toLower","operatorMotionArgs","visualLine","shouldMoveCursor","insertAt","interlaceInsertRepeat","blockwise","keepSpaces","replace","fullLine","exitVisualBlock","position","increase","backtrack","textObjectInner","searchArgs","querySrc","wholeWordOnly","defaultKeymapLength","length","defaultExCommandMap","name","shortName","possiblyAsync","excludeFromCommandHistory","Pos","Vim","enterVimMode","cm","setOption","signal","mode","on","onCursorActivity","maybeInitVimState","getInputField","getOnPasteFn","leaveVimMode","off","state","vim","detachVimMap","next","keyMap","rmClass","getWrapperElement","getOption","document","body","style","caretColor","disableFatCursorMark","attach","attachVimMap","prev","addClass","enableFatCursorMark","updateFatCursorMark","fatCursorMarks","clearFatCursorMark","ranges","listSelections","result","i","range","empty","lineLength","getLine","anchor","line","ch","push","markText","className","marks","clear","defineOption","val","Init","test","cmKey","key","undefined","vimKey","cmKeyToVimKey","cmd","findKey","modifiers","Shift","Ctrl","Alt","Cmd","Mod","CapsLock","specialKeys","Enter","Backspace","Delete","Insert","charAt","pieces","split","lastPiece","hasCharacter","piece","isUpperCase","toLowerCase","join","onPasteFn","insertMode","setCursor","offsetCursor","getCursor","actions","enterInsertMode","numberRegex","wordCharTest","isWordChar","bigWordCharTest","makeKeyRange","start","size","String","fromCharCode","upperCaseAlphabet","lowerCaseAlphabet","numbers","validMarks","concat","validRegisters","upperCaseChars","RegExp","_","isLine","firstLine","lastLine","isLowerCase","k","isMatchableSymbol","indexOf","isNumber","isWhiteSpaceString","isEndOfSentenceSymbol","inArray","arr","options","defaultValue","aliases","callback","Error","value","cfg","option","scope","local","createCircularJumpList","pointer","head","tail","buffer","Array","add","oldCur","newCur","current","curMark","useNextSlot","cursor","trashMark","setBookmark","markPos","find","cursorEqual","move","offset","mark","inc","oldPointer","cachedCursor","createInsertModeChanges","c","changes","expectCursorActivityForChange","MacroModeState","latestRegister","isPlaying","isRecording","replaySearchQueries","onRecordingDone","lastInsertModeChanges","prototype","exitMacroRecordMode","macroModeState","vimGlobalState","enterMacroRecordMode","registerName","register","registerController","getRegister","openDialog","createTextNode","bottom","inputState","InputState","lastEditInputState","lastEditActionCommand","lastHPos","lastHSPos","lastMotion","fakeCursor","insertModeRepeat","visualMode","visualBlock","lastSelection","lastPastedText","sel","resetVimGlobalState","searchQuery","searchIsReversed","lastSubstituteReplacePart","jumpList","lastCharacterSearch","increment","selectedCharacter","RegisterController","searchHistoryController","HistoryController","exCommandHistoryController","optionName","lastInsertModeKeyTimer","vimApi","buildKeyMap","getRegisterController","resetVimGlobalState_","getVimGlobalState_","maybeInitVimState_","suppressErrorLogging","InsertModeKey","map","lhs","rhs","ctx","exCommandDispatcher","unmap","noremap","toCtxArray","ctxsToMap","actualLength","origLength","mapping","substr","newMapping","_mapCommand","mappedCtxs","filter","el","mapclear","userKeymap","slice","contexts","j","defineEx","prefix","func","exCommands","commandMap_","handleKey","origin","command","handleMacroRecording","clearInputState","logKey","handleEsc","exitVisualMode","exitInsertMode","doKeyToKey","match","exec","substring","index","handleKeyInsertMode","keyBuffer","keysAreChars","commandDispatcher","matchCommand","thisMatch","window","clearTimeout","setTimeout","selections","here","replaceRange","pop","handleKeyNonInsertMode","keysMatcher","mainKey","operatorShortcut","pushRepeatDigit","operation","curOp","isVimOp","processCommand","e","console","handleEx","input","defineMotion","defineAction","defineOperator","mapCommand","defineRegister","prefixRepeat","motionRepeat","n","getRepeat","repeat","parseInt","reason","Register","text","insertModeChanges","searchQueries","setText","pushText","pushInsertModeChanges","pushSearchQuery","query","toString","registers","unnamedRegister","isValidRegister","shiftNumericRegisters_","append","historyBuffer","iterator","initialPrefix","nextMatch","up","dir","element","pushInput","splice","reset","matches","commandMatches","full","partial","bestMatch","character","lastChar","repeatOverride","processMotion","processOperator","processOperatorMotion","processAction","processSearch","processEx","copyArgs","evalInput","updateCmSelection","repeatIsExplicit","recordLastEdit","getSearchCursor","getSearchState","setReversed","promptPrefix","originalQuery","getQuery","originalScrollPos","getScrollInfo","handleQuery","ignoreCase","smartCase","updateSearchQuery","showConfirm","onPromptClose","scrollTo","left","top","logSearchQuery","onPromptKeyUp","close","keyName","target","selectionEnd","selectionStart","Math","min","parsedQuery","scrollIntoView","findNext","clearSearchHighlight","onPromptKeyDown","e_stop","focus","shift","showPrompt","onClose","desc","onKeyUp","onKeyDown","word","expandWordUnderCursor","isKeyword","end","escapeRegex","exArgs","selectValueOnOpen","origHead","copyCursor","clipCursorToContent","origAnchor","oldHead","oldAnchor","newHead","newAnchor","noRepeat","motionResult","motions","recordJumpPosition","Infinity","updateMark","cursorIsBefore","lastSel","lineOffset","abs","chOffset","curStart","curEnd","cmSel","cursorMin","cursorMax","makeCmSelection","tmp","expandSelectionToLine","clipToLine","exclusive","setSelections","primary","operatorMoveTo","operators","actionCommand","moveToTopLine","_head","getUserVisibleLines","findFirstNonWhiteSpaceCharacter","moveToMiddleLine","floor","moveToBottomLine","expandToLine","_cm","cur","isReversed","highlightSearchMatches","findAndSelectNextInclusive","prevInputState","findNextFromAndToInclusive","from","to","subMode","goToMark","pos","getMarkPos","moveToOtherHighlightedEnd","jumpToMark","best","isWrongDirection","equal","between","cursorIsBetween","moveByCharacters","moveByLines","endCh","moveByDisplayLines","moveByScroll","moveToColumn","moveToEol","first","last","posV","findPosV","hasMarkedText","moveToStartOfLine","charCoords","res","hitSide","lastCharCoords","goalCoords","coordsChar","resCoords","moveByPage","moveByParagraph","findParagraph","moveBySentence","findSentence","scrollbox","clientHeight","defaultTextHeight","orig","dest","moveByWords","moveToWord","moveTillCharacter","moveToCharacter","recordLastCharacterSearch","moveToSymbol","findSymbol","moveToFirstNonWhiteSpaceCharacter","moveToMatchedSymbol","lineText","symbol","getTokenTypeAt","re","matched","findMatchingBracket","bracketRegex","moveToLineOrEdgeOfDocument","lineNum","textObjectManipulation","mirroredPairs","selfPaired","selectCompanionObject","findBeginningAndEnd","expandTagUnderCursor","expandSelection","repeatLastCharacterSearch","lastSearch","moveH","fn","fillArray","times","change","args","finalHead","getRange","lastState","prevLineEnd","Number","MAX_VALUE","wasLastLine","commands","newlineAndIndent","setSelection","getSelection","replaceSelection","replacement","replaceSelections","indent","startLine","endLine","indentLine","indentAuto","_args","execCommand","changeCase","getSelections","swapped","toSwap","toUpperCase","yank","endPos","jumpListWalk","scroll","lineHeight","delta","newPos","cursorCoords","ceil","newBottom","scrollToCursor","height","y","replayMacro","executeMacroRegister","toggleOverwrite","overwrite","max","getLastEditPos","onChange","onKeyEventTargetKeyDown","selectForInsert","toggleVisualMode","reselectLastSelection","_actionArgs","updateLastSelection","anchorMark","headMark","joinLines","finalCh","curFinalPos","newLineAndEnterInsertMode","newlineFn","newlineAndIndentContinueComment","paste","tabSize","whitespaceLength","str","tabs","spaces","currentLine","chompedText","wasChomped","firstIndent","wspace","newIndent","quotient","curPosFinal","idx","lastSelectionCurEnd","selectedArea","getSelectedAreaRange","selectedText","emptyStrings","selectBlock","posFromIndex","indexFromPos","lastCh","extendLineToColumn","undo","repeatFn","redo","setRegister","setMark","markName","replaceWith","replaceTo","replaceWithStr","incrementNumberToken","lineStr","numberStr","baseStr","digits","base","number","zeroPadding","repeatLastEdit","includeLineBreak","maxCh","ret","prop","hasOwnProperty","offsetLine","offsetCh","commandMatch","pressed","mapped","prefixLen","pressedPrefix","mappedPrefix","cur1","cur2","arguments","apply","call","cur3","cur1before2","cur2before3","trim","s","column","clipPos","isClipped","curHead","primIndex","getIndex","wasClipped","baseCh","headCh","newDir","lineHead","atAnchor","atHead","getCurrentSelectedAreaRange","getLastSelectedAreaRange","block","width","updateFakeCursor","headOffset","anchorOffset","right","getHead","moveHead","clearFakeCursor","selection","lines","firstNonWS","search","_forward","noSymbol","wordStart","findMatchingTag","findEnclosingTag","tags","open","symbolToMode","findSymbolModes","bracket","isComplete","nextCh","symb","depth","reverseSymb","section","init","curMoveThrough","comment","found","method","preprocess","token","lineCount","curCh","lineLen","findWord","emptyLineIsWord","charTests","stop","foundWord","words","eodCh","shortCircuit","firstWord","lastWord","keepHPos","retval","charIdxInLine","includeChar","lastIndexOf","isEmpty","isBoundary","any","startState","nextChar","ln","curr","last_valid","skip_empty_lines","reverse","curr_index","bracketRegexp","openSym","curChar","scanForBracket","chars","len","firstIndex","SearchState","setQuery","getOverlay","searchOverlay","setOverlay","overlay","reversed","getScrollbarAnnotate","annotate","setScrollbarAnnotate","searchState_","splitBySlash","argString","splitBySeparator","findUnescapedSlashes","findUnescapedSeparators","separator","slashes","tokens","escapeNextChar","translateRegex","specials","unescape","out","specialComesNext","charUnescapes","translateRegexReplace","unescapes","unescapeRegexReplace","stream","StringStream","output","eol","peek","matcher","parseQuery","lastSearchRegister","regexPart","forceIgnoreCase","flagsPart","regexp","dom","createElement","a","nodeType","appendChild","Object","setAttribute","template","pre","$color","openNotification","duration","alert","innerText","makePrompt","createDocumentFragment","$fontFamily","$whiteSpace","autocorrect","autocapitalize","spellcheck","shortText","prompt","regexEqual","r1","r2","props","rawQuery","source","matchSol","sol","skipToEnd","backUp","highlightTimeout","searchState","removeOverlay","addOverlay","showMatchesOnScrollbar","lastEndPos","isInRange","scrollInfo","occludeToleranceTop","occludeToleranceBottom","bottomY","done","doc","history","ExCommandDispatcher","buildCommandMap_","opt_params","that","_processCommand","commandHistoryRegister","previousCommand","inputStream","params","parseInput_","commandName","matchCommand_","parseCommandArgs_","toInput","eatWhile","eat","lineEnd","parseLineSpec_","numberMatch","parseLineSpecOffset_","offsetMatch","delim","argDelimiter","user","unshift","colorscheme","mapArgs","imap","nmap","vmap","set","setArgs","setCfg","expr","forceGet","optionIsBoolean","oldValue","message","setOptionReturn","setlocal","setglobal","regArgs","regInfo","sort","unique","pattern","parseArgs","eatSpace","opts","decimal","hex","octal","err","lineStart","radix","numPart","textPart","matchPart","compareFn","b","anum","bnum","comparePatternFn","textOld","vglobal","global","inverted","matchedLines","getLineHandle","nextCommand","getLineNumber","substitute","replacePart","trailing","count","confirm","startPos","doReplace","write","save","nohlsearch","delmarks","sym","startMark","finishMark","charCodeAt","finish","searchCursor","exMode","lastPos","modifiedLineNumber","joined","replaceAll","newText","unmodifiedLineNumber","findNextValidMatch","lastMatchTo","_value","savedCallback","detach","insertModeChangeRegister","lastChange","logInsertModeChange","extra","fallthrough","imc","repeatInsertModeChanges","changeObj","ignoreCount","selectionCount","maybeReset","handleExternalSelection","widget","fakeCursorBookmark","somethingSelected","onKeyFound","lookupKey","repeatForInsert","isAction","cachedInputState","repeatCommand","repeatInsert","changeObject","keyHandler","binding"],"mappings":"AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,CAAC,UAASA,GAAT,EAAc;AACb,MAAI,OAAOC,OAAP,IAAkB,QAAlB,IAA8B,OAAOC,MAAP,IAAiB,QAAnD,EAA6D;AAC3DF,IAAAA,GAAG,CAACG,OAAO,CAAC,mBAAD,CAAR,EAA+BA,OAAO,CAAC,8BAAD,CAAtC,EAAwEA,OAAO,CAAC,wBAAD,CAA/E,EAA2GA,OAAO,CAAC,gCAAD,CAAlH,CAAH,CADF,KAEK,IAAI,OAAOC,MAAP,IAAiB,UAAjB,IAA+BA,MAAM,CAACC,GAA1C,EAA+C;AAClDD,IAAAA,MAAM,CAAC,CAAC,mBAAD,EAAsB,8BAAtB,EAAsD,wBAAtD,EAAgF,6BAAhF,CAAD,EAAiHJ,GAAjH,CAAN,CADG,KAEA;AACHA,IAAAA,GAAG,CAACM,UAAD,CAAH;AACH,CAPD,EAOG,UAASA,UAAT,EAAqB;AACtB;;AAEA,MAAIC,aAAa,GAAG,CAClB;AACA;AACA;AAAEC,IAAAA,IAAI,EAAE,QAAR;AAAkBC,IAAAA,IAAI,EAAE,UAAxB;AAAoCC,IAAAA,MAAM,EAAE;AAA5C,GAHkB,EAIlB;AAAEF,IAAAA,IAAI,EAAE,SAAR;AAAmBC,IAAAA,IAAI,EAAE,UAAzB;AAAqCC,IAAAA,MAAM,EAAE;AAA7C,GAJkB,EAKlB;AAAEF,IAAAA,IAAI,EAAE,MAAR;AAAgBC,IAAAA,IAAI,EAAE,UAAtB;AAAkCC,IAAAA,MAAM,EAAE;AAA1C,GALkB,EAMlB;AAAEF,IAAAA,IAAI,EAAE,QAAR;AAAkBC,IAAAA,IAAI,EAAE,UAAxB;AAAoCC,IAAAA,MAAM,EAAE;AAA5C,GANkB,EAOlB;AAAEF,IAAAA,IAAI,EAAE,SAAR;AAAmBC,IAAAA,IAAI,EAAE,UAAzB;AAAqCC,IAAAA,MAAM,EAAE;AAA7C,GAPkB,EAQlB;AAAEF,IAAAA,IAAI,EAAE,MAAR;AAAgBC,IAAAA,IAAI,EAAE,UAAtB;AAAkCC,IAAAA,MAAM,EAAE,GAA1C;AAA+CC,IAAAA,OAAO,EAAE;AAAxD,GARkB,EASlB;AAAEH,IAAAA,IAAI,EAAE,OAAR;AAAiBC,IAAAA,IAAI,EAAE,UAAvB;AAAmCC,IAAAA,MAAM,EAAE,GAA3C;AAAgDC,IAAAA,OAAO,EAAE;AAAzD,GATkB,EAUlB;AAAEH,IAAAA,IAAI,EAAE,WAAR;AAAqBC,IAAAA,IAAI,EAAE,UAA3B;AAAuCC,IAAAA,MAAM,EAAE;AAA/C,GAVkB,EAWlB;AAAEF,IAAAA,IAAI,EAAE,QAAR;AAAkBC,IAAAA,IAAI,EAAE,UAAxB;AAAoCC,IAAAA,MAAM,EAAE,GAA5C;AAAiDC,IAAAA,OAAO,EAAE;AAA1D,GAXkB,EAYlB;AAAEH,IAAAA,IAAI,EAAE,WAAR;AAAqBC,IAAAA,IAAI,EAAE,UAA3B;AAAuCC,IAAAA,MAAM,EAAE;AAA/C,GAZkB,EAalB;AAAEF,IAAAA,IAAI,EAAE,QAAR;AAAkBC,IAAAA,IAAI,EAAE,UAAxB;AAAoCC,IAAAA,MAAM,EAAE,GAA5C;AAAiDC,IAAAA,OAAO,EAAE;AAA1D,GAbkB,EAclB;AAAEH,IAAAA,IAAI,EAAE,OAAR;AAAiBC,IAAAA,IAAI,EAAE,UAAvB;AAAmCC,IAAAA,MAAM,EAAE;AAA3C,GAdkB,EAelB;AAAEF,IAAAA,IAAI,EAAE,OAAR;AAAiBC,IAAAA,IAAI,EAAE,UAAvB;AAAmCC,IAAAA,MAAM,EAAE;AAA3C,GAfkB,EAgBlB;AAAEF,IAAAA,IAAI,EAAE,OAAR;AAAiBC,IAAAA,IAAI,EAAE,UAAvB;AAAmCC,IAAAA,MAAM,EAAE;AAA3C,GAhBkB,EAiBlB;AAAEF,IAAAA,IAAI,EAAE,OAAR;AAAiBC,IAAAA,IAAI,EAAE,UAAvB;AAAmCC,IAAAA,MAAM,EAAE;AAA3C,GAjBkB,EAkBlB;AAAEF,IAAAA,IAAI,EAAE,OAAR;AAAiBC,IAAAA,IAAI,EAAE,UAAvB;AAAmCC,IAAAA,MAAM,EAAE,OAA3C;AAAoDC,IAAAA,OAAO,EAAE;AAA7D,GAlBkB,EAmBlB;AAAEH,IAAAA,IAAI,EAAE,OAAR;AAAiBC,IAAAA,IAAI,EAAE,UAAvB;AAAmCC,IAAAA,MAAM,EAAE,OAA3C;AAAoDC,IAAAA,OAAO,EAAE;AAA7D,GAnBkB,EAoBlB;AAAEH,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,UAAnB;AAA+BC,IAAAA,MAAM,EAAE,IAAvC;AAA6CC,IAAAA,OAAO,EAAE;AAAtD,GApBkB,EAqBlB;AAAEH,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,UAAnB;AAA+BC,IAAAA,MAAM,EAAE,GAAvC;AAA4CC,IAAAA,OAAO,EAAE;AAArD,GArBkB,EAsBlB;AAAEH,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,UAAnB;AAA+BC,IAAAA,MAAM,EAAE,IAAvC;AAA6CC,IAAAA,OAAO,EAAE;AAAtD,GAtBkB,EAuBlB;AAAEH,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,UAAnB;AAA+BC,IAAAA,MAAM,EAAE,KAAvC;AAA8CC,IAAAA,OAAO,EAAE;AAAvD,GAvBkB,EAwBlB;AAAEH,IAAAA,IAAI,EAAE,QAAR;AAAkBC,IAAAA,IAAI,EAAE,UAAxB;AAAoCC,IAAAA,MAAM,EAAE;AAA5C,GAxBkB,EAyBlB;AAAEF,IAAAA,IAAI,EAAE,OAAR;AAAiBC,IAAAA,IAAI,EAAE,UAAvB;AAAmCC,IAAAA,MAAM,EAAE;AAA3C,GAzBkB,EA0BlB;AAAEF,IAAAA,IAAI,EAAE,UAAR;AAAoBC,IAAAA,IAAI,EAAE,UAA1B;AAAsCC,IAAAA,MAAM,EAAE;AAA9C,GA1BkB,EA2BlB;AAAEF,IAAAA,IAAI,EAAE,YAAR;AAAsBC,IAAAA,IAAI,EAAE,UAA5B;AAAwCC,IAAAA,MAAM,EAAE;AAAhD,GA3BkB,EA4BlB;AAAEF,IAAAA,IAAI,EAAE,MAAR;AAAgBC,IAAAA,IAAI,EAAE,UAAtB;AAAkCC,IAAAA,MAAM,EAAE,IAA1C;AAAgDC,IAAAA,OAAO,EAAE;AAAzD,GA5BkB,EA6BlB;AAAEH,IAAAA,IAAI,EAAE,OAAR;AAAiBC,IAAAA,IAAI,EAAE,QAAvB;AAAiCG,IAAAA,MAAM,EAAE,iBAAzC;AAA4DD,IAAAA,OAAO,EAAE;AAArE,GA7BkB,EA8BlB;AACA;AAAEH,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BI,IAAAA,MAAM,EAAE,eAArC;AAAsDC,IAAAA,UAAU,EAAE;AAAEC,MAAAA,QAAQ,EAAE,IAAZ;AAAkBC,MAAAA,UAAU,EAAE;AAA9B;AAAlE,GA/BkB,EAgClB;AAAER,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BI,IAAAA,MAAM,EAAE,kBAArC;AAAyDC,IAAAA,UAAU,EAAE;AAAEC,MAAAA,QAAQ,EAAE,IAAZ;AAAkBC,MAAAA,UAAU,EAAE;AAA9B;AAArE,GAhCkB,EAiClB;AAAER,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BI,IAAAA,MAAM,EAAE,kBAArC;AAAyDC,IAAAA,UAAU,EAAE;AAAEC,MAAAA,QAAQ,EAAE,IAAZ;AAAkBC,MAAAA,UAAU,EAAE;AAA9B;AAArE,GAjCkB,EAkClB;AAAER,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BI,IAAAA,MAAM,EAAE,kBAArC;AAAyDC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE;AAAX;AAArE,GAlCkB,EAmClB;AAAET,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BI,IAAAA,MAAM,EAAE,kBAArC;AAAyDC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE;AAAX;AAArE,GAnCkB,EAoClB;AAAET,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BI,IAAAA,MAAM,EAAE,aAArC;AAAoDC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE,IAAX;AAAiBF,MAAAA,QAAQ,EAAE;AAA3B;AAAhE,GApCkB,EAqClB;AAAEP,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BI,IAAAA,MAAM,EAAE,aAArC;AAAoDC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE,KAAX;AAAkBF,MAAAA,QAAQ,EAAE;AAA5B;AAAhE,GArCkB,EAsClB;AAAEP,IAAAA,IAAI,EAAE,IAAR;AAAcC,IAAAA,IAAI,EAAE,QAApB;AAA8BI,IAAAA,MAAM,EAAE,oBAAtC;AAA4DC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE;AAAX;AAAxE,GAtCkB,EAuClB;AAAET,IAAAA,IAAI,EAAE,IAAR;AAAcC,IAAAA,IAAI,EAAE,QAApB;AAA8BI,IAAAA,MAAM,EAAE,oBAAtC;AAA4DC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE;AAAX;AAAxE,GAvCkB,EAwClB;AAAET,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BI,IAAAA,MAAM,EAAE,aAArC;AAAoDC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE,IAAX;AAAiBC,MAAAA,OAAO,EAAE;AAA1B;AAAhE,GAxCkB,EAyClB;AAAEV,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BI,IAAAA,MAAM,EAAE,aAArC;AAAoDC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE,IAAX;AAAiBC,MAAAA,OAAO,EAAE,KAA1B;AAAiCC,MAAAA,OAAO,EAAE;AAA1C;AAAhE,GAzCkB,EA0ClB;AAAEX,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BI,IAAAA,MAAM,EAAE,aAArC;AAAoDC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE,IAAX;AAAiBC,MAAAA,OAAO,EAAE,IAA1B;AAAgCE,MAAAA,SAAS,EAAE;AAA3C;AAAhE,GA1CkB,EA2ClB;AAAEZ,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BI,IAAAA,MAAM,EAAE,aAArC;AAAoDC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE,IAAX;AAAiBC,MAAAA,OAAO,EAAE,IAA1B;AAAgCC,MAAAA,OAAO,EAAE,IAAzC;AAA+CC,MAAAA,SAAS,EAAE;AAA1D;AAAhE,GA3CkB,EA4ClB;AAAEZ,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BI,IAAAA,MAAM,EAAE,aAArC;AAAoDC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE,KAAX;AAAkBC,MAAAA,OAAO,EAAE;AAA3B;AAAhE,GA5CkB,EA6ClB;AAAEV,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BI,IAAAA,MAAM,EAAE,aAArC;AAAoDC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE,KAAX;AAAkBC,MAAAA,OAAO,EAAE,KAA3B;AAAkCC,MAAAA,OAAO,EAAE;AAA3C;AAAhE,GA7CkB,EA8ClB;AAAEX,IAAAA,IAAI,EAAE,IAAR;AAAcC,IAAAA,IAAI,EAAE,QAApB;AAA8BI,IAAAA,MAAM,EAAE,aAAtC;AAAqDC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE,KAAX;AAAkBC,MAAAA,OAAO,EAAE,IAA3B;AAAiCE,MAAAA,SAAS,EAAE;AAA5C;AAAjE,GA9CkB,EA+ClB;AAAEZ,IAAAA,IAAI,EAAE,IAAR;AAAcC,IAAAA,IAAI,EAAE,QAApB;AAA8BI,IAAAA,MAAM,EAAE,aAAtC;AAAqDC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE,KAAX;AAAkBC,MAAAA,OAAO,EAAE,IAA3B;AAAiCC,MAAAA,OAAO,EAAE,IAA1C;AAAgDC,MAAAA,SAAS,EAAE;AAA3D;AAAjE,GA/CkB,EAgDlB;AAAEZ,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BI,IAAAA,MAAM,EAAE,iBAArC;AAAwDC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE,KAAX;AAAkBD,MAAAA,UAAU,EAAE;AAA9B;AAApE,GAhDkB,EAiDlB;AAAER,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BI,IAAAA,MAAM,EAAE,iBAArC;AAAwDC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE,IAAX;AAAiBD,MAAAA,UAAU,EAAE;AAA7B;AAApE,GAjDkB,EAkDlB;AAAER,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BI,IAAAA,MAAM,EAAE,gBAArC;AAAuDC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE;AAAX;AAAnE,GAlDkB,EAmDlB;AAAET,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BI,IAAAA,MAAM,EAAE,gBAArC;AAAuDC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE;AAAX;AAAnE,GAnDkB,EAoDlB;AAAET,IAAAA,IAAI,EAAE,OAAR;AAAiBC,IAAAA,IAAI,EAAE,QAAvB;AAAiCI,IAAAA,MAAM,EAAE,YAAzC;AAAuDC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE;AAAX;AAAnE,GApDkB,EAqDlB;AAAET,IAAAA,IAAI,EAAE,OAAR;AAAiBC,IAAAA,IAAI,EAAE,QAAvB;AAAiCI,IAAAA,MAAM,EAAE,YAAzC;AAAuDC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE;AAAX;AAAnE,GArDkB,EAsDlB;AAAET,IAAAA,IAAI,EAAE,OAAR;AAAiBC,IAAAA,IAAI,EAAE,QAAvB;AAAiCI,IAAAA,MAAM,EAAE,cAAzC;AAAyDC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE,IAAX;AAAiBI,MAAAA,cAAc,EAAE;AAAjC;AAArE,GAtDkB,EAuDlB;AAAEb,IAAAA,IAAI,EAAE,OAAR;AAAiBC,IAAAA,IAAI,EAAE,QAAvB;AAAiCI,IAAAA,MAAM,EAAE,cAAzC;AAAyDC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE,KAAX;AAAkBI,MAAAA,cAAc,EAAE;AAAlC;AAArE,GAvDkB,EAwDlB;AAAEb,IAAAA,IAAI,EAAE,IAAR;AAAcC,IAAAA,IAAI,EAAE,QAApB;AAA8BI,IAAAA,MAAM,EAAE,4BAAtC;AAAoEC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE,KAAX;AAAkBI,MAAAA,cAAc,EAAE,IAAlC;AAAwCN,MAAAA,QAAQ,EAAE,IAAlD;AAAwDC,MAAAA,UAAU,EAAE;AAApE;AAAhF,GAxDkB,EAyDlB;AAAER,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BI,IAAAA,MAAM,EAAE,4BAArC;AAAmEC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE,IAAX;AAAiBI,MAAAA,cAAc,EAAE,IAAjC;AAAuCN,MAAAA,QAAQ,EAAE,IAAjD;AAAuDC,MAAAA,UAAU,EAAE;AAAnE;AAA/E,GAzDkB,EA0DlB;AAAER,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BI,IAAAA,MAAM,EAAE;AAArC,GA1DkB,EA2DlB;AAAEL,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BI,IAAAA,MAAM,EAAE;AAArC,GA3DkB,EA4DlB;AAAEL,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BI,IAAAA,MAAM,EAAE,aAArC;AAAoDC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE,IAAX;AAAiBK,MAAAA,WAAW,EAAC;AAA7B;AAAhE,GA5DkB,EA6DlB;AAAEd,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BI,IAAAA,MAAM,EAAE,aAArC;AAAoDC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE,KAAX;AAAkBK,MAAAA,WAAW,EAAC;AAA9B;AAAhE,GA7DkB,EA8DlB;AAAEd,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BI,IAAAA,MAAM,EAAE,aAArC;AAAoDC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE,IAAX;AAAiBK,MAAAA,WAAW,EAAC,IAA7B;AAAmCC,MAAAA,YAAY,EAAC,CAAC;AAAjD;AAAhE,GA9DkB,EA+DlB;AAAEf,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BI,IAAAA,MAAM,EAAE,WAArC;AAAkDC,IAAAA,UAAU,EAAE;AAAEM,MAAAA,SAAS,EAAE;AAAb;AAA9D,GA/DkB,EAgElB;AAAEZ,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BI,IAAAA,MAAM,EAAE,qBAArC;AAA4DC,IAAAA,UAAU,EAAE;AAAEM,MAAAA,SAAS,EAAE,IAAb;AAAmBJ,MAAAA,UAAU,EAAE;AAA/B;AAAxE,GAhEkB,EAiElB;AAAER,IAAAA,IAAI,EAAE,cAAR;AAAwBC,IAAAA,IAAI,EAAE,QAA9B;AAAwCI,IAAAA,MAAM,EAAE,iBAAhD;AAAmEC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE,IAAX;AAAkBG,MAAAA,SAAS,EAAE;AAA7B;AAA/E,GAjEkB,EAkElB;AAAEZ,IAAAA,IAAI,EAAE,cAAR;AAAwBC,IAAAA,IAAI,EAAE,QAA9B;AAAwCI,IAAAA,MAAM,EAAE,iBAAhD;AAAmEC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE;AAAX;AAA/E,GAlEkB,EAmElB;AAAET,IAAAA,IAAI,EAAE,cAAR;AAAwBC,IAAAA,IAAI,EAAE,QAA9B;AAAwCI,IAAAA,MAAM,EAAE,mBAAhD;AAAqEC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE,IAAX;AAAiBG,MAAAA,SAAS,EAAE;AAA5B;AAAjF,GAnEkB,EAoElB;AAAEZ,IAAAA,IAAI,EAAE,cAAR;AAAwBC,IAAAA,IAAI,EAAE,QAA9B;AAAwCI,IAAAA,MAAM,EAAE,mBAAhD;AAAqEC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE;AAAX;AAAjF,GApEkB,EAqElB;AAAET,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BI,IAAAA,MAAM,EAAE,2BAArC;AAAkEC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE;AAAX;AAA9E,GArEkB,EAsElB;AAAET,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BI,IAAAA,MAAM,EAAE,2BAArC;AAAkEC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE;AAAX;AAA9E,GAtEkB,EAuElB;AAAET,IAAAA,IAAI,EAAE,eAAR;AAAyBC,IAAAA,IAAI,EAAE,QAA/B;AAAyCI,IAAAA,MAAM,EAAE,UAAjD;AAA6DC,IAAAA,UAAU,EAAE;AAACE,MAAAA,UAAU,EAAE,IAAb;AAAmBD,MAAAA,QAAQ,EAAE;AAA7B;AAAzE,GAvEkB,EAwElB;AAAEP,IAAAA,IAAI,EAAE,cAAR;AAAwBC,IAAAA,IAAI,EAAE,QAA9B;AAAwCI,IAAAA,MAAM,EAAE,UAAhD;AAA4DC,IAAAA,UAAU,EAAE;AAACE,MAAAA,UAAU,EAAE;AAAb;AAAxE,GAxEkB,EAyElB;AAAER,IAAAA,IAAI,EAAE,IAAR;AAAcC,IAAAA,IAAI,EAAE,QAApB;AAA8BI,IAAAA,MAAM,EAAE,YAAtC;AAAoDC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE;AAAX;AAAhE,GAzEkB,EA0ElB;AAAET,IAAAA,IAAI,EAAE,IAAR;AAAcC,IAAAA,IAAI,EAAE,QAApB;AAA8BI,IAAAA,MAAM,EAAE,YAAtC;AAAoDC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE;AAAX;AAAhE,GA1EkB,EA2ElB;AAAET,IAAAA,IAAI,EAAE,KAAR;AAAeC,IAAAA,IAAI,EAAE,QAArB;AAA+BI,IAAAA,MAAM,EAAE,YAAvC;AAAqDC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE,IAAX;AAAiBF,MAAAA,QAAQ,EAAE;AAA3B;AAAjE,GA3EkB,EA4ElB;AAAEP,IAAAA,IAAI,EAAE,KAAR;AAAeC,IAAAA,IAAI,EAAE,QAArB;AAA+BI,IAAAA,MAAM,EAAE,YAAvC;AAAqDC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE,KAAX;AAAkBF,MAAAA,QAAQ,EAAE;AAA5B;AAAjE,GA5EkB,EA6ElB;AACA;AAAEP,IAAAA,IAAI,EAAE,IAAR;AAAcC,IAAAA,IAAI,EAAE,QAApB;AAA8BG,IAAAA,MAAM,EAAE,OAAtC;AAA+CY,IAAAA,MAAM,EAAE,IAAvD;AAA6DC,IAAAA,UAAU,EAAE;AAAEC,MAAAA,KAAK,EAAE,IAAT;AAAeF,MAAAA,MAAM,EAAE,IAAvB;AAA6BG,MAAAA,WAAW,EAAE;AAA1C;AAAzE,GA9EkB,EA+ElB;AAAEnB,IAAAA,IAAI,EAAE,IAAR;AAAcC,IAAAA,IAAI,EAAE,QAApB;AAA8BG,IAAAA,MAAM,EAAE,OAAtC;AAA+CY,IAAAA,MAAM,EAAE,IAAvD;AAA6DC,IAAAA,UAAU,EAAE;AAAEC,MAAAA,KAAK,EAAE,KAAT;AAAgBF,MAAAA,MAAM,EAAE,IAAxB;AAA8BG,MAAAA,WAAW,EAAE;AAA3C;AAAzE,GA/EkB,EAgFlB;AAAEnB,IAAAA,IAAI,EAAE,cAAR;AAAwBC,IAAAA,IAAI,EAAE,QAA9B;AAAwCI,IAAAA,MAAM,EAAE,cAAhD;AAAgEC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE,IAAX;AAAiBD,MAAAA,UAAU,EAAE;AAA7B;AAA5E,GAhFkB,EAiFlB;AAAER,IAAAA,IAAI,EAAE,cAAR;AAAwBC,IAAAA,IAAI,EAAE,QAA9B;AAAwCI,IAAAA,MAAM,EAAE,cAAhD;AAAgEC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE,KAAX;AAAkBD,MAAAA,UAAU,EAAE;AAA9B;AAA5E,GAjFkB,EAkFlB;AAAER,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BI,IAAAA,MAAM,EAAE;AAArC,GAlFkB,EAmFlB;AAAEL,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BI,IAAAA,MAAM,EAAE,2BAArC;AAAkEF,IAAAA,OAAO,EAAC;AAA1E,GAnFkB,EAoFlB;AAAEH,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BI,IAAAA,MAAM,EAAE,2BAArC;AAAkEC,IAAAA,UAAU,EAAE;AAACc,MAAAA,QAAQ,EAAE;AAAX,KAA9E;AAAgGjB,IAAAA,OAAO,EAAC;AAAxG,GApFkB,EAqFlB;AACA;AAAEH,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,UAAnB;AAA+BoB,IAAAA,QAAQ,EAAE;AAAzC,GAtFkB,EAuFlB;AAAErB,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,UAAnB;AAA+BoB,IAAAA,QAAQ,EAAE;AAAzC,GAvFkB,EAwFlB;AAAErB,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,UAAnB;AAA+BoB,IAAAA,QAAQ,EAAE;AAAzC,GAxFkB,EAyFlB;AAAErB,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,UAAnB;AAA+BoB,IAAAA,QAAQ,EAAE;AAAzC,GAzFkB,EA0FlB;AAAErB,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,UAAnB;AAA+BoB,IAAAA,QAAQ,EAAE,QAAzC;AAAmDC,IAAAA,YAAY,EAAE;AAAEC,MAAAA,WAAW,EAAE;AAAf;AAAjE,GA1FkB,EA2FlB;AAAEvB,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,UAAnB;AAA+BoB,IAAAA,QAAQ,EAAE,QAAzC;AAAmDC,IAAAA,YAAY,EAAE;AAAEC,MAAAA,WAAW,EAAE;AAAf;AAAjE,GA3FkB,EA4FlB;AAAEvB,IAAAA,IAAI,EAAE,IAAR;AAAcC,IAAAA,IAAI,EAAE,UAApB;AAAgCoB,IAAAA,QAAQ,EAAE;AAA1C,GA5FkB,EA6FlB;AAAErB,IAAAA,IAAI,EAAE,IAAR;AAAcC,IAAAA,IAAI,EAAE,UAApB;AAAgCoB,IAAAA,QAAQ,EAAE,YAA1C;AAAwDC,IAAAA,YAAY,EAAE;AAACE,MAAAA,OAAO,EAAE;AAAV,KAAtE;AAAuFR,IAAAA,MAAM,EAAE;AAA/F,GA7FkB,EA8FlB;AAAEhB,IAAAA,IAAI,EAAE,IAAR;AAAcC,IAAAA,IAAI,EAAE,UAApB;AAAgCoB,IAAAA,QAAQ,EAAE,YAA1C;AAAwDC,IAAAA,YAAY,EAAE;AAACE,MAAAA,OAAO,EAAE;AAAV,KAAtE;AAAwFR,IAAAA,MAAM,EAAE;AAAhG,GA9FkB,EA+FlB;AAAEhB,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BI,IAAAA,MAAM,EAAE,UAArC;AAAiDC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE,IAAX;AAAiBD,MAAAA,UAAU,EAAE;AAA7B;AAA7D,GA/FkB,EAgGlB;AAAER,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BI,IAAAA,MAAM,EAAE,UAArC;AAAiDC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE,KAAX;AAAkBD,MAAAA,UAAU,EAAE;AAA9B;AAA7D,GAhGkB,EAiGlB;AAAER,IAAAA,IAAI,EAAE,IAAR;AAAcC,IAAAA,IAAI,EAAE,QAApB;AAA8BI,IAAAA,MAAM,EAAE,4BAAtC;AAAoEC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE;AAAX;AAAhF,GAjGkB,EAkGlB;AAAET,IAAAA,IAAI,EAAE,IAAR;AAAcC,IAAAA,IAAI,EAAE,QAApB;AAA8BI,IAAAA,MAAM,EAAE,4BAAtC;AAAoEC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE;AAAX;AAAhF,GAlGkB,EAmGlB;AACA;AAAET,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,gBAAnB;AAAqCoB,IAAAA,QAAQ,EAAE,QAA/C;AAAyDhB,IAAAA,MAAM,EAAE,kBAAjE;AAAqFC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE;AAAX,KAAjG;AAAoHgB,IAAAA,kBAAkB,EAAE;AAAEC,MAAAA,UAAU,EAAE;AAAd;AAAxI,GApGkB,EAqGlB;AAAE1B,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,gBAAnB;AAAqCoB,IAAAA,QAAQ,EAAE,QAA/C;AAAyDhB,IAAAA,MAAM,EAAE,kBAAjE;AAAqFC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE;AAAX,KAAjG;AAAqHgB,IAAAA,kBAAkB,EAAE;AAAEC,MAAAA,UAAU,EAAE;AAAd;AAAzI,GArGkB,EAsGlB;AAAE1B,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,gBAAnB;AAAqCoB,IAAAA,QAAQ,EAAE,QAA/C;AAAyDhB,IAAAA,MAAM,EAAE,WAAjE;AAA8EC,IAAAA,UAAU,EAAE;AAAEM,MAAAA,SAAS,EAAE;AAAb,KAA1F;AAA+GT,IAAAA,OAAO,EAAE;AAAxH,GAtGkB,EAuGlB;AAAEH,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,UAAnB;AAA+BoB,IAAAA,QAAQ,EAAE,QAAzC;AAAmDC,IAAAA,YAAY,EAAE;AAAEf,MAAAA,QAAQ,EAAE;AAAZ,KAAjE;AAAqFJ,IAAAA,OAAO,EAAE;AAA9F,GAvGkB,EAwGlB;AAAEH,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,gBAAnB;AAAqCoB,IAAAA,QAAQ,EAAE,MAA/C;AAAuDhB,IAAAA,MAAM,EAAE,cAA/D;AAA+EC,IAAAA,UAAU,EAAE;AAAEC,MAAAA,QAAQ,EAAE;AAAZ,KAA3F;AAA+GJ,IAAAA,OAAO,EAAE;AAAxH,GAxGkB,EAyGlB;AAAEH,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,UAAnB;AAA+BoB,IAAAA,QAAQ,EAAE,MAAzC;AAAiDC,IAAAA,YAAY,EAAE;AAAEf,MAAAA,QAAQ,EAAE;AAAZ,KAA/D;AAAmFJ,IAAAA,OAAO,EAAE;AAA5F,GAzGkB,EA0GlB;AAAEH,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,gBAAnB;AAAqCoB,IAAAA,QAAQ,EAAE,QAA/C;AAAyDhB,IAAAA,MAAM,EAAE,WAAjE;AAA8EC,IAAAA,UAAU,EAAE;AAAEM,MAAAA,SAAS,EAAE;AAAb,KAA1F;AAA+GT,IAAAA,OAAO,EAAE;AAAxH,GA1GkB,EA2GlB;AAAEH,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,UAAnB;AAA+BoB,IAAAA,QAAQ,EAAE,QAAzC;AAAmDC,IAAAA,YAAY,EAAE;AAAEf,MAAAA,QAAQ,EAAE;AAAZ,KAAjE;AAAqFJ,IAAAA,OAAO,EAAE;AAA9F,GA3GkB,EA4GlB;AAAEH,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,gBAAnB;AAAqCoB,IAAAA,QAAQ,EAAE,YAA/C;AAA6DhB,IAAAA,MAAM,EAAE,kBAArE;AAAyFC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE;AAAX,KAArG;AAAwHa,IAAAA,YAAY,EAAE;AAAEK,MAAAA,gBAAgB,EAAE;AAApB,KAAtI;AAAkKxB,IAAAA,OAAO,EAAE;AAA3K,GA5GkB,EA6GlB;AAAEH,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,UAAnB;AAA+BoB,IAAAA,QAAQ,EAAE,YAAzC;AAAuDlB,IAAAA,OAAO,EAAE;AAAhE,GA7GkB,EA8GlB;AAAEH,IAAAA,IAAI,EAAE,OAAR;AAAiBC,IAAAA,IAAI,EAAE,gBAAvB;AAAyCoB,IAAAA,QAAQ,EAAE,QAAnD;AAA6DhB,IAAAA,MAAM,EAAE,aAArE;AAAoFC,IAAAA,UAAU,EAAE;AAAEG,MAAAA,OAAO,EAAE,KAAX;AAAkBC,MAAAA,OAAO,EAAE;AAA3B,KAAhG;AAAoIP,IAAAA,OAAO,EAAE;AAA7I,GA9GkB,EA+GlB;AACA;AAAEH,IAAAA,IAAI,EAAE,OAAR;AAAiBC,IAAAA,IAAI,EAAE,MAAvB;AAA+BE,IAAAA,OAAO,EAAE;AAAxC,GAhHkB,EAiHlB;AACA;AAAEH,IAAAA,IAAI,EAAE,OAAR;AAAiBC,IAAAA,IAAI,EAAE,QAAvB;AAAiCG,IAAAA,MAAM,EAAE,cAAzC;AAAyDa,IAAAA,UAAU,EAAE;AAAER,MAAAA,OAAO,EAAE;AAAX;AAArE,GAlHkB,EAmHlB;AAAET,IAAAA,IAAI,EAAE,OAAR;AAAiBC,IAAAA,IAAI,EAAE,QAAvB;AAAiCG,IAAAA,MAAM,EAAE,cAAzC;AAAyDa,IAAAA,UAAU,EAAE;AAAER,MAAAA,OAAO,EAAE;AAAX;AAArE,GAnHkB,EAoHlB;AAAET,IAAAA,IAAI,EAAE,OAAR;AAAiBC,IAAAA,IAAI,EAAE,QAAvB;AAAiCG,IAAAA,MAAM,EAAE,QAAzC;AAAmDa,IAAAA,UAAU,EAAE;AAAER,MAAAA,OAAO,EAAE,IAAX;AAAiBF,MAAAA,QAAQ,EAAE;AAA3B;AAA/D,GApHkB,EAqHlB;AAAEP,IAAAA,IAAI,EAAE,OAAR;AAAiBC,IAAAA,IAAI,EAAE,QAAvB;AAAiCG,IAAAA,MAAM,EAAE,QAAzC;AAAmDa,IAAAA,UAAU,EAAE;AAAER,MAAAA,OAAO,EAAE,KAAX;AAAkBF,MAAAA,QAAQ,EAAE;AAA5B;AAA/D,GArHkB,EAsHlB;AAAEP,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BG,IAAAA,MAAM,EAAE,iBAArC;AAAwDY,IAAAA,MAAM,EAAE,IAAhE;AAAsEC,IAAAA,UAAU,EAAE;AAAEW,MAAAA,QAAQ,EAAE;AAAZ,KAAlF;AAA6GzB,IAAAA,OAAO,EAAE;AAAtH,GAtHkB,EAuHlB;AAAEH,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BG,IAAAA,MAAM,EAAE,iBAArC;AAAwDY,IAAAA,MAAM,EAAE,IAAhE;AAAsEC,IAAAA,UAAU,EAAE;AAAEW,MAAAA,QAAQ,EAAE;AAAZ,KAAlF;AAAuGzB,IAAAA,OAAO,EAAE;AAAhH,GAvHkB,EAwHlB;AAAEH,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BG,IAAAA,MAAM,EAAE,iBAArC;AAAwDY,IAAAA,MAAM,EAAE,IAAhE;AAAsEC,IAAAA,UAAU,EAAE;AAAEW,MAAAA,QAAQ,EAAE;AAAZ,KAAlF;AAAqHzB,IAAAA,OAAO,EAAE;AAA9H,GAxHkB,EAyHlB;AAAEH,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BG,IAAAA,MAAM,EAAE,iBAArC;AAAwDY,IAAAA,MAAM,EAAE,IAAhE;AAAsEC,IAAAA,UAAU,EAAE;AAAEW,MAAAA,QAAQ,EAAE;AAAZ,KAAlF;AAA2GzB,IAAAA,OAAO,EAAE;AAApH,GAzHkB,EA0HlB;AAAEH,IAAAA,IAAI,EAAE,IAAR;AAAcC,IAAAA,IAAI,EAAE,QAApB;AAA8BG,IAAAA,MAAM,EAAE,iBAAtC;AAAyDY,IAAAA,MAAM,EAAE,IAAjE;AAAuEC,IAAAA,UAAU,EAAE;AAAEW,MAAAA,QAAQ,EAAE;AAAZ,KAAnF;AAA6GzB,IAAAA,OAAO,EAAE;AAAtH,GA1HkB,EA2HlB;AAAEH,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BG,IAAAA,MAAM,EAAE,iBAArC;AAAwDY,IAAAA,MAAM,EAAE,IAAhE;AAAsEC,IAAAA,UAAU,EAAE;AAAEW,MAAAA,QAAQ,EAAE;AAAZ,KAAlF;AAAgHzB,IAAAA,OAAO,EAAE;AAAzH,GA3HkB,EA4HlB;AAAEH,IAAAA,IAAI,EAAE,IAAR;AAAcC,IAAAA,IAAI,EAAE,QAApB;AAA8BG,IAAAA,MAAM,EAAE,iBAAtC;AAAyDY,IAAAA,MAAM,EAAE,IAAjE;AAAuEC,IAAAA,UAAU,EAAE;AAAEW,MAAAA,QAAQ,EAAE;AAAZ,KAAnF;AAAuGzB,IAAAA,OAAO,EAAE;AAAhH,GA5HkB,EA6HlB;AAAEH,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BG,IAAAA,MAAM,EAAE,iBAArC;AAAwDY,IAAAA,MAAM,EAAE,IAAhE;AAAsEC,IAAAA,UAAU,EAAE;AAAEW,MAAAA,QAAQ,EAAE;AAAZ,KAAlF;AAAuHzB,IAAAA,OAAO,EAAE;AAAhI,GA7HkB,EA8HlB;AAAEH,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BG,IAAAA,MAAM,EAAE,2BAArC;AAAkEY,IAAAA,MAAM,EAAE,IAA1E;AAAgFa,IAAAA,qBAAqB,EAAE,IAAvG;AAA6GZ,IAAAA,UAAU,EAAE;AAAEC,MAAAA,KAAK,EAAE;AAAT,KAAzH;AAA0If,IAAAA,OAAO,EAAE;AAAnJ,GA9HkB,EA+HlB;AAAEH,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BG,IAAAA,MAAM,EAAE,2BAArC;AAAkEY,IAAAA,MAAM,EAAE,IAA1E;AAAgFa,IAAAA,qBAAqB,EAAE,IAAvG;AAA6GZ,IAAAA,UAAU,EAAE;AAAEC,MAAAA,KAAK,EAAE;AAAT,KAAzH;AAA2If,IAAAA,OAAO,EAAE;AAApJ,GA/HkB,EAgIlB;AAAEH,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BG,IAAAA,MAAM,EAAE;AAArC,GAhIkB,EAiIlB;AAAEJ,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BG,IAAAA,MAAM,EAAE,kBAArC;AAAyDa,IAAAA,UAAU,EAAE;AAAEV,MAAAA,QAAQ,EAAE;AAAZ;AAArE,GAjIkB,EAkIlB;AAAEP,IAAAA,IAAI,EAAE,OAAR;AAAiBC,IAAAA,IAAI,EAAE,QAAvB;AAAiCG,IAAAA,MAAM,EAAE,kBAAzC;AAA6Da,IAAAA,UAAU,EAAE;AAAEa,MAAAA,SAAS,EAAE;AAAb;AAAzE,GAlIkB,EAmIlB;AAAE9B,IAAAA,IAAI,EAAE,OAAR;AAAiBC,IAAAA,IAAI,EAAE,QAAvB;AAAiCG,IAAAA,MAAM,EAAE,kBAAzC;AAA6Da,IAAAA,UAAU,EAAE;AAAEa,MAAAA,SAAS,EAAE;AAAb;AAAzE,GAnIkB,EAoIlB;AAAE9B,IAAAA,IAAI,EAAE,IAAR;AAAcC,IAAAA,IAAI,EAAE,QAApB;AAA8BG,IAAAA,MAAM,EAAE;AAAtC,GApIkB,EAqIlB;AAAEJ,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BG,IAAAA,MAAM,EAAE,WAArC;AAAkDY,IAAAA,MAAM,EAAE;AAA1D,GArIkB,EAsIlB;AAAEhB,IAAAA,IAAI,EAAE,IAAR;AAAcC,IAAAA,IAAI,EAAE,QAApB;AAA8BG,IAAAA,MAAM,EAAE,WAAtC;AAAmDa,IAAAA,UAAU,EAAE;AAAEc,MAAAA,UAAU,EAAE;AAAd,KAA/D;AAAqFf,IAAAA,MAAM,EAAE;AAA7F,GAtIkB,EAuIlB;AAAEhB,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BG,IAAAA,MAAM,EAAE,OAArC;AAA8CY,IAAAA,MAAM,EAAE,IAAtD;AAA4DC,IAAAA,UAAU,EAAE;AAAEC,MAAAA,KAAK,EAAE,IAAT;AAAeF,MAAAA,MAAM,EAAE;AAAvB;AAAxE,GAvIkB,EAwIlB;AAAEhB,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BG,IAAAA,MAAM,EAAE,OAArC;AAA8CY,IAAAA,MAAM,EAAE,IAAtD;AAA4DC,IAAAA,UAAU,EAAE;AAAEC,MAAAA,KAAK,EAAE,KAAT;AAAgBF,MAAAA,MAAM,EAAE;AAAxB;AAAxE,GAxIkB,EAyIlB;AAAEhB,IAAAA,IAAI,EAAE,cAAR;AAAwBC,IAAAA,IAAI,EAAE,QAA9B;AAAwCG,IAAAA,MAAM,EAAE,SAAhD;AAA2DY,IAAAA,MAAM,EAAE;AAAnE,GAzIkB,EA0IlB;AAAEhB,IAAAA,IAAI,EAAE,cAAR;AAAwBC,IAAAA,IAAI,EAAE,QAA9B;AAAwCG,IAAAA,MAAM,EAAE;AAAhD,GA1IkB,EA2IlB;AAAEJ,IAAAA,IAAI,EAAE,cAAR;AAAwBC,IAAAA,IAAI,EAAE,QAA9B;AAAwCG,IAAAA,MAAM,EAAE;AAAhD,GA3IkB,EA4IlB;AACA;AAAEJ,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BG,IAAAA,MAAM,EAAE,iBAArC;AAAwDY,IAAAA,MAAM,EAAE,IAAhE;AAAsEC,IAAAA,UAAU,EAAE;AAAEe,MAAAA,OAAO,EAAE;AAAX,KAAlF;AAAqG7B,IAAAA,OAAO,EAAE;AAA9G,GA7IkB,EA8IlB;AAAEH,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,UAAnB;AAA+BoB,IAAAA,QAAQ,EAAE,QAAzC;AAAmDC,IAAAA,YAAY,EAAE;AAAEf,MAAAA,QAAQ,EAAE,IAAZ;AAAkB0B,MAAAA,QAAQ,EAAE;AAA5B,KAAjE;AAAqG9B,IAAAA,OAAO,EAAE,QAA9G;AAAwH+B,IAAAA,eAAe,EAAE;AAAzI,GA9IkB,EA+IlB;AAAElC,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BG,IAAAA,MAAM,EAAE,MAArC;AAA6CD,IAAAA,OAAO,EAAE;AAAtD,GA/IkB,EAgJlB;AAAEH,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,UAAnB;AAA+BoB,IAAAA,QAAQ,EAAE,YAAzC;AAAuDC,IAAAA,YAAY,EAAE;AAACE,MAAAA,OAAO,EAAE;AAAV,KAArE;AAAsFrB,IAAAA,OAAO,EAAE,QAA/F;AAAyGa,IAAAA,MAAM,EAAE;AAAjH,GAhJkB,EAiJlB;AAAEhB,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,UAAnB;AAA+BoB,IAAAA,QAAQ,EAAE,YAAzC;AAAuDC,IAAAA,YAAY,EAAE;AAACE,MAAAA,OAAO,EAAE;AAAV,KAArE;AAAuFrB,IAAAA,OAAO,EAAE,QAAhG;AAA0Ga,IAAAA,MAAM,EAAE;AAAlH,GAjJkB,EAkJlB;AAAEhB,IAAAA,IAAI,EAAE,OAAR;AAAiBC,IAAAA,IAAI,EAAE,QAAvB;AAAiCG,IAAAA,MAAM,EAAE;AAAzC,GAlJkB,EAmJlB;AAAEJ,IAAAA,IAAI,EAAE,cAAR;AAAwBC,IAAAA,IAAI,EAAE,QAA9B;AAAwCG,IAAAA,MAAM,EAAE;AAAhD,GAnJkB,EAoJlB;AAAEJ,IAAAA,IAAI,EAAE,cAAR;AAAwBC,IAAAA,IAAI,EAAE,QAA9B;AAAwCG,IAAAA,MAAM,EAAE;AAAhD,GApJkB,EAqJlB;AAAEJ,IAAAA,IAAI,EAAE,IAAR;AAAcC,IAAAA,IAAI,EAAE,QAApB;AAA8BG,IAAAA,MAAM,EAAE,gBAAtC;AAAwDa,IAAAA,UAAU,EAAE;AAAEkB,MAAAA,QAAQ,EAAE;AAAZ;AAApE,GArJkB,EAsJlB;AAAEnC,IAAAA,IAAI,EAAE,IAAR;AAAcC,IAAAA,IAAI,EAAE,QAApB;AAA8BG,IAAAA,MAAM,EAAE,gBAAtC;AAAwDa,IAAAA,UAAU,EAAE;AAAEkB,MAAAA,QAAQ,EAAE;AAAZ,KAApE;AAA4F9B,IAAAA,MAAM,EAAE;AAApG,GAtJkB,EAuJlB;AAAEL,IAAAA,IAAI,EAAE,IAAR;AAAcC,IAAAA,IAAI,EAAE,QAApB;AAA8BG,IAAAA,MAAM,EAAE,gBAAtC;AAAwDa,IAAAA,UAAU,EAAE;AAAEkB,MAAAA,QAAQ,EAAE;AAAZ;AAApE,GAvJkB,EAwJlB;AAAEnC,IAAAA,IAAI,EAAE,OAAR;AAAiBC,IAAAA,IAAI,EAAE,QAAvB;AAAiCG,IAAAA,MAAM,EAAE,gBAAzC;AAA2Da,IAAAA,UAAU,EAAE;AAAEkB,MAAAA,QAAQ,EAAE;AAAZ,KAAvE;AAA4F9B,IAAAA,MAAM,EAAE;AAApG,GAxJkB,EAyJlB;AAAEL,IAAAA,IAAI,EAAE,IAAR;AAAcC,IAAAA,IAAI,EAAE,QAApB;AAA8BG,IAAAA,MAAM,EAAE,gBAAtC;AAAwDa,IAAAA,UAAU,EAAE;AAAEkB,MAAAA,QAAQ,EAAE;AAAZ;AAApE,GAzJkB,EA0JlB;AAAEnC,IAAAA,IAAI,EAAE,IAAR;AAAcC,IAAAA,IAAI,EAAE,QAApB;AAA8BG,IAAAA,MAAM,EAAE,gBAAtC;AAAwDa,IAAAA,UAAU,EAAE;AAAEkB,MAAAA,QAAQ,EAAE;AAAZ,KAApE;AAA4F9B,IAAAA,MAAM,EAAE;AAApG,GA1JkB,EA2JlB;AAAEL,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BG,IAAAA,MAAM,EAAE;AAArC,GA3JkB,EA4JlB;AAAEJ,IAAAA,IAAI,EAAE,OAAR;AAAiBC,IAAAA,IAAI,EAAE,QAAvB;AAAiCG,IAAAA,MAAM,EAAE,sBAAzC;AAAiEY,IAAAA,MAAM,EAAE,IAAzE;AAA+EC,IAAAA,UAAU,EAAE;AAACmB,MAAAA,QAAQ,EAAE,IAAX;AAAiBC,MAAAA,SAAS,EAAE;AAA5B;AAA3F,GA5JkB,EA6JlB;AAAErC,IAAAA,IAAI,EAAE,OAAR;AAAiBC,IAAAA,IAAI,EAAE,QAAvB;AAAiCG,IAAAA,MAAM,EAAE,sBAAzC;AAAiEY,IAAAA,MAAM,EAAE,IAAzE;AAA+EC,IAAAA,UAAU,EAAE;AAACmB,MAAAA,QAAQ,EAAE,KAAX;AAAkBC,MAAAA,SAAS,EAAE;AAA7B;AAA3F,GA7JkB,EA8JlB;AAAErC,IAAAA,IAAI,EAAE,OAAR;AAAiBC,IAAAA,IAAI,EAAE,QAAvB;AAAiCG,IAAAA,MAAM,EAAE,QAAzC;AAAmDa,IAAAA,UAAU,EAAE;AAAEM,MAAAA,WAAW,EAAE;AAAf,KAA/D;AAAsFpB,IAAAA,OAAO,EAAE;AAA/F,GA9JkB,EA+JlB;AAAEH,IAAAA,IAAI,EAAE,OAAR;AAAiBC,IAAAA,IAAI,EAAE,QAAvB;AAAiCG,IAAAA,MAAM,EAAE,QAAzC;AAAmDa,IAAAA,UAAU,EAAE;AAAEM,MAAAA,WAAW,EAAE;AAAf,KAA/D;AAAuFpB,IAAAA,OAAO,EAAE;AAAhG,GA/JkB,EAgKlB;AACA;AAAEH,IAAAA,IAAI,EAAE,cAAR;AAAwBC,IAAAA,IAAI,EAAE,QAA9B;AAAwCI,IAAAA,MAAM,EAAE;AAAhD,GAjKkB,EAkKlB;AAAEL,IAAAA,IAAI,EAAE,cAAR;AAAwBC,IAAAA,IAAI,EAAE,QAA9B;AAAwCI,IAAAA,MAAM,EAAE,wBAAhD;AAA0EC,IAAAA,UAAU,EAAE;AAAEgC,MAAAA,eAAe,EAAE;AAAnB;AAAtF,GAlKkB,EAmKlB;AACA;AAAEtC,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BsC,IAAAA,UAAU,EAAE;AAAE9B,MAAAA,OAAO,EAAE,IAAX;AAAiB+B,MAAAA,QAAQ,EAAE,QAA3B;AAAqChC,MAAAA,UAAU,EAAE;AAAjD;AAAzC,GApKkB,EAqKlB;AAAER,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BsC,IAAAA,UAAU,EAAE;AAAE9B,MAAAA,OAAO,EAAE,KAAX;AAAkB+B,MAAAA,QAAQ,EAAE,QAA5B;AAAsChC,MAAAA,UAAU,EAAE;AAAlD;AAAzC,GArKkB,EAsKlB;AAAER,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BsC,IAAAA,UAAU,EAAE;AAAE9B,MAAAA,OAAO,EAAE,IAAX;AAAiB+B,MAAAA,QAAQ,EAAE,iBAA3B;AAA8CC,MAAAA,aAAa,EAAE,IAA7D;AAAmEjC,MAAAA,UAAU,EAAE;AAA/E;AAAzC,GAtKkB,EAuKlB;AAAER,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE,QAAnB;AAA6BsC,IAAAA,UAAU,EAAE;AAAE9B,MAAAA,OAAO,EAAE,KAAX;AAAkB+B,MAAAA,QAAQ,EAAE,iBAA5B;AAA+CC,MAAAA,aAAa,EAAE,IAA9D;AAAoEjC,MAAAA,UAAU,EAAE;AAAhF;AAAzC,GAvKkB,EAwKlB;AAAER,IAAAA,IAAI,EAAE,IAAR;AAAcC,IAAAA,IAAI,EAAE,QAApB;AAA8BsC,IAAAA,UAAU,EAAE;AAAE9B,MAAAA,OAAO,EAAE,IAAX;AAAiB+B,MAAAA,QAAQ,EAAE,iBAA3B;AAA8ChC,MAAAA,UAAU,EAAE;AAA1D;AAA1C,GAxKkB,EAyKlB;AAAER,IAAAA,IAAI,EAAE,IAAR;AAAcC,IAAAA,IAAI,EAAE,QAApB;AAA8BsC,IAAAA,UAAU,EAAE;AAAE9B,MAAAA,OAAO,EAAE,KAAX;AAAkB+B,MAAAA,QAAQ,EAAE,iBAA5B;AAA+ChC,MAAAA,UAAU,EAAE;AAA3D;AAA1C,GAzKkB,EA0KlB;AACA;AAAER,IAAAA,IAAI,EAAE,GAAR;AAAaC,IAAAA,IAAI,EAAE;AAAnB,GA3KkB,CAApB;AA6KA,MAAIyC,mBAAmB,GAAG3C,aAAa,CAAC4C,MAAxC;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,MAAIC,mBAAmB,GAAG,CACxB;AAAEC,IAAAA,IAAI,EAAE,aAAR;AAAuBC,IAAAA,SAAS,EAAE;AAAlC,GADwB,EAExB;AAAED,IAAAA,IAAI,EAAE;AAAR,GAFwB,EAGxB;AAAEA,IAAAA,IAAI,EAAE,MAAR;AAAgBC,IAAAA,SAAS,EAAE;AAA3B,GAHwB,EAIxB;AAAED,IAAAA,IAAI,EAAE,MAAR;AAAgBC,IAAAA,SAAS,EAAE;AAA3B,GAJwB,EAKxB;AAAED,IAAAA,IAAI,EAAE,MAAR;AAAgBC,IAAAA,SAAS,EAAE;AAA3B,GALwB,EAMxB;AAAED,IAAAA,IAAI,EAAE;AAAR,GANwB,EAOxB;AAAEA,IAAAA,IAAI,EAAE,OAAR;AAAiBC,IAAAA,SAAS,EAAE;AAA5B,GAPwB,EAQxB;AAAED,IAAAA,IAAI,EAAE,MAAR;AAAgBC,IAAAA,SAAS,EAAE;AAA3B,GARwB,EASxB;AAAED,IAAAA,IAAI,EAAE,MAAR;AAAgBC,IAAAA,SAAS,EAAE;AAA3B,GATwB,EAUxB;AAAED,IAAAA,IAAI,EAAE,KAAR;AAAeC,IAAAA,SAAS,EAAE;AAA1B,GAVwB,EAWxB;AAAED,IAAAA,IAAI,EAAE,UAAR;AAAoBC,IAAAA,SAAS,EAAE;AAA/B,GAXwB,EAYxB;AAAED,IAAAA,IAAI,EAAE,WAAR;AAAqBC,IAAAA,SAAS,EAAE;AAAhC,GAZwB,EAaxB;AAAED,IAAAA,IAAI,EAAE,MAAR;AAAgBC,IAAAA,SAAS,EAAE;AAA3B,GAbwB,EAcxB;AAAED,IAAAA,IAAI,EAAE,YAAR;AAAsBC,IAAAA,SAAS,EAAE,GAAjC;AAAsCC,IAAAA,aAAa,EAAE;AAArD,GAdwB,EAexB;AAAEF,IAAAA,IAAI,EAAE,YAAR;AAAsBC,IAAAA,SAAS,EAAE;AAAjC,GAfwB,EAgBxB;AAAED,IAAAA,IAAI,EAAE,MAAR;AAAgBC,IAAAA,SAAS,EAAE;AAA3B,GAhBwB,EAiBxB;AAAED,IAAAA,IAAI,EAAE,UAAR;AAAoBC,IAAAA,SAAS,EAAE;AAA/B,GAjBwB,EAkBxB;AAAED,IAAAA,IAAI,EAAE,WAAR;AAAqBC,IAAAA,SAAS,EAAE,KAAhC;AAAuCE,IAAAA,yBAAyB,EAAE;AAAlE,GAlBwB,EAmBxB;AAAEH,IAAAA,IAAI,EAAE,SAAR;AAAmBC,IAAAA,SAAS,EAAE;AAA9B,GAnBwB,EAoBxB;AAAED,IAAAA,IAAI,EAAE,QAAR;AAAkBC,IAAAA,SAAS,EAAE;AAA7B,GApBwB,CAA1B;AAuBA,MAAIG,GAAG,GAAGnD,UAAU,CAACmD,GAArB;;AAEA,MAAIC,GAAG,GAAG,YAAW;AACnB,aAASC,YAAT,CAAsBC,EAAtB,EAA0B;AACxBA,MAAAA,EAAE,CAACC,SAAH,CAAa,cAAb,EAA6B,IAA7B;AACAD,MAAAA,EAAE,CAACC,SAAH,CAAa,yBAAb,EAAwC,KAAxC;AACAvD,MAAAA,UAAU,CAACwD,MAAX,CAAkBF,EAAlB,EAAsB,iBAAtB,EAAyC;AAACG,QAAAA,IAAI,EAAE;AAAP,OAAzC;AACAH,MAAAA,EAAE,CAACI,EAAH,CAAM,gBAAN,EAAwBC,gBAAxB;AACAC,MAAAA,iBAAiB,CAACN,EAAD,CAAjB;AACAtD,MAAAA,UAAU,CAAC0D,EAAX,CAAcJ,EAAE,CAACO,aAAH,EAAd,EAAkC,OAAlC,EAA2CC,YAAY,CAACR,EAAD,CAAvD;AACD;;AAED,aAASS,YAAT,CAAsBT,EAAtB,EAA0B;AACxBA,MAAAA,EAAE,CAACC,SAAH,CAAa,cAAb,EAA6B,KAA7B;AACAD,MAAAA,EAAE,CAACU,GAAH,CAAO,gBAAP,EAAyBL,gBAAzB;AACA3D,MAAAA,UAAU,CAACgE,GAAX,CAAeV,EAAE,CAACO,aAAH,EAAf,EAAmC,OAAnC,EAA4CC,YAAY,CAACR,EAAD,CAAxD;AACAA,MAAAA,EAAE,CAACW,KAAH,CAASC,GAAT,GAAe,IAAf;AACD;;AAED,aAASC,YAAT,CAAsBb,EAAtB,EAA0Bc,IAA1B,EAAgC;AAC9B,UAAI,QAAQpE,UAAU,CAACqE,MAAX,CAAkBH,GAA9B,EAAmC;AACjClE,QAAAA,UAAU,CAACsE,OAAX,CAAmBhB,EAAE,CAACiB,iBAAH,EAAnB,EAA2C,eAA3C;;AACA,YAAIjB,EAAE,CAACkB,SAAH,CAAa,YAAb,KAA8B,iBAA9B,IAAmDC,QAAQ,CAACC,IAAT,CAAcC,KAAd,CAAoBC,UAApB,IAAkC,IAAzF,EAA+F;AAC7FC,UAAAA,oBAAoB,CAACvB,EAAD,CAApB;AACAA,UAAAA,EAAE,CAACO,aAAH,GAAmBc,KAAnB,CAAyBC,UAAzB,GAAsC,EAAtC;AACD;AACF;;AAED,UAAI,CAACR,IAAD,IAASA,IAAI,CAACU,MAAL,IAAeC,YAA5B,EACEhB,YAAY,CAACT,EAAD,CAAZ;AACH;;AACD,aAASyB,YAAT,CAAsBzB,EAAtB,EAA0B0B,IAA1B,EAAgC;AAC9B,UAAI,QAAQhF,UAAU,CAACqE,MAAX,CAAkBH,GAA9B,EAAmC;AACjClE,QAAAA,UAAU,CAACiF,QAAX,CAAoB3B,EAAE,CAACiB,iBAAH,EAApB,EAA4C,eAA5C;;AACA,YAAIjB,EAAE,CAACkB,SAAH,CAAa,YAAb,KAA8B,iBAA9B,IAAmDC,QAAQ,CAACC,IAAT,CAAcC,KAAd,CAAoBC,UAApB,IAAkC,IAAzF,EAA+F;AAC7FM,UAAAA,mBAAmB,CAAC5B,EAAD,CAAnB;AACAA,UAAAA,EAAE,CAACO,aAAH,GAAmBc,KAAnB,CAAyBC,UAAzB,GAAsC,aAAtC;AACD;AACF;;AAED,UAAI,CAACI,IAAD,IAASA,IAAI,CAACF,MAAL,IAAeC,YAA5B,EACE1B,YAAY,CAACC,EAAD,CAAZ;AACH;;AAED,aAAS6B,mBAAT,CAA6B7B,EAA7B,EAAiC;AAC/B,UAAI,CAACA,EAAE,CAACW,KAAH,CAASmB,cAAd,EAA8B;AAC9BC,MAAAA,kBAAkB,CAAC/B,EAAD,CAAlB;AACA,UAAIgC,MAAM,GAAGhC,EAAE,CAACiC,cAAH,EAAb;AAAA,UAAkCC,MAAM,GAAG,EAA3C;;AACA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,MAAM,CAACzC,MAA3B,EAAmC4C,CAAC,EAApC,EAAwC;AACtC,YAAIC,KAAK,GAAGJ,MAAM,CAACG,CAAD,CAAlB;;AACA,YAAIC,KAAK,CAACC,KAAN,EAAJ,EAAmB;AACjB,cAAIC,UAAU,GAAGtC,EAAE,CAACuC,OAAH,CAAWH,KAAK,CAACI,MAAN,CAAaC,IAAxB,EAA8BlD,MAA/C;;AACA,cAAI6C,KAAK,CAACI,MAAN,CAAaE,EAAb,GAAkBJ,UAAtB,EAAkC;AAChCJ,YAAAA,MAAM,CAACS,IAAP,CAAY3C,EAAE,CAAC4C,QAAH,CAAYR,KAAK,CAACI,MAAlB,EAA0B3C,GAAG,CAACuC,KAAK,CAACI,MAAN,CAAaC,IAAd,EAAoBL,KAAK,CAACI,MAAN,CAAaE,EAAb,GAAkB,CAAtC,CAA7B,EACY;AAACG,cAAAA,SAAS,EAAE;AAAZ,aADZ,CAAZ;AAED,WAHD,MAGO;AACLX,YAAAA,MAAM,CAACS,IAAP,CAAY3C,EAAE,CAAC4C,QAAH,CAAY/C,GAAG,CAACuC,KAAK,CAACI,MAAN,CAAaC,IAAd,EAAoBH,UAAU,GAAG,CAAjC,CAAf,EACYzC,GAAG,CAACuC,KAAK,CAACI,MAAN,CAAaC,IAAd,EAAoBH,UAApB,CADf,EAEY;AAACO,cAAAA,SAAS,EAAE;AAAZ,aAFZ,CAAZ;AAGD;AACF;AACF;;AACD7C,MAAAA,EAAE,CAACW,KAAH,CAASmB,cAAT,GAA0BI,MAA1B;AACD;;AAED,aAASH,kBAAT,CAA4B/B,EAA5B,EAAgC;AAC9B,UAAI8C,KAAK,GAAG9C,EAAE,CAACW,KAAH,CAASmB,cAArB;AACA,UAAIgB,KAAJ,EAAW,KAAK,IAAIX,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGW,KAAK,CAACvD,MAA1B,EAAkC4C,CAAC,EAAnC,EAAuCW,KAAK,CAACX,CAAD,CAAL,CAASY,KAAT;AACnD;;AAED,aAASnB,mBAAT,CAA6B5B,EAA7B,EAAiC;AAC/BA,MAAAA,EAAE,CAACW,KAAH,CAASmB,cAAT,GAA0B,EAA1B;AACAD,MAAAA,mBAAmB,CAAC7B,EAAD,CAAnB;AACAA,MAAAA,EAAE,CAACI,EAAH,CAAM,gBAAN,EAAwByB,mBAAxB;AACD;;AAED,aAASN,oBAAT,CAA8BvB,EAA9B,EAAkC;AAChC+B,MAAAA,kBAAkB,CAAC/B,EAAD,CAAlB;AACAA,MAAAA,EAAE,CAACU,GAAH,CAAO,gBAAP,EAAyBmB,mBAAzB,EAFgC,CAGhC;AACA;;AACA7B,MAAAA,EAAE,CAACW,KAAH,CAASmB,cAAT,GAA0B,IAA1B;AACD,KAhFkB,CAkFnB;;;AACApF,IAAAA,UAAU,CAACsG,YAAX,CAAwB,SAAxB,EAAmC,KAAnC,EAA0C,UAAShD,EAAT,EAAaiD,GAAb,EAAkBvB,IAAlB,EAAwB;AAChE,UAAIuB,GAAG,IAAIjD,EAAE,CAACkB,SAAH,CAAa,QAAb,KAA0B,KAArC,EACElB,EAAE,CAACC,SAAH,CAAa,QAAb,EAAuB,KAAvB,EADF,KAEK,IAAI,CAACgD,GAAD,IAAQvB,IAAI,IAAIhF,UAAU,CAACwG,IAA3B,IAAmC,OAAOC,IAAP,CAAYnD,EAAE,CAACkB,SAAH,CAAa,QAAb,CAAZ,CAAvC,EACHlB,EAAE,CAACC,SAAH,CAAa,QAAb,EAAuB,SAAvB;AACH,KALD;;AAOA,aAASmD,KAAT,CAAeC,GAAf,EAAoBrD,EAApB,EAAwB;AACtB,UAAI,CAACA,EAAL,EAAS;AAAE,eAAOsD,SAAP;AAAmB;;AAC9B,UAAI,KAAKD,GAAL,CAAJ,EAAe;AAAE,eAAO,KAAKA,GAAL,CAAP;AAAmB;;AACpC,UAAIE,MAAM,GAAGC,aAAa,CAACH,GAAD,CAA1B;;AACA,UAAI,CAACE,MAAL,EAAa;AACX,eAAO,KAAP;AACD;;AACD,UAAIE,GAAG,GAAG/G,UAAU,CAACoD,GAAX,CAAe4D,OAAf,CAAuB1D,EAAvB,EAA2BuD,MAA3B,CAAV;;AACA,UAAI,OAAOE,GAAP,IAAc,UAAlB,EAA8B;AAC5B/G,QAAAA,UAAU,CAACwD,MAAX,CAAkBF,EAAlB,EAAsB,cAAtB,EAAsCuD,MAAtC;AACD;;AACD,aAAOE,GAAP;AACD;;AAED,QAAIE,SAAS,GAAG;AAACC,MAAAA,KAAK,EAAC,GAAP;AAAWC,MAAAA,IAAI,EAAC,GAAhB;AAAoBC,MAAAA,GAAG,EAAC,GAAxB;AAA4BC,MAAAA,GAAG,EAAC,GAAhC;AAAoCC,MAAAA,GAAG,EAAC,GAAxC;AAA4CC,MAAAA,QAAQ,EAAC;AAArD,KAAhB;AACA,QAAIC,WAAW,GAAG;AAACC,MAAAA,KAAK,EAAC,IAAP;AAAYC,MAAAA,SAAS,EAAC,IAAtB;AAA2BC,MAAAA,MAAM,EAAC,KAAlC;AAAwCC,MAAAA,MAAM,EAAC;AAA/C,KAAlB;;AACA,aAASd,aAAT,CAAuBH,GAAvB,EAA4B;AAC1B,UAAIA,GAAG,CAACkB,MAAJ,CAAW,CAAX,KAAiB,IAArB,EAA2B;AACzB;AACA,eAAOlB,GAAG,CAACkB,MAAJ,CAAW,CAAX,CAAP;AACD;;AACD,UAAIC,MAAM,GAAGnB,GAAG,CAACoB,KAAJ,CAAU,QAAV,CAAb;AACA,UAAIC,SAAS,GAAGF,MAAM,CAACA,MAAM,CAACjF,MAAP,GAAgB,CAAjB,CAAtB;;AACA,UAAIiF,MAAM,CAACjF,MAAP,IAAiB,CAAjB,IAAsBiF,MAAM,CAAC,CAAD,CAAN,CAAUjF,MAAV,IAAoB,CAA9C,EAAiD;AAC/C;AACA,eAAO,KAAP;AACD,OAHD,MAGO,IAAIiF,MAAM,CAACjF,MAAP,IAAiB,CAAjB,IAAsBiF,MAAM,CAAC,CAAD,CAAN,IAAa,OAAnC,IAA8CE,SAAS,CAACnF,MAAV,IAAoB,CAAtE,EAAyE;AAC9E;AACA,eAAO,KAAP;AACD;;AACD,UAAIoF,YAAY,GAAG,KAAnB;;AACA,WAAK,IAAIxC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqC,MAAM,CAACjF,MAA3B,EAAmC4C,CAAC,EAApC,EAAwC;AACtC,YAAIyC,KAAK,GAAGJ,MAAM,CAACrC,CAAD,CAAlB;;AACA,YAAIyC,KAAK,IAAIjB,SAAb,EAAwB;AAAEa,UAAAA,MAAM,CAACrC,CAAD,CAAN,GAAYwB,SAAS,CAACiB,KAAD,CAArB;AAA+B,SAAzD,MACK;AAAED,UAAAA,YAAY,GAAG,IAAf;AAAsB;;AAC7B,YAAIC,KAAK,IAAIV,WAAb,EAA0B;AAAEM,UAAAA,MAAM,CAACrC,CAAD,CAAN,GAAY+B,WAAW,CAACU,KAAD,CAAvB;AAAiC;AAC9D;;AACD,UAAI,CAACD,YAAL,EAAmB;AACjB;AACA,eAAO,KAAP;AACD,OAxByB,CAyB1B;AACA;;;AACA,UAAIE,WAAW,CAACH,SAAD,CAAf,EAA4B;AAC1BF,QAAAA,MAAM,CAACA,MAAM,CAACjF,MAAP,GAAgB,CAAjB,CAAN,GAA4BmF,SAAS,CAACI,WAAV,EAA5B;AACD;;AACD,aAAO,MAAMN,MAAM,CAACO,IAAP,CAAY,GAAZ,CAAN,GAAyB,GAAhC;AACD;;AAED,aAASvE,YAAT,CAAsBR,EAAtB,EAA0B;AACxB,UAAIY,GAAG,GAAGZ,EAAE,CAACW,KAAH,CAASC,GAAnB;;AACA,UAAI,CAACA,GAAG,CAACoE,SAAT,EAAoB;AAClBpE,QAAAA,GAAG,CAACoE,SAAJ,GAAgB,YAAW;AACzB,cAAI,CAACpE,GAAG,CAACqE,UAAT,EAAqB;AACnBjF,YAAAA,EAAE,CAACkF,SAAH,CAAaC,YAAY,CAACnF,EAAE,CAACoF,SAAH,EAAD,EAAiB,CAAjB,EAAoB,CAApB,CAAzB;AACAC,YAAAA,OAAO,CAACC,eAAR,CAAwBtF,EAAxB,EAA4B,EAA5B,EAAgCY,GAAhC;AACD;AACF,SALD;AAMD;;AACD,aAAOA,GAAG,CAACoE,SAAX;AACD;;AAED,QAAIO,WAAW,GAAG,MAAlB;AACA,QAAIC,YAAY,GAAG,CAAC9I,UAAU,CAAC+I,UAAZ,EAAwB,UAAS/C,EAAT,EAAa;AACtD,aAAOA,EAAE,IAAI,CAAChG,UAAU,CAAC+I,UAAX,CAAsB/C,EAAtB,CAAP,IAAoC,CAAC,KAAKS,IAAL,CAAUT,EAAV,CAA5C;AACD,KAFkB,CAAnB;AAAA,QAEIgD,eAAe,GAAG,CAAC,UAAShD,EAAT,EAAa;AAClC,aAAO,KAAKS,IAAL,CAAUT,EAAV,CAAP;AACD,KAFqB,CAFtB;;AAKA,aAASiD,YAAT,CAAsBC,KAAtB,EAA6BC,IAA7B,EAAmC;AACjC,UAAIjJ,IAAI,GAAG,EAAX;;AACA,WAAK,IAAIuF,CAAC,GAAGyD,KAAb,EAAoBzD,CAAC,GAAGyD,KAAK,GAAGC,IAAhC,EAAsC1D,CAAC,EAAvC,EAA2C;AACzCvF,QAAAA,IAAI,CAAC+F,IAAL,CAAUmD,MAAM,CAACC,YAAP,CAAoB5D,CAApB,CAAV;AACD;;AACD,aAAOvF,IAAP;AACD;;AACD,QAAIoJ,iBAAiB,GAAGL,YAAY,CAAC,EAAD,EAAK,EAAL,CAApC;AACA,QAAIM,iBAAiB,GAAGN,YAAY,CAAC,EAAD,EAAK,EAAL,CAApC;AACA,QAAIO,OAAO,GAAGP,YAAY,CAAC,EAAD,EAAK,EAAL,CAA1B;AACA,QAAIQ,UAAU,GAAG,GAAGC,MAAH,CAAUJ,iBAAV,EAA6BC,iBAA7B,EAAgDC,OAAhD,EAAyD,CAAC,GAAD,EAAM,GAAN,CAAzD,CAAjB;AACA,QAAIG,cAAc,GAAG,GAAGD,MAAH,CAAUJ,iBAAV,EAA6BC,iBAA7B,EAAgDC,OAAhD,EAAyD,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgB,GAAhB,EAAqB,GAArB,EAA0B,GAA1B,CAAzD,CAArB;AACA,QAAII,cAAJ;;AACA,QAAI;AAAEA,MAAAA,cAAc,GAAG,IAAIC,MAAJ,CAAW,aAAX,EAA0B,GAA1B,CAAjB;AAAkD,KAAxD,CACA,OAAOC,CAAP,EAAU;AAAEF,MAAAA,cAAc,GAAG,SAAjB;AAA6B;;AAEzC,aAASG,MAAT,CAAgBzG,EAAhB,EAAoByC,IAApB,EAA0B;AACxB,aAAOA,IAAI,IAAIzC,EAAE,CAAC0G,SAAH,EAAR,IAA0BjE,IAAI,IAAIzC,EAAE,CAAC2G,QAAH,EAAzC;AACD;;AACD,aAASC,WAAT,CAAqBC,CAArB,EAAwB;AACtB,aAAQ,SAAD,CAAY1D,IAAZ,CAAiB0D,CAAjB,CAAP;AACD;;AACD,aAASC,iBAAT,CAA2BD,CAA3B,EAA8B;AAC5B,aAAO,SAASE,OAAT,CAAiBF,CAAjB,KAAuB,CAAC,CAA/B;AACD;;AACD,aAASG,QAAT,CAAkBH,CAAlB,EAAqB;AACnB,aAAOtB,WAAW,CAACpC,IAAZ,CAAiB0D,CAAjB,CAAP;AACD;;AACD,aAAShC,WAAT,CAAqBgC,CAArB,EAAwB;AACtB,aAAOP,cAAc,CAACnD,IAAf,CAAoB0D,CAApB,CAAP;AACD;;AACD,aAASI,kBAAT,CAA4BJ,CAA5B,EAA+B;AAC7B,aAAQ,OAAD,CAAU1D,IAAV,CAAe0D,CAAf,CAAP;AACD;;AACD,aAASK,qBAAT,CAA+BL,CAA/B,EAAkC;AAChC,aAAO,MAAME,OAAN,CAAcF,CAAd,KAAoB,CAAC,CAA5B;AACD;;AACD,aAASM,OAAT,CAAiBlE,GAAjB,EAAsBmE,GAAtB,EAA2B;AACzB,WAAK,IAAIjF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiF,GAAG,CAAC7H,MAAxB,EAAgC4C,CAAC,EAAjC,EAAqC;AACnC,YAAIiF,GAAG,CAACjF,CAAD,CAAH,IAAUc,GAAd,EAAmB;AACjB,iBAAO,IAAP;AACD;AACF;;AACD,aAAO,KAAP;AACD;;AAED,QAAIoE,OAAO,GAAG,EAAd;;AACA,aAASrE,YAAT,CAAsBvD,IAAtB,EAA4B6H,YAA5B,EAA0CzK,IAA1C,EAAgD0K,OAAhD,EAAyDC,QAAzD,EAAmE;AACjE,UAAIF,YAAY,KAAKhE,SAAjB,IAA8B,CAACkE,QAAnC,EAA6C;AAC3C,cAAMC,KAAK,CAAC,sDAAD,CAAX;AACD;;AACD,UAAI,CAAC5K,IAAL,EAAW;AAAEA,QAAAA,IAAI,GAAG,QAAP;AAAkB;;AAC/BwK,MAAAA,OAAO,CAAC5H,IAAD,CAAP,GAAgB;AACd5C,QAAAA,IAAI,EAAEA,IADQ;AAEdyK,QAAAA,YAAY,EAAEA,YAFA;AAGdE,QAAAA,QAAQ,EAAEA;AAHI,OAAhB;;AAKA,UAAID,OAAJ,EAAa;AACX,aAAK,IAAIpF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGoF,OAAO,CAAChI,MAA5B,EAAoC4C,CAAC,EAArC,EAAyC;AACvCkF,UAAAA,OAAO,CAACE,OAAO,CAACpF,CAAD,CAAR,CAAP,GAAsBkF,OAAO,CAAC5H,IAAD,CAA7B;AACD;AACF;;AACD,UAAI6H,YAAJ,EAAkB;AAChBrH,QAAAA,SAAS,CAACR,IAAD,EAAO6H,YAAP,CAAT;AACD;AACF;;AAED,aAASrH,SAAT,CAAmBR,IAAnB,EAAyBiI,KAAzB,EAAgC1H,EAAhC,EAAoC2H,GAApC,EAAyC;AACvC,UAAIC,MAAM,GAAGP,OAAO,CAAC5H,IAAD,CAApB;AACAkI,MAAAA,GAAG,GAAGA,GAAG,IAAI,EAAb;AACA,UAAIE,KAAK,GAAGF,GAAG,CAACE,KAAhB;;AACA,UAAI,CAACD,MAAL,EAAa;AACX,eAAO,IAAIH,KAAJ,CAAU,qBAAqBhI,IAA/B,CAAP;AACD;;AACD,UAAImI,MAAM,CAAC/K,IAAP,IAAe,SAAnB,EAA8B;AAC5B,YAAI6K,KAAK,IAAIA,KAAK,KAAK,IAAvB,EAA6B;AAC3B,iBAAO,IAAID,KAAJ,CAAU,uBAAuBhI,IAAvB,GAA8B,GAA9B,GAAoCiI,KAA9C,CAAP;AACD,SAFD,MAEO,IAAIA,KAAK,KAAK,KAAd,EAAqB;AAC1B;AACAA,UAAAA,KAAK,GAAG,IAAR;AACD;AACF;;AACD,UAAIE,MAAM,CAACJ,QAAX,EAAqB;AACnB,YAAIK,KAAK,KAAK,OAAd,EAAuB;AACrBD,UAAAA,MAAM,CAACJ,QAAP,CAAgBE,KAAhB,EAAuBpE,SAAvB;AACD;;AACD,YAAIuE,KAAK,KAAK,QAAV,IAAsB7H,EAA1B,EAA8B;AAC5B4H,UAAAA,MAAM,CAACJ,QAAP,CAAgBE,KAAhB,EAAuB1H,EAAvB;AACD;AACF,OAPD,MAOO;AACL,YAAI6H,KAAK,KAAK,OAAd,EAAuB;AACrBD,UAAAA,MAAM,CAACF,KAAP,GAAeE,MAAM,CAAC/K,IAAP,IAAe,SAAf,GAA2B,CAAC,CAAC6K,KAA7B,GAAqCA,KAApD;AACD;;AACD,YAAIG,KAAK,KAAK,QAAV,IAAsB7H,EAA1B,EAA8B;AAC5BA,UAAAA,EAAE,CAACW,KAAH,CAASC,GAAT,CAAayG,OAAb,CAAqB5H,IAArB,IAA6B;AAACiI,YAAAA,KAAK,EAAEA;AAAR,WAA7B;AACD;AACF;AACF;;AAED,aAASxG,SAAT,CAAmBzB,IAAnB,EAAyBO,EAAzB,EAA6B2H,GAA7B,EAAkC;AAChC,UAAIC,MAAM,GAAGP,OAAO,CAAC5H,IAAD,CAApB;AACAkI,MAAAA,GAAG,GAAGA,GAAG,IAAI,EAAb;AACA,UAAIE,KAAK,GAAGF,GAAG,CAACE,KAAhB;;AACA,UAAI,CAACD,MAAL,EAAa;AACX,eAAO,IAAIH,KAAJ,CAAU,qBAAqBhI,IAA/B,CAAP;AACD;;AACD,UAAImI,MAAM,CAACJ,QAAX,EAAqB;AACnB,YAAIM,KAAK,GAAG9H,EAAE,IAAI4H,MAAM,CAACJ,QAAP,CAAgBlE,SAAhB,EAA2BtD,EAA3B,CAAlB;;AACA,YAAI6H,KAAK,KAAK,QAAV,IAAsBC,KAAK,KAAKxE,SAApC,EAA+C;AAC7C,iBAAOwE,KAAP;AACD;;AACD,YAAID,KAAK,KAAK,OAAd,EAAuB;AACrB,iBAAOD,MAAM,CAACJ,QAAP,EAAP;AACD;;AACD;AACD,OATD,MASO;AACL,YAAIM,KAAK,GAAID,KAAK,KAAK,QAAX,IAAyB7H,EAAE,IAAIA,EAAE,CAACW,KAAH,CAASC,GAAT,CAAayG,OAAb,CAAqB5H,IAArB,CAA3C;AACA,eAAO,CAACqI,KAAK,IAAKD,KAAK,KAAK,OAAX,IAAuBD,MAAhC,IAA0C,EAA3C,EAA+CF,KAAtD;AACD;AACF;;AAED1E,IAAAA,YAAY,CAAC,UAAD,EAAaM,SAAb,EAAwB,QAAxB,EAAkC,CAAC,IAAD,CAAlC,EAA0C,UAAS7D,IAAT,EAAeO,EAAf,EAAmB;AACvE;AACA,UAAIA,EAAE,KAAKsD,SAAX,EAAsB;AACpB;AACD,OAJsE,CAKvE;;;AACA,UAAI7D,IAAI,KAAK6D,SAAb,EAAwB;AACtB,YAAInD,IAAI,GAAGH,EAAE,CAACkB,SAAH,CAAa,MAAb,CAAX;AACA,eAAOf,IAAI,IAAI,MAAR,GAAiB,EAAjB,GAAsBA,IAA7B;AACD,OAHD,MAGO;AACL,YAAIA,IAAI,GAAGV,IAAI,IAAI,EAAR,GAAa,MAAb,GAAsBA,IAAjC;AACAO,QAAAA,EAAE,CAACC,SAAH,CAAa,MAAb,EAAqBE,IAArB;AACD;AACF,KAbW,CAAZ;;AAeA,QAAI4H,sBAAsB,GAAG,YAAW;AACtC,UAAIlC,IAAI,GAAG,GAAX;AACA,UAAImC,OAAO,GAAG,CAAC,CAAf;AACA,UAAIC,IAAI,GAAG,CAAX;AACA,UAAIC,IAAI,GAAG,CAAX;AACA,UAAIC,MAAM,GAAG,IAAIC,KAAJ,CAAUvC,IAAV,CAAb;;AACA,eAASwC,GAAT,CAAarI,EAAb,EAAiBsI,MAAjB,EAAyBC,MAAzB,EAAiC;AAC/B,YAAIC,OAAO,GAAGR,OAAO,GAAGnC,IAAxB;AACA,YAAI4C,OAAO,GAAGN,MAAM,CAACK,OAAD,CAApB;;AACA,iBAASE,WAAT,CAAqBC,MAArB,EAA6B;AAC3B,cAAI7H,IAAI,GAAG,EAAEkH,OAAF,GAAYnC,IAAvB;AACA,cAAI+C,SAAS,GAAGT,MAAM,CAACrH,IAAD,CAAtB;;AACA,cAAI8H,SAAJ,EAAe;AACbA,YAAAA,SAAS,CAAC7F,KAAV;AACD;;AACDoF,UAAAA,MAAM,CAACrH,IAAD,CAAN,GAAed,EAAE,CAAC6I,WAAH,CAAeF,MAAf,CAAf;AACD;;AACD,YAAIF,OAAJ,EAAa;AACX,cAAIK,OAAO,GAAGL,OAAO,CAACM,IAAR,EAAd,CADW,CAEX;;AACA,cAAID,OAAO,IAAI,CAACE,WAAW,CAACF,OAAD,EAAUR,MAAV,CAA3B,EAA8C;AAC5CI,YAAAA,WAAW,CAACJ,MAAD,CAAX;AACD;AACF,SAND,MAMO;AACLI,UAAAA,WAAW,CAACJ,MAAD,CAAX;AACD;;AACDI,QAAAA,WAAW,CAACH,MAAD,CAAX;AACAN,QAAAA,IAAI,GAAGD,OAAP;AACAE,QAAAA,IAAI,GAAGF,OAAO,GAAGnC,IAAV,GAAiB,CAAxB;;AACA,YAAIqC,IAAI,GAAG,CAAX,EAAc;AACZA,UAAAA,IAAI,GAAG,CAAP;AACD;AACF;;AACD,eAASe,IAAT,CAAcjJ,EAAd,EAAkBkJ,MAAlB,EAA0B;AACxBlB,QAAAA,OAAO,IAAIkB,MAAX;;AACA,YAAIlB,OAAO,GAAGC,IAAd,EAAoB;AAClBD,UAAAA,OAAO,GAAGC,IAAV;AACD,SAFD,MAEO,IAAID,OAAO,GAAGE,IAAd,EAAoB;AACzBF,UAAAA,OAAO,GAAGE,IAAV;AACD;;AACD,YAAIiB,IAAI,GAAGhB,MAAM,CAAC,CAACtC,IAAI,GAAGmC,OAAR,IAAmBnC,IAApB,CAAjB,CAPwB,CAQxB;;AACA,YAAIsD,IAAI,IAAI,CAACA,IAAI,CAACJ,IAAL,EAAb,EAA0B;AACxB,cAAIK,GAAG,GAAGF,MAAM,GAAG,CAAT,GAAa,CAAb,GAAiB,CAAC,CAA5B;AACA,cAAIX,MAAJ;AACA,cAAID,MAAM,GAAGtI,EAAE,CAACoF,SAAH,EAAb;;AACA,aAAG;AACD4C,YAAAA,OAAO,IAAIoB,GAAX;AACAD,YAAAA,IAAI,GAAGhB,MAAM,CAAC,CAACtC,IAAI,GAAGmC,OAAR,IAAmBnC,IAApB,CAAb,CAFC,CAGD;;AACA,gBAAIsD,IAAI,KACHZ,MAAM,GAAGY,IAAI,CAACJ,IAAL,EADN,CAAJ,IAEA,CAACC,WAAW,CAACV,MAAD,EAASC,MAAT,CAFhB,EAEkC;AAChC;AACD;AACF,WATD,QASSP,OAAO,GAAGC,IAAV,IAAkBD,OAAO,GAAGE,IATrC;AAUD;;AACD,eAAOiB,IAAP;AACD;;AACD,eAASJ,IAAT,CAAc/I,EAAd,EAAkBkJ,MAAlB,EAA0B;AACxB,YAAIG,UAAU,GAAGrB,OAAjB;AACA,YAAImB,IAAI,GAAGF,IAAI,CAACjJ,EAAD,EAAKkJ,MAAL,CAAf;AACAlB,QAAAA,OAAO,GAAGqB,UAAV;AACA,eAAOF,IAAI,IAAIA,IAAI,CAACJ,IAAL,EAAf;AACD;;AACD,aAAO;AACLO,QAAAA,YAAY,EAAEhG,SADT;AACoB;AACzB+E,QAAAA,GAAG,EAAEA,GAFA;AAGLU,QAAAA,IAAI,EAAEA,IAHD;AAILE,QAAAA,IAAI,EAAEA;AAJD,OAAP;AAMD,KAvED,CAtSmB,CA+WnB;AACA;AACA;;;AACA,QAAIM,uBAAuB,GAAG,UAASC,CAAT,EAAY;AACxC,UAAIA,CAAJ,EAAO;AACL;AACA,eAAO;AACLC,UAAAA,OAAO,EAAED,CAAC,CAACC,OADN;AAELC,UAAAA,6BAA6B,EAAEF,CAAC,CAACE;AAF5B,SAAP;AAID;;AACD,aAAO;AACL;AACAD,QAAAA,OAAO,EAAE,EAFJ;AAGL;AACAC,QAAAA,6BAA6B,EAAE;AAJ1B,OAAP;AAMD,KAdD;;AAgBA,aAASC,cAAT,GAA0B;AACxB,WAAKC,cAAL,GAAsBtG,SAAtB;AACA,WAAKuG,SAAL,GAAiB,KAAjB;AACA,WAAKC,WAAL,GAAmB,KAAnB;AACA,WAAKC,mBAAL,GAA2B,EAA3B;AACA,WAAKC,eAAL,GAAuB1G,SAAvB;AACA,WAAK2G,qBAAL,GAA6BV,uBAAuB,EAApD;AACD;;AACDI,IAAAA,cAAc,CAACO,SAAf,GAA2B;AACzBC,MAAAA,mBAAmB,EAAE,YAAW;AAC9B,YAAIC,cAAc,GAAGC,cAAc,CAACD,cAApC;;AACA,YAAIA,cAAc,CAACJ,eAAnB,EAAoC;AAClCI,UAAAA,cAAc,CAACJ,eAAf,GADkC,CACA;AACnC;;AACDI,QAAAA,cAAc,CAACJ,eAAf,GAAiC1G,SAAjC;AACA8G,QAAAA,cAAc,CAACN,WAAf,GAA6B,KAA7B;AACD,OARwB;AASzBQ,MAAAA,oBAAoB,EAAE,UAAStK,EAAT,EAAauK,YAAb,EAA2B;AAC/C,YAAIC,QAAQ,GACRH,cAAc,CAACI,kBAAf,CAAkCC,WAAlC,CAA8CH,YAA9C,CADJ;;AAEA,YAAIC,QAAJ,EAAc;AACZA,UAAAA,QAAQ,CAACzH,KAAT;AACA,eAAK6G,cAAL,GAAsBW,YAAtB;;AACA,cAAIvK,EAAE,CAAC2K,UAAP,EAAmB;AACjB,iBAAKX,eAAL,GAAuBhK,EAAE,CAAC2K,UAAH,CACnBxJ,QAAQ,CAACyJ,cAAT,CAAwB,iBAAeL,YAAf,GAA4B,GAApD,CADmB,EACuC,IADvC,EAC6C;AAACM,cAAAA,MAAM,EAAC;AAAR,aAD7C,CAAvB;AAED;;AACD,eAAKf,WAAL,GAAmB,IAAnB;AACD;AACF;AArBwB,KAA3B;;AAwBA,aAASxJ,iBAAT,CAA2BN,EAA3B,EAA+B;AAC7B,UAAI,CAACA,EAAE,CAACW,KAAH,CAASC,GAAd,EAAmB;AACjB;AACAZ,QAAAA,EAAE,CAACW,KAAH,CAASC,GAAT,GAAe;AACbkK,UAAAA,UAAU,EAAE,IAAIC,UAAJ,EADC;AAEb;AACA;AACAC,UAAAA,kBAAkB,EAAE1H,SAJP;AAKb;AACA;AACA2H,UAAAA,qBAAqB,EAAE3H,SAPV;AAQb;AACA;AACA;AACA;AACA;AACA4H,UAAAA,QAAQ,EAAE,CAAC,CAbE;AAcb;AACAC,UAAAA,SAAS,EAAE,CAAC,CAfC;AAgBb;AACA;AACAC,UAAAA,UAAU,EAAE,IAlBC;AAmBbtI,UAAAA,KAAK,EAAE,EAnBM;AAoBb;AACAuI,UAAAA,UAAU,EAAE,IArBC;AAsBbpG,UAAAA,UAAU,EAAE,KAtBC;AAuBb;AACA;AACAqG,UAAAA,gBAAgB,EAAEhI,SAzBL;AA0BbiI,UAAAA,UAAU,EAAE,KA1BC;AA2Bb;AACAjN,UAAAA,UAAU,EAAE,KA5BC;AA6BbkN,UAAAA,WAAW,EAAE,KA7BA;AA8BbC,UAAAA,aAAa,EAAE,IA9BF;AA+BbC,UAAAA,cAAc,EAAE,IA/BH;AAgCbC,UAAAA,GAAG,EAAE,EAhCQ;AAiCb;AACAtE,UAAAA,OAAO,EAAE;AAlCI,SAAf;AAoCD;;AACD,aAAOrH,EAAE,CAACW,KAAH,CAASC,GAAhB;AACD;;AACD,QAAIyJ,cAAJ;;AACA,aAASuB,mBAAT,GAA+B;AAC7BvB,MAAAA,cAAc,GAAG;AACf;AACAwB,QAAAA,WAAW,EAAE,IAFE;AAGf;AACAC,QAAAA,gBAAgB,EAAE,KAJH;AAKf;AACAC,QAAAA,yBAAyB,EAAEzI,SANZ;AAOf0I,QAAAA,QAAQ,EAAEjE,sBAAsB,EAPjB;AAQfqC,QAAAA,cAAc,EAAE,IAAIT,cAAJ,EARD;AASf;AACAsC,QAAAA,mBAAmB,EAAE;AAACC,UAAAA,SAAS,EAAC,CAAX;AAAc7O,UAAAA,OAAO,EAAC,IAAtB;AAA4B8O,UAAAA,iBAAiB,EAAC;AAA9C,SAVN;AAWf1B,QAAAA,kBAAkB,EAAE,IAAI2B,kBAAJ,CAAuB,EAAvB,CAXL;AAYf;AACAC,QAAAA,uBAAuB,EAAE,IAAIC,iBAAJ,EAbV;AAcf;AACAC,QAAAA,0BAA0B,EAAG,IAAID,iBAAJ;AAfd,OAAjB;;AAiBA,WAAK,IAAIE,UAAT,IAAuBnF,OAAvB,EAAgC;AAC9B,YAAIO,MAAM,GAAGP,OAAO,CAACmF,UAAD,CAApB;AACA5E,QAAAA,MAAM,CAACF,KAAP,GAAeE,MAAM,CAACN,YAAtB;AACD;AACF;;AAED,QAAImF,sBAAJ;AACA,QAAIC,MAAM,GAAE;AACVC,MAAAA,WAAW,EAAE,YAAW,CACtB;AACD,OAHS;AAIV;AACA;AACAC,MAAAA,qBAAqB,EAAE,YAAW;AAChC,eAAOvC,cAAc,CAACI,kBAAtB;AACD,OARS;AASV;AACAoC,MAAAA,oBAAoB,EAAEjB,mBAVZ;AAYV;AACAkB,MAAAA,kBAAkB,EAAE,YAAW;AAC7B,eAAOzC,cAAP;AACD,OAfS;AAiBV;AACA0C,MAAAA,kBAAkB,EAAEzM,iBAlBV;AAoBV0M,MAAAA,oBAAoB,EAAE,KApBZ;AAsBVC,MAAAA,aAAa,EAAEA,aAtBL;AAuBVC,MAAAA,GAAG,EAAE,UAASC,GAAT,EAAcC,GAAd,EAAmBC,GAAnB,EAAwB;AAC3B;AACAC,QAAAA,mBAAmB,CAACJ,GAApB,CAAwBC,GAAxB,EAA6BC,GAA7B,EAAkCC,GAAlC;AACD,OA1BS;AA2BVE,MAAAA,KAAK,EAAE,UAASJ,GAAT,EAAcE,GAAd,EAAmB;AACxBC,QAAAA,mBAAmB,CAACC,KAApB,CAA0BJ,GAA1B,EAA+BE,GAA/B;AACD,OA7BS;AA8BV;AACA;AACA;AACAG,MAAAA,OAAO,EAAE,UAASL,GAAT,EAAcC,GAAd,EAAmBC,GAAnB,EAAwB;AAC/B,iBAASI,UAAT,CAAoBJ,GAApB,EAAyB;AACvB,iBAAOA,GAAG,GAAG,CAACA,GAAD,CAAH,GAAW,CAAC,QAAD,EAAW,QAAX,EAAqB,QAArB,CAArB;AACD;;AACD,YAAIK,SAAS,GAAGD,UAAU,CAACJ,GAAD,CAA1B,CAJ+B,CAK/B;;AACA,YAAIM,YAAY,GAAGhR,aAAa,CAAC4C,MAAjC;AAAA,YAAyCqO,UAAU,GAAGtO,mBAAtD;;AACA,aAAK,IAAI6C,CAAC,GAAGwL,YAAY,GAAGC,UAA5B,EACKzL,CAAC,GAAGwL,YAAJ,IAAoBD,SAAS,CAACnO,MADnC,EAEK4C,CAAC,EAFN,EAEU;AACR,cAAI0L,OAAO,GAAGlR,aAAa,CAACwF,CAAD,CAA3B,CADQ,CAER;;AACA,cAAI0L,OAAO,CAACjR,IAAR,IAAgBwQ,GAAhB,KACC,CAACC,GAAD,IAAQ,CAACQ,OAAO,CAAC9Q,OAAjB,IAA4B8Q,OAAO,CAAC9Q,OAAR,KAAoBsQ,GADjD,KAEAQ,OAAO,CAAChR,IAAR,CAAaiR,MAAb,CAAoB,CAApB,EAAuB,CAAvB,MAA8B,IAF9B,IAGAD,OAAO,CAAChR,IAAR,CAAaiR,MAAb,CAAoB,CAApB,EAAuB,CAAvB,MAA8B,KAHlC,EAGyC;AACvC;AACA,gBAAIC,UAAU,GAAG,EAAjB;;AACA,iBAAK,IAAI1K,GAAT,IAAgBwK,OAAhB,EAAyB;AACvBE,cAAAA,UAAU,CAAC1K,GAAD,CAAV,GAAkBwK,OAAO,CAACxK,GAAD,CAAzB;AACD,aALsC,CAMvC;;;AACA0K,YAAAA,UAAU,CAACnR,IAAX,GAAkBuQ,GAAlB;;AACA,gBAAIE,GAAG,IAAI,CAACU,UAAU,CAAChR,OAAvB,EAAgC;AAC9BgR,cAAAA,UAAU,CAAChR,OAAX,GAAqBsQ,GAArB;AACD,aAVsC,CAWvC;;;AACA,iBAAKW,WAAL,CAAiBD,UAAjB,EAZuC,CAavC;;;AACA,gBAAIE,UAAU,GAAGR,UAAU,CAACI,OAAO,CAAC9Q,OAAT,CAA3B;AACA2Q,YAAAA,SAAS,GAAGA,SAAS,CAACQ,MAAV,CAAiB,UAASC,EAAT,EAAa;AAAE,qBAAOF,UAAU,CAAClH,OAAX,CAAmBoH,EAAnB,MAA2B,CAAC,CAAnC;AAAuC,aAAvE,CAAZ;AACD;AACF,SAhC8B,CAiC/B;;AACD,OAnES;AAoEV;AACAC,MAAAA,QAAQ,EAAE,UAASf,GAAT,EAAc;AACtB;AACA,YAAIM,YAAY,GAAGhR,aAAa,CAAC4C,MAAjC;AAAA,YACIqO,UAAU,GAAGtO,mBADjB;AAEA,YAAI+O,UAAU,GAAG1R,aAAa,CAAC2R,KAAd,CAAoB,CAApB,EAAuBX,YAAY,GAAGC,UAAtC,CAAjB;AACAjR,QAAAA,aAAa,GAAGA,aAAa,CAAC2R,KAAd,CAAoBX,YAAY,GAAGC,UAAnC,CAAhB;;AACA,YAAIP,GAAJ,EAAS;AACP;AACA;AACA,eAAK,IAAIlL,CAAC,GAAGkM,UAAU,CAAC9O,MAAX,GAAoB,CAAjC,EAAoC4C,CAAC,IAAI,CAAzC,EAA4CA,CAAC,EAA7C,EAAiD;AAC/C,gBAAI0L,OAAO,GAAGQ,UAAU,CAAClM,CAAD,CAAxB;;AACA,gBAAIkL,GAAG,KAAKQ,OAAO,CAAC9Q,OAApB,EAA6B;AAC3B,kBAAI8Q,OAAO,CAAC9Q,OAAZ,EAAqB;AACnB,qBAAKiR,WAAL,CAAiBH,OAAjB;AACD,eAFD,MAEO;AACL;AACA;AACA,oBAAIU,QAAQ,GAAG,CAAC,QAAD,EAAW,QAAX,EAAqB,QAArB,CAAf;;AACA,qBAAK,IAAIC,CAAT,IAAcD,QAAd,EAAwB;AACtB,sBAAIA,QAAQ,CAACC,CAAD,CAAR,KAAgBnB,GAApB,EAAyB;AACvB,wBAAIU,UAAU,GAAG,EAAjB;;AACA,yBAAK,IAAI1K,GAAT,IAAgBwK,OAAhB,EAAyB;AACvBE,sBAAAA,UAAU,CAAC1K,GAAD,CAAV,GAAkBwK,OAAO,CAACxK,GAAD,CAAzB;AACD;;AACD0K,oBAAAA,UAAU,CAAChR,OAAX,GAAqBwR,QAAQ,CAACC,CAAD,CAA7B;;AACA,yBAAKR,WAAL,CAAiBD,UAAjB;AACD;AACF;AACF;AACF;AACF;AACF;AACF,OArGS;AAsGV;AACA;AACA9N,MAAAA,SAAS,EAAEA,SAxGD;AAyGViB,MAAAA,SAAS,EAAEA,SAzGD;AA0GV8B,MAAAA,YAAY,EAAEA,YA1GJ;AA2GVyL,MAAAA,QAAQ,EAAE,UAAShP,IAAT,EAAeiP,MAAf,EAAuBC,IAAvB,EAA4B;AACpC,YAAI,CAACD,MAAL,EAAa;AACXA,UAAAA,MAAM,GAAGjP,IAAT;AACD,SAFD,MAEO,IAAIA,IAAI,CAACsH,OAAL,CAAa2H,MAAb,MAAyB,CAA7B,EAAgC;AACrC,gBAAM,IAAIjH,KAAJ,CAAU,qBAAmBiH,MAAnB,GAA0B,wBAA1B,GAAmDjP,IAAnD,GAAwD,2BAAlE,CAAN;AACD;;AACDmP,QAAAA,UAAU,CAACnP,IAAD,CAAV,GAAiBkP,IAAjB;AACArB,QAAAA,mBAAmB,CAACuB,WAApB,CAAgCH,MAAhC,IAAwC;AAACjP,UAAAA,IAAI,EAACA,IAAN;AAAYC,UAAAA,SAAS,EAACgP,MAAtB;AAA8B7R,UAAAA,IAAI,EAAC;AAAnC,SAAxC;AACD,OAnHS;AAoHViS,MAAAA,SAAS,EAAE,UAAU9O,EAAV,EAAcqD,GAAd,EAAmB0L,MAAnB,EAA2B;AACpC,YAAIC,OAAO,GAAG,KAAKtL,OAAL,CAAa1D,EAAb,EAAiBqD,GAAjB,EAAsB0L,MAAtB,CAAd;;AACA,YAAI,OAAOC,OAAP,KAAmB,UAAvB,EAAmC;AACjC,iBAAOA,OAAO,EAAd;AACD;AACF,OAzHS;;AA0HV;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACMtL,MAAAA,OAAO,EAAE,UAAS1D,EAAT,EAAaqD,GAAb,EAAkB0L,MAAlB,EAA0B;AACjC,YAAInO,GAAG,GAAGN,iBAAiB,CAACN,EAAD,CAA3B;;AACA,iBAASiP,oBAAT,GAAgC;AAC9B,cAAI7E,cAAc,GAAGC,cAAc,CAACD,cAApC;;AACA,cAAIA,cAAc,CAACN,WAAnB,EAAgC;AAC9B,gBAAIzG,GAAG,IAAI,GAAX,EAAgB;AACd+G,cAAAA,cAAc,CAACD,mBAAf;AACA+E,cAAAA,eAAe,CAAClP,EAAD,CAAf;AACA,qBAAO,IAAP;AACD;;AACD,gBAAI+O,MAAM,IAAI,SAAd,EAAyB;AACvBI,cAAAA,MAAM,CAAC/E,cAAD,EAAiB/G,GAAjB,CAAN;AACD;AACF;AACF;;AACD,iBAAS+L,SAAT,GAAqB;AACnB,cAAI/L,GAAG,IAAI,OAAX,EAAoB;AAClB;AACA6L,YAAAA,eAAe,CAAClP,EAAD,CAAf;;AACA,gBAAIY,GAAG,CAAC2K,UAAR,EAAoB;AAClB8D,cAAAA,cAAc,CAACrP,EAAD,CAAd;AACD,aAFD,MAEO,IAAIY,GAAG,CAACqE,UAAR,EAAoB;AACzBqK,cAAAA,cAAc,CAACtP,EAAD,CAAd;AACD;;AACD,mBAAO,IAAP;AACD;AACF;;AACD,iBAASuP,UAAT,CAAoB3S,IAApB,EAA0B;AACxB;AACA,cAAI4S,KAAJ;;AACA,iBAAO5S,IAAP,EAAa;AACX;AACA;AACA4S,YAAAA,KAAK,GAAI,mBAAD,CAAsBC,IAAtB,CAA2B7S,IAA3B,CAAR;AACAyG,YAAAA,GAAG,GAAGmM,KAAK,CAAC,CAAD,CAAX;AACA5S,YAAAA,IAAI,GAAGA,IAAI,CAAC8S,SAAL,CAAeF,KAAK,CAACG,KAAN,GAActM,GAAG,CAAC9D,MAAjC,CAAP;AACA7C,YAAAA,UAAU,CAACoD,GAAX,CAAegP,SAAf,CAAyB9O,EAAzB,EAA6BqD,GAA7B,EAAkC,SAAlC;AACD;AACF;;AAED,iBAASuM,mBAAT,GAA+B;AAC7B,cAAIR,SAAS,EAAb,EAAiB;AAAE,mBAAO,IAAP;AAAc;;AACjC,cAAIxS,IAAI,GAAGgE,GAAG,CAACkK,UAAJ,CAAe+E,SAAf,GAA2BjP,GAAG,CAACkK,UAAJ,CAAe+E,SAAf,GAA2BxM,GAAjE;AACA,cAAIyM,YAAY,GAAGzM,GAAG,CAAC9D,MAAJ,IAAc,CAAjC;AACA,cAAIiQ,KAAK,GAAGO,iBAAiB,CAACC,YAAlB,CAA+BpT,IAA/B,EAAqCD,aAArC,EAAoDiE,GAAG,CAACkK,UAAxD,EAAoE,QAApE,CAAZ,CAJ6B,CAK7B;;AACA,iBAAOlO,IAAI,CAAC2C,MAAL,GAAc,CAAd,IAAmBiQ,KAAK,CAAC3S,IAAN,IAAc,MAAxC,EAAgD;AAC9C,gBAAID,IAAI,GAAGgE,GAAG,CAACkK,UAAJ,CAAe+E,SAAf,GAA2BjT,IAAI,CAAC0R,KAAL,CAAW,CAAX,CAAtC;AACA,gBAAI2B,SAAS,GAAGF,iBAAiB,CAACC,YAAlB,CAA+BpT,IAA/B,EAAqCD,aAArC,EAAoDiE,GAAG,CAACkK,UAAxD,EAAoE,QAApE,CAAhB;;AACA,gBAAImF,SAAS,CAACpT,IAAV,IAAkB,MAAtB,EAA8B;AAAE2S,cAAAA,KAAK,GAAGS,SAAR;AAAoB;AACrD;;AACD,cAAIT,KAAK,CAAC3S,IAAN,IAAc,MAAlB,EAA0B;AAAEqS,YAAAA,eAAe,CAAClP,EAAD,CAAf;AAAqB,mBAAO,KAAP;AAAe,WAAhE,MACK,IAAIwP,KAAK,CAAC3S,IAAN,IAAc,SAAlB,EAA6B;AAChC,gBAAI4P,sBAAJ,EAA4B;AAAEyD,cAAAA,MAAM,CAACC,YAAP,CAAoB1D,sBAApB;AAA8C;;AAC5EA,YAAAA,sBAAsB,GAAGyD,MAAM,CAACE,UAAP,CACvB,YAAW;AAAE,kBAAIxP,GAAG,CAACqE,UAAJ,IAAkBrE,GAAG,CAACkK,UAAJ,CAAe+E,SAArC,EAAgD;AAAEX,gBAAAA,eAAe,CAAClP,EAAD,CAAf;AAAsB;AAAE,aADhE,EAEvBkB,SAAS,CAAC,0BAAD,CAFc,CAAzB;AAGA,mBAAO,CAAC4O,YAAR;AACD;;AAED,cAAIrD,sBAAJ,EAA4B;AAAEyD,YAAAA,MAAM,CAACC,YAAP,CAAoB1D,sBAApB;AAA8C;;AAC5E,cAAIqD,YAAJ,EAAkB;AAChB,gBAAIO,UAAU,GAAGrQ,EAAE,CAACiC,cAAH,EAAjB;;AACA,iBAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGkO,UAAU,CAAC9Q,MAA/B,EAAuC4C,CAAC,EAAxC,EAA4C;AAC1C,kBAAImO,IAAI,GAAGD,UAAU,CAAClO,CAAD,CAAV,CAAc8F,IAAzB;AACAjI,cAAAA,EAAE,CAACuQ,YAAH,CAAgB,EAAhB,EAAoBpL,YAAY,CAACmL,IAAD,EAAO,CAAP,EAAU,EAAE1T,IAAI,CAAC2C,MAAL,GAAc,CAAhB,CAAV,CAAhC,EAA+D+Q,IAA/D,EAAqE,QAArE;AACD;;AACDjG,YAAAA,cAAc,CAACD,cAAf,CAA8BH,qBAA9B,CAAoDR,OAApD,CAA4D+G,GAA5D;AACD;;AACDtB,UAAAA,eAAe,CAAClP,EAAD,CAAf;AACA,iBAAOwP,KAAK,CAACR,OAAb;AACD;;AAED,iBAASyB,sBAAT,GAAkC;AAChC,cAAIxB,oBAAoB,MAAMG,SAAS,EAAvC,EAA2C;AAAE,mBAAO,IAAP;AAAc;;AAE3D,cAAIxS,IAAI,GAAGgE,GAAG,CAACkK,UAAJ,CAAe+E,SAAf,GAA2BjP,GAAG,CAACkK,UAAJ,CAAe+E,SAAf,GAA2BxM,GAAjE;;AACA,cAAI,aAAaF,IAAb,CAAkBvG,IAAlB,CAAJ,EAA6B;AAAE,mBAAO,IAAP;AAAc;;AAE7C,cAAI8T,WAAW,GAAG,cAAcjB,IAAd,CAAmB7S,IAAnB,CAAlB;;AACA,cAAI,CAAC8T,WAAL,EAAkB;AAAExB,YAAAA,eAAe,CAAClP,EAAD,CAAf;AAAqB,mBAAO,KAAP;AAAe;;AACxD,cAAIjD,OAAO,GAAG6D,GAAG,CAAC2K,UAAJ,GAAiB,QAAjB,GACiB,QAD/B;AAEA,cAAIoF,OAAO,GAAGD,WAAW,CAAC,CAAD,CAAX,IAAkBA,WAAW,CAAC,CAAD,CAA3C;;AACA,cAAI9P,GAAG,CAACkK,UAAJ,CAAe8F,gBAAf,IAAmChQ,GAAG,CAACkK,UAAJ,CAAe8F,gBAAf,CAAgCtC,KAAhC,CAAsC,CAAC,CAAvC,KAA6CqC,OAApF,EAA6F;AAC3F;AACAA,YAAAA,OAAO,GAAG/P,GAAG,CAACkK,UAAJ,CAAe8F,gBAAzB;AACD;;AACD,cAAIpB,KAAK,GAAGO,iBAAiB,CAACC,YAAlB,CAA+BW,OAA/B,EAAwChU,aAAxC,EAAuDiE,GAAG,CAACkK,UAA3D,EAAuE/N,OAAvE,CAAZ;;AACA,cAAIyS,KAAK,CAAC3S,IAAN,IAAc,MAAlB,EAA0B;AAAEqS,YAAAA,eAAe,CAAClP,EAAD,CAAf;AAAqB,mBAAO,KAAP;AAAe,WAAhE,MACK,IAAIwP,KAAK,CAAC3S,IAAN,IAAc,SAAlB,EAA6B;AAAE,mBAAO,IAAP;AAAc;;AAElD+D,UAAAA,GAAG,CAACkK,UAAJ,CAAe+E,SAAf,GAA2B,EAA3B;AACA,cAAIa,WAAW,GAAG,cAAcjB,IAAd,CAAmB7S,IAAnB,CAAlB;;AACA,cAAI8T,WAAW,CAAC,CAAD,CAAX,IAAkBA,WAAW,CAAC,CAAD,CAAX,IAAkB,GAAxC,EAA6C;AAC3C9P,YAAAA,GAAG,CAACkK,UAAJ,CAAe+F,eAAf,CAA+BH,WAAW,CAAC,CAAD,CAA1C;AACD;;AACD,iBAAOlB,KAAK,CAACR,OAAb;AACD;;AAED,YAAIA,OAAJ;;AACA,YAAIpO,GAAG,CAACqE,UAAR,EAAoB;AAAE+J,UAAAA,OAAO,GAAGY,mBAAmB,EAA7B;AAAkC,SAAxD,MACK;AAAEZ,UAAAA,OAAO,GAAGyB,sBAAsB,EAAhC;AAAqC;;AAC5C,YAAIzB,OAAO,KAAK,KAAhB,EAAuB;AACrB,iBAAO,CAACpO,GAAG,CAACqE,UAAL,IAAmB5B,GAAG,CAAC9D,MAAJ,KAAe,CAAlC,GAAsC,YAAW;AAAE,mBAAO,IAAP;AAAc,WAAjE,GAAoE+D,SAA3E;AACD,SAFD,MAEO,IAAI0L,OAAO,KAAK,IAAhB,EAAsB;AAC3B;AACA;AACA;AACA,iBAAO,YAAW;AAAE,mBAAO,IAAP;AAAc,WAAlC;AACD,SALM,MAKA;AACL,iBAAO,YAAW;AAChB,mBAAOhP,EAAE,CAAC8Q,SAAH,CAAa,YAAW;AAC7B9Q,cAAAA,EAAE,CAAC+Q,KAAH,CAASC,OAAT,GAAmB,IAAnB;;AACA,kBAAI;AACF,oBAAIhC,OAAO,CAACnS,IAAR,IAAgB,UAApB,EAAgC;AAC9B0S,kBAAAA,UAAU,CAACP,OAAO,CAAClS,MAAT,CAAV;AACD,iBAFD,MAEO;AACLiT,kBAAAA,iBAAiB,CAACkB,cAAlB,CAAiCjR,EAAjC,EAAqCY,GAArC,EAA0CoO,OAA1C;AACD;AACF,eAND,CAME,OAAOkC,CAAP,EAAU;AACV;AACAlR,gBAAAA,EAAE,CAACW,KAAH,CAASC,GAAT,GAAe0C,SAAf;AACAhD,gBAAAA,iBAAiB,CAACN,EAAD,CAAjB;;AACA,oBAAI,CAACtD,UAAU,CAACoD,GAAX,CAAekN,oBAApB,EAA0C;AACxCmE,kBAAAA,OAAO,CAAC,KAAD,CAAP,CAAeD,CAAf;AACD;;AACD,sBAAMA,CAAN;AACD;;AACD,qBAAO,IAAP;AACD,aAlBM,CAAP;AAmBD,WApBD;AAqBD;AACF,OAzQS;AA0QVE,MAAAA,QAAQ,EAAE,UAASpR,EAAT,EAAaqR,KAAb,EAAoB;AAC5B/D,QAAAA,mBAAmB,CAAC2D,cAApB,CAAmCjR,EAAnC,EAAuCqR,KAAvC;AACD,OA5QS;AA8QVC,MAAAA,YAAY,EAAEA,YA9QJ;AA+QVC,MAAAA,YAAY,EAAEA,YA/QJ;AAgRVC,MAAAA,cAAc,EAAEA,cAhRN;AAiRVC,MAAAA,UAAU,EAAEA,UAjRF;AAkRVzD,MAAAA,WAAW,EAAEA,WAlRH;AAoRV0D,MAAAA,cAAc,EAAEA,cApRN;AAsRVrC,MAAAA,cAAc,EAAEA,cAtRN;AAuRVC,MAAAA,cAAc,EAAEA;AAvRN,KAAZ,CAtemB,CAgwBnB;;AACA,aAASvE,UAAT,GAAsB;AACpB,WAAK4G,YAAL,GAAoB,EAApB;AACA,WAAKC,YAAL,GAAoB,EAApB;AAEA,WAAK3T,QAAL,GAAgB,IAAhB;AACA,WAAKC,YAAL,GAAoB,IAApB;AACA,WAAKjB,MAAL,GAAc,IAAd;AACA,WAAKC,UAAL,GAAkB,IAAlB;AACA,WAAK2S,SAAL,GAAiB,EAAjB,CARoB,CAQC;;AACrB,WAAKtF,YAAL,GAAoB,IAApB,CAToB,CASM;AAC3B;;AACDQ,IAAAA,UAAU,CAACb,SAAX,CAAqB2G,eAArB,GAAuC,UAASgB,CAAT,EAAY;AACjD,UAAI,CAAC,KAAK5T,QAAV,EAAoB;AAClB,aAAK0T,YAAL,GAAoB,KAAKA,YAAL,CAAkBvL,MAAlB,CAAyByL,CAAzB,CAApB;AACD,OAFD,MAEO;AACL,aAAKD,YAAL,GAAoB,KAAKA,YAAL,CAAkBxL,MAAlB,CAAyByL,CAAzB,CAApB;AACD;AACF,KAND;;AAOA9G,IAAAA,UAAU,CAACb,SAAX,CAAqB4H,SAArB,GAAiC,YAAW;AAC1C,UAAIC,MAAM,GAAG,CAAb;;AACA,UAAI,KAAKJ,YAAL,CAAkBpS,MAAlB,GAA2B,CAA3B,IAAgC,KAAKqS,YAAL,CAAkBrS,MAAlB,GAA2B,CAA/D,EAAkE;AAChEwS,QAAAA,MAAM,GAAG,CAAT;;AACA,YAAI,KAAKJ,YAAL,CAAkBpS,MAAlB,GAA2B,CAA/B,EAAkC;AAChCwS,UAAAA,MAAM,IAAIC,QAAQ,CAAC,KAAKL,YAAL,CAAkB5M,IAAlB,CAAuB,EAAvB,CAAD,EAA6B,EAA7B,CAAlB;AACD;;AACD,YAAI,KAAK6M,YAAL,CAAkBrS,MAAlB,GAA2B,CAA/B,EAAkC;AAChCwS,UAAAA,MAAM,IAAIC,QAAQ,CAAC,KAAKJ,YAAL,CAAkB7M,IAAlB,CAAuB,EAAvB,CAAD,EAA6B,EAA7B,CAAlB;AACD;AACF;;AACD,aAAOgN,MAAP;AACD,KAZD;;AAcA,aAAS7C,eAAT,CAAyBlP,EAAzB,EAA6BiS,MAA7B,EAAqC;AACnCjS,MAAAA,EAAE,CAACW,KAAH,CAASC,GAAT,CAAakK,UAAb,GAA0B,IAAIC,UAAJ,EAA1B;AACArO,MAAAA,UAAU,CAACwD,MAAX,CAAkBF,EAAlB,EAAsB,kBAAtB,EAA0CiS,MAA1C;AACD;AAED;AACJ;AACA;AACA;AACA;AACA;;;AACI,aAASC,QAAT,CAAkBC,IAAlB,EAAwBhV,QAAxB,EAAkCuB,SAAlC,EAA6C;AAC3C,WAAKqE,KAAL;AACA,WAAK8M,SAAL,GAAiB,CAACsC,IAAI,IAAI,EAAT,CAAjB;AACA,WAAKC,iBAAL,GAAyB,EAAzB;AACA,WAAKC,aAAL,GAAqB,EAArB;AACA,WAAKlV,QAAL,GAAgB,CAAC,CAACA,QAAlB;AACA,WAAKuB,SAAL,GAAiB,CAAC,CAACA,SAAnB;AACD;;AACDwT,IAAAA,QAAQ,CAAChI,SAAT,GAAqB;AACnBoI,MAAAA,OAAO,EAAE,UAASH,IAAT,EAAehV,QAAf,EAAyBuB,SAAzB,EAAoC;AAC3C,aAAKmR,SAAL,GAAiB,CAACsC,IAAI,IAAI,EAAT,CAAjB;AACA,aAAKhV,QAAL,GAAgB,CAAC,CAACA,QAAlB;AACA,aAAKuB,SAAL,GAAiB,CAAC,CAACA,SAAnB;AACD,OALkB;AAMnB6T,MAAAA,QAAQ,EAAE,UAASJ,IAAT,EAAehV,QAAf,EAAyB;AACjC;AACA,YAAIA,QAAJ,EAAc;AACZ,cAAI,CAAC,KAAKA,QAAV,EAAoB;AAClB,iBAAK0S,SAAL,CAAelN,IAAf,CAAoB,IAApB;AACD;;AACD,eAAKxF,QAAL,GAAgB,IAAhB;AACD;;AACD,aAAK0S,SAAL,CAAelN,IAAf,CAAoBwP,IAApB;AACD,OAfkB;AAgBnBK,MAAAA,qBAAqB,EAAE,UAAS/I,OAAT,EAAkB;AACvC,aAAK2I,iBAAL,CAAuBzP,IAAvB,CAA4B4G,uBAAuB,CAACE,OAAD,CAAnD;AACD,OAlBkB;AAmBnBgJ,MAAAA,eAAe,EAAE,UAASC,KAAT,EAAgB;AAC/B,aAAKL,aAAL,CAAmB1P,IAAnB,CAAwB+P,KAAxB;AACD,OArBkB;AAsBnB3P,MAAAA,KAAK,EAAE,YAAW;AAChB,aAAK8M,SAAL,GAAiB,EAAjB;AACA,aAAKuC,iBAAL,GAAyB,EAAzB;AACA,aAAKC,aAAL,GAAqB,EAArB;AACA,aAAKlV,QAAL,GAAgB,KAAhB;AACD,OA3BkB;AA4BnBwV,MAAAA,QAAQ,EAAE,YAAW;AACnB,eAAO,KAAK9C,SAAL,CAAe9K,IAAf,CAAoB,EAApB,CAAP;AACD;AA9BkB,KAArB;AAiCA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACI,aAAS2M,cAAT,CAAwBjS,IAAxB,EAA8B+K,QAA9B,EAAwC;AACtC,UAAIoI,SAAS,GAAGvI,cAAc,CAACI,kBAAf,CAAkCmI,SAAlD;;AACA,UAAI,CAACnT,IAAD,IAASA,IAAI,CAACF,MAAL,IAAe,CAA5B,EAA+B;AAC7B,cAAMkI,KAAK,CAAC,mCAAD,CAAX;AACD;;AACD,UAAImL,SAAS,CAACnT,IAAD,CAAb,EAAqB;AACnB,cAAMgI,KAAK,CAAC,8BAA8BhI,IAA/B,CAAX;AACD;;AACDmT,MAAAA,SAAS,CAACnT,IAAD,CAAT,GAAkB+K,QAAlB;AACAnE,MAAAA,cAAc,CAAC1D,IAAf,CAAoBlD,IAApB;AACD;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI,aAAS2M,kBAAT,CAA4BwG,SAA5B,EAAuC;AACrC,WAAKA,SAAL,GAAiBA,SAAjB;AACA,WAAKC,eAAL,GAAuBD,SAAS,CAAC,GAAD,CAAT,GAAiB,IAAIV,QAAJ,EAAxC;AACAU,MAAAA,SAAS,CAAC,GAAD,CAAT,GAAiB,IAAIV,QAAJ,EAAjB;AACAU,MAAAA,SAAS,CAAC,GAAD,CAAT,GAAiB,IAAIV,QAAJ,EAAjB;AACAU,MAAAA,SAAS,CAAC,GAAD,CAAT,GAAiB,IAAIV,QAAJ,EAAjB;AACD;;AACD9F,IAAAA,kBAAkB,CAAClC,SAAnB,GAA+B;AAC7BqI,MAAAA,QAAQ,EAAE,UAAShI,YAAT,EAAuBtM,QAAvB,EAAiCkU,IAAjC,EAAuChV,QAAvC,EAAiDuB,SAAjD,EAA4D;AACpE;AACA,YAAI6L,YAAY,KAAK,GAArB,EAA0B;;AAC1B,YAAIpN,QAAQ,IAAIgV,IAAI,CAAC5N,MAAL,CAAY4N,IAAI,CAAC5S,MAAL,GAAc,CAA1B,MAAiC,IAAjD,EAAsD;AACpD4S,UAAAA,IAAI,IAAI,IAAR;AACD,SALmE,CAMpE;AACA;;;AACA,YAAI3H,QAAQ,GAAG,KAAKsI,eAAL,CAAqBvI,YAArB,IACX,KAAKG,WAAL,CAAiBH,YAAjB,CADW,GACsB,IADrC,CARoE,CAUpE;AACA;;AACA,YAAI,CAACC,QAAL,EAAe;AACb,kBAAQvM,QAAR;AACE,iBAAK,MAAL;AACE;AACA,mBAAK2U,SAAL,CAAe,GAAf,IAAsB,IAAIV,QAAJ,CAAaC,IAAb,EAAmBhV,QAAnB,EAA6BuB,SAA7B,CAAtB;AACA;;AACF,iBAAK,QAAL;AACA,iBAAK,QAAL;AACE,kBAAIyT,IAAI,CAACpL,OAAL,CAAa,IAAb,KAAsB,CAAC,CAA3B,EAA8B;AAC5B;AACA,qBAAK6L,SAAL,CAAe,GAAf,IAAsB,IAAIV,QAAJ,CAAaC,IAAb,EAAmBhV,QAAnB,CAAtB;AACD,eAHD,MAGO;AACL;AACA;AACA,qBAAK4V,sBAAL;AACA,qBAAKH,SAAL,CAAe,GAAf,IAAsB,IAAIV,QAAJ,CAAaC,IAAb,EAAmBhV,QAAnB,CAAtB;AACD;;AACD;AAhBJ,WADa,CAmBb;;;AACA,eAAK0V,eAAL,CAAqBP,OAArB,CAA6BH,IAA7B,EAAmChV,QAAnC,EAA6CuB,SAA7C;AACA;AACD,SAlCmE,CAoCpE;;;AACA,YAAIsU,MAAM,GAAGnO,WAAW,CAAC0F,YAAD,CAAxB;;AACA,YAAIyI,MAAJ,EAAY;AACVxI,UAAAA,QAAQ,CAAC+H,QAAT,CAAkBJ,IAAlB,EAAwBhV,QAAxB;AACD,SAFD,MAEO;AACLqN,UAAAA,QAAQ,CAAC8H,OAAT,CAAiBH,IAAjB,EAAuBhV,QAAvB,EAAiCuB,SAAjC;AACD,SA1CmE,CA2CpE;AACA;;;AACA,aAAKmU,eAAL,CAAqBP,OAArB,CAA6B9H,QAAQ,CAACmI,QAAT,EAA7B,EAAkDxV,QAAlD;AACD,OA/C4B;AAgD7B;AACA;AACAuN,MAAAA,WAAW,EAAE,UAASjL,IAAT,EAAe;AAC1B,YAAI,CAAC,KAAKqT,eAAL,CAAqBrT,IAArB,CAAL,EAAiC;AAC/B,iBAAO,KAAKoT,eAAZ;AACD;;AACDpT,QAAAA,IAAI,GAAGA,IAAI,CAACqF,WAAL,EAAP;;AACA,YAAI,CAAC,KAAK8N,SAAL,CAAenT,IAAf,CAAL,EAA2B;AACzB,eAAKmT,SAAL,CAAenT,IAAf,IAAuB,IAAIyS,QAAJ,EAAvB;AACD;;AACD,eAAO,KAAKU,SAAL,CAAenT,IAAf,CAAP;AACD,OA3D4B;AA4D7BqT,MAAAA,eAAe,EAAE,UAASrT,IAAT,EAAe;AAC9B,eAAOA,IAAI,IAAI0H,OAAO,CAAC1H,IAAD,EAAO4G,cAAP,CAAtB;AACD,OA9D4B;AA+D7B0M,MAAAA,sBAAsB,EAAE,YAAW;AACjC,aAAK,IAAI5Q,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAI,CAArB,EAAwBA,CAAC,EAAzB,EAA6B;AAC3B,eAAKyQ,SAAL,CAAezQ,CAAf,IAAoB,KAAKuI,WAAL,CAAiB,MAAMvI,CAAC,GAAG,CAAV,CAAjB,CAApB;AACD;AACF;AAnE4B,KAA/B;;AAqEA,aAASmK,iBAAT,GAA6B;AACzB,WAAK2G,aAAL,GAAqB,EAArB;AACA,WAAKC,QAAL,GAAgB,CAAhB;AACA,WAAKC,aAAL,GAAqB,IAArB;AACH;;AACD7G,IAAAA,iBAAiB,CAACpC,SAAlB,GAA8B;AAC5B;AACA;AACAkJ,MAAAA,SAAS,EAAE,UAAU/B,KAAV,EAAiBgC,EAAjB,EAAqB;AAC9B,YAAIJ,aAAa,GAAG,KAAKA,aAAzB;AACA,YAAIK,GAAG,GAAGD,EAAE,GAAG,CAAC,CAAJ,GAAQ,CAApB;AACA,YAAI,KAAKF,aAAL,KAAuB,IAA3B,EAAiC,KAAKA,aAAL,GAAqB9B,KAArB;;AACjC,aAAK,IAAIlP,CAAC,GAAG,KAAK+Q,QAAL,GAAgBI,GAA7B,EAAkCD,EAAE,GAAGlR,CAAC,IAAI,CAAR,GAAYA,CAAC,GAAG8Q,aAAa,CAAC1T,MAAlE,EAA0E4C,CAAC,IAAGmR,GAA9E,EAAmF;AACjF,cAAIC,OAAO,GAAGN,aAAa,CAAC9Q,CAAD,CAA3B;;AACA,eAAK,IAAIqM,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAI+E,OAAO,CAAChU,MAA7B,EAAqCiP,CAAC,EAAtC,EAA0C;AACxC,gBAAI,KAAK2E,aAAL,IAAsBI,OAAO,CAAC7D,SAAR,CAAkB,CAAlB,EAAqBlB,CAArB,CAA1B,EAAmD;AACjD,mBAAK0E,QAAL,GAAgB/Q,CAAhB;AACA,qBAAOoR,OAAP;AACD;AACF;AACF,SAZ6B,CAa9B;;;AACA,YAAIpR,CAAC,IAAI8Q,aAAa,CAAC1T,MAAvB,EAA+B;AAC7B,eAAK2T,QAAL,GAAgBD,aAAa,CAAC1T,MAA9B;AACA,iBAAO,KAAK4T,aAAZ;AACD,SAjB6B,CAkB9B;;;AACA,YAAIhR,CAAC,GAAG,CAAR,EAAY,OAAOkP,KAAP;AACb,OAvB2B;AAwB5BmC,MAAAA,SAAS,EAAE,UAASnC,KAAT,EAAgB;AACzB,YAAI1B,KAAK,GAAG,KAAKsD,aAAL,CAAmBlM,OAAnB,CAA2BsK,KAA3B,CAAZ;AACA,YAAI1B,KAAK,GAAG,CAAC,CAAb,EAAgB,KAAKsD,aAAL,CAAmBQ,MAAnB,CAA0B9D,KAA1B,EAAiC,CAAjC;AAChB,YAAI0B,KAAK,CAAC9R,MAAV,EAAkB,KAAK0T,aAAL,CAAmBtQ,IAAnB,CAAwB0O,KAAxB;AACnB,OA5B2B;AA6B5BqC,MAAAA,KAAK,EAAE,YAAW;AAChB,aAAKP,aAAL,GAAqB,IAArB;AACA,aAAKD,QAAL,GAAgB,KAAKD,aAAL,CAAmB1T,MAAnC;AACD;AAhC2B,KAA9B;AAkCA,QAAIwQ,iBAAiB,GAAG;AACtBC,MAAAA,YAAY,EAAE,UAASpT,IAAT,EAAemE,MAAf,EAAuB+J,UAAvB,EAAmC/N,OAAnC,EAA4C;AACxD,YAAI4W,OAAO,GAAGC,cAAc,CAAChX,IAAD,EAAOmE,MAAP,EAAehE,OAAf,EAAwB+N,UAAxB,CAA5B;;AACA,YAAI,CAAC6I,OAAO,CAACE,IAAT,IAAiB,CAACF,OAAO,CAACG,OAA9B,EAAuC;AACrC,iBAAO;AAACjX,YAAAA,IAAI,EAAE;AAAP,WAAP;AACD,SAFD,MAEO,IAAI,CAAC8W,OAAO,CAACE,IAAT,IAAiBF,OAAO,CAACG,OAA7B,EAAsC;AAC3C,iBAAO;AAACjX,YAAAA,IAAI,EAAE;AAAP,WAAP;AACD;;AAED,YAAIkX,SAAJ;;AACA,aAAK,IAAI5R,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGwR,OAAO,CAACE,IAAR,CAAatU,MAAjC,EAAyC4C,CAAC,EAA1C,EAA8C;AAC5C,cAAIqN,KAAK,GAAGmE,OAAO,CAACE,IAAR,CAAa1R,CAAb,CAAZ;;AACA,cAAI,CAAC4R,SAAL,EAAgB;AACdA,YAAAA,SAAS,GAAGvE,KAAZ;AACD;AACF;;AACD,YAAIuE,SAAS,CAACnX,IAAV,CAAe0R,KAAf,CAAqB,CAAC,EAAtB,KAA6B,aAAjC,EAAgD;AAC9C,cAAI0F,SAAS,GAAGC,QAAQ,CAACrX,IAAD,CAAxB;AACA,cAAI,CAACoX,SAAL,EAAgB,OAAO;AAACnX,YAAAA,IAAI,EAAE;AAAP,WAAP;AAChBiO,UAAAA,UAAU,CAACqB,iBAAX,GAA+B6H,SAA/B;AACD;;AACD,eAAO;AAACnX,UAAAA,IAAI,EAAE,MAAP;AAAemS,UAAAA,OAAO,EAAE+E;AAAxB,SAAP;AACD,OAtBqB;AAuBtB9C,MAAAA,cAAc,EAAE,UAASjR,EAAT,EAAaY,GAAb,EAAkBoO,OAAlB,EAA2B;AACzCpO,QAAAA,GAAG,CAACkK,UAAJ,CAAeoJ,cAAf,GAAgClF,OAAO,CAACkF,cAAxC;;AACA,gBAAQlF,OAAO,CAACnS,IAAhB;AACE,eAAK,QAAL;AACE,iBAAKsX,aAAL,CAAmBnU,EAAnB,EAAuBY,GAAvB,EAA4BoO,OAA5B;AACA;;AACF,eAAK,UAAL;AACE,iBAAKoF,eAAL,CAAqBpU,EAArB,EAAyBY,GAAzB,EAA8BoO,OAA9B;AACA;;AACF,eAAK,gBAAL;AACE,iBAAKqF,qBAAL,CAA2BrU,EAA3B,EAA+BY,GAA/B,EAAoCoO,OAApC;AACA;;AACF,eAAK,QAAL;AACE,iBAAKsF,aAAL,CAAmBtU,EAAnB,EAAuBY,GAAvB,EAA4BoO,OAA5B;AACA;;AACF,eAAK,QAAL;AACE,iBAAKuF,aAAL,CAAmBvU,EAAnB,EAAuBY,GAAvB,EAA4BoO,OAA5B;AACA;;AACF,eAAK,IAAL;AACA,eAAK,SAAL;AACE,iBAAKwF,SAAL,CAAexU,EAAf,EAAmBY,GAAnB,EAAwBoO,OAAxB;AACA;;AACF;AACE;AArBJ;AAuBD,OAhDqB;AAiDtBmF,MAAAA,aAAa,EAAE,UAASnU,EAAT,EAAaY,GAAb,EAAkBoO,OAAlB,EAA2B;AACxCpO,QAAAA,GAAG,CAACkK,UAAJ,CAAe7N,MAAf,GAAwB+R,OAAO,CAAC/R,MAAhC;AACA2D,QAAAA,GAAG,CAACkK,UAAJ,CAAe5N,UAAf,GAA4BuX,QAAQ,CAACzF,OAAO,CAAC9R,UAAT,CAApC;AACA,aAAKwX,SAAL,CAAe1U,EAAf,EAAmBY,GAAnB;AACD,OArDqB;AAsDtBwT,MAAAA,eAAe,EAAE,UAASpU,EAAT,EAAaY,GAAb,EAAkBoO,OAAlB,EAA2B;AAC1C,YAAIlE,UAAU,GAAGlK,GAAG,CAACkK,UAArB;;AACA,YAAIA,UAAU,CAAC7M,QAAf,EAAyB;AACvB,cAAI6M,UAAU,CAAC7M,QAAX,IAAuB+Q,OAAO,CAAC/Q,QAAnC,EAA6C;AAC3C;AACA;AACA6M,YAAAA,UAAU,CAAC7N,MAAX,GAAoB,cAApB;AACA6N,YAAAA,UAAU,CAAC5N,UAAX,GAAwB;AAAEC,cAAAA,QAAQ,EAAE;AAAZ,aAAxB;AACA,iBAAKuX,SAAL,CAAe1U,EAAf,EAAmBY,GAAnB;AACA;AACD,WAPD,MAOO;AACL;AACAsO,YAAAA,eAAe,CAAClP,EAAD,CAAf;AACD;AACF;;AACD8K,QAAAA,UAAU,CAAC7M,QAAX,GAAsB+Q,OAAO,CAAC/Q,QAA9B;AACA6M,QAAAA,UAAU,CAAC5M,YAAX,GAA0BuW,QAAQ,CAACzF,OAAO,CAAC9Q,YAAT,CAAlC;;AACA,YAAI8Q,OAAO,CAACpS,IAAR,CAAa2C,MAAb,GAAsB,CAA1B,EAA6B;AAC3BuL,UAAAA,UAAU,CAAC8F,gBAAX,GAA8B5B,OAAO,CAACpS,IAAtC;AACD;;AACD,YAAIoS,OAAO,CAAClQ,eAAZ,EAA6B;AACzB8B,UAAAA,GAAG,CAAC4K,WAAJ,GAAkB,KAAlB;AACAmJ,UAAAA,iBAAiB,CAAC3U,EAAD,CAAjB;AACH;;AACD,YAAIY,GAAG,CAAC2K,UAAR,EAAoB;AAClB;AACA,eAAKmJ,SAAL,CAAe1U,EAAf,EAAmBY,GAAnB;AACD;AACF,OAlFqB;AAmFtByT,MAAAA,qBAAqB,EAAE,UAASrU,EAAT,EAAaY,GAAb,EAAkBoO,OAAlB,EAA2B;AAChD,YAAIzD,UAAU,GAAG3K,GAAG,CAAC2K,UAArB;AACA,YAAIlN,kBAAkB,GAAGoW,QAAQ,CAACzF,OAAO,CAAC3Q,kBAAT,CAAjC;;AACA,YAAIA,kBAAJ,EAAwB;AACtB;AACA,cAAIkN,UAAU,IAAIlN,kBAAkB,CAACC,UAArC,EAAiD;AAC/CsC,YAAAA,GAAG,CAACtC,UAAJ,GAAiB,IAAjB;AACD;AACF;;AACD,aAAK8V,eAAL,CAAqBpU,EAArB,EAAyBY,GAAzB,EAA8BoO,OAA9B;;AACA,YAAI,CAACzD,UAAL,EAAiB;AACf,eAAK4I,aAAL,CAAmBnU,EAAnB,EAAuBY,GAAvB,EAA4BoO,OAA5B;AACD;AACF,OAhGqB;AAiGtBsF,MAAAA,aAAa,EAAE,UAAStU,EAAT,EAAaY,GAAb,EAAkBoO,OAAlB,EAA2B;AACxC,YAAIlE,UAAU,GAAGlK,GAAG,CAACkK,UAArB;AACA,YAAIiH,MAAM,GAAGjH,UAAU,CAACgH,SAAX,EAAb;AACA,YAAI8C,gBAAgB,GAAG,CAAC,CAAC7C,MAAzB;AACA,YAAIlU,UAAU,GAAG4W,QAAQ,CAACzF,OAAO,CAACnR,UAAT,CAAR,IAAgC,EAAjD;;AACA,YAAIiN,UAAU,CAACqB,iBAAf,EAAkC;AAChCtO,UAAAA,UAAU,CAACsO,iBAAX,GAA+BrB,UAAU,CAACqB,iBAA1C;AACD,SAPuC,CAQxC;;;AACA,YAAI6C,OAAO,CAAC/Q,QAAZ,EAAsB;AACpB,eAAKmW,eAAL,CAAqBpU,EAArB,EAAyBY,GAAzB,EAA8BoO,OAA9B;AACD;;AACD,YAAIA,OAAO,CAAC/R,MAAZ,EAAoB;AAClB,eAAKkX,aAAL,CAAmBnU,EAAnB,EAAuBY,GAAvB,EAA4BoO,OAA5B;AACD;;AACD,YAAIA,OAAO,CAAC/R,MAAR,IAAkB+R,OAAO,CAAC/Q,QAA9B,EAAwC;AACtC,eAAKyW,SAAL,CAAe1U,EAAf,EAAmBY,GAAnB;AACD;;AACD/C,QAAAA,UAAU,CAACkU,MAAX,GAAoBA,MAAM,IAAI,CAA9B;AACAlU,QAAAA,UAAU,CAAC+W,gBAAX,GAA8BA,gBAA9B;AACA/W,QAAAA,UAAU,CAAC0M,YAAX,GAA0BO,UAAU,CAACP,YAArC;AACA2E,QAAAA,eAAe,CAAClP,EAAD,CAAf;AACAY,QAAAA,GAAG,CAACwK,UAAJ,GAAiB,IAAjB;;AACA,YAAI4D,OAAO,CAACpR,MAAZ,EAAoB;AAClB,eAAKiX,cAAL,CAAoBjU,GAApB,EAAyBkK,UAAzB,EAAqCkE,OAArC;AACD;;AACD3J,QAAAA,OAAO,CAAC2J,OAAO,CAAChS,MAAT,CAAP,CAAwBgD,EAAxB,EAA4BnC,UAA5B,EAAwC+C,GAAxC;AACD,OA5HqB;AA6HtB2T,MAAAA,aAAa,EAAE,UAASvU,EAAT,EAAaY,GAAb,EAAkBoO,OAAlB,EAA2B;AACxC,YAAI,CAAChP,EAAE,CAAC8U,eAAR,EAAyB;AACvB;AACA;AACD;;AACD,YAAIzX,OAAO,GAAG2R,OAAO,CAAC7P,UAAR,CAAmB9B,OAAjC;AACA,YAAIgC,aAAa,GAAG2P,OAAO,CAAC7P,UAAR,CAAmBE,aAAvC;AACA0V,QAAAA,cAAc,CAAC/U,EAAD,CAAd,CAAmBgV,WAAnB,CAA+B,CAAC3X,OAAhC;AACA,YAAI4X,YAAY,GAAI5X,OAAD,GAAY,GAAZ,GAAkB,GAArC;AACA,YAAI6X,aAAa,GAAGH,cAAc,CAAC/U,EAAD,CAAd,CAAmBmV,QAAnB,EAApB;AACA,YAAIC,iBAAiB,GAAGpV,EAAE,CAACqV,aAAH,EAAxB;;AACA,iBAASC,WAAT,CAAqB5C,KAArB,EAA4B6C,UAA5B,EAAwCC,SAAxC,EAAmD;AACjDnL,UAAAA,cAAc,CAACgC,uBAAf,CAAuCmH,SAAvC,CAAiDd,KAAjD;AACArI,UAAAA,cAAc,CAACgC,uBAAf,CAAuCqH,KAAvC;;AACA,cAAI;AACF+B,YAAAA,iBAAiB,CAACzV,EAAD,EAAK0S,KAAL,EAAY6C,UAAZ,EAAwBC,SAAxB,CAAjB;AACD,WAFD,CAEE,OAAOtE,CAAP,EAAU;AACVwE,YAAAA,WAAW,CAAC1V,EAAD,EAAK,oBAAoB0S,KAAzB,CAAX;AACAxD,YAAAA,eAAe,CAAClP,EAAD,CAAf;AACA;AACD;;AACD+P,UAAAA,iBAAiB,CAACoE,aAAlB,CAAgCnU,EAAhC,EAAoCY,GAApC,EAAyC;AACvC/D,YAAAA,IAAI,EAAE,QADiC;AAEvCI,YAAAA,MAAM,EAAE,UAF+B;AAGvCC,YAAAA,UAAU,EAAE;AAAEG,cAAAA,OAAO,EAAE,IAAX;AAAiBD,cAAAA,UAAU,EAAE4R,OAAO,CAAC7P,UAAR,CAAmB/B;AAAhD;AAH2B,WAAzC;AAKD;;AACD,iBAASuY,aAAT,CAAuBjD,KAAvB,EAA8B;AAC5B1S,UAAAA,EAAE,CAAC4V,QAAH,CAAYR,iBAAiB,CAACS,IAA9B,EAAoCT,iBAAiB,CAACU,GAAtD;AACAR,UAAAA,WAAW,CAAC5C,KAAD,EAAQ;AAAK;AAAb,YAAgC;AAAK;AAArC,WAAX;AACA,cAAItI,cAAc,GAAGC,cAAc,CAACD,cAApC;;AACA,cAAIA,cAAc,CAACN,WAAnB,EAAgC;AAC9BiM,YAAAA,cAAc,CAAC3L,cAAD,EAAiBsI,KAAjB,CAAd;AACD;AACF;;AACD,iBAASsD,aAAT,CAAuB9E,CAAvB,EAA0BwB,KAA1B,EAAiCuD,KAAjC,EAAwC;AACtC,cAAIC,OAAO,GAAGxZ,UAAU,CAACwZ,OAAX,CAAmBhF,CAAnB,CAAd;AAAA,cAAqCmC,EAArC;AAAA,cAAyCnK,MAAzC;;AACA,cAAIgN,OAAO,IAAI,IAAX,IAAmBA,OAAO,IAAI,MAAlC,EAA0C;AACxC7C,YAAAA,EAAE,GAAG6C,OAAO,IAAI,IAAX,GAAkB,IAAlB,GAAyB,KAA9B;AACAhN,YAAAA,MAAM,GAAGgI,CAAC,CAACiF,MAAF,GAAWjF,CAAC,CAACiF,MAAF,CAASC,YAApB,GAAmC,CAA5C;AACA1D,YAAAA,KAAK,GAAGrI,cAAc,CAACgC,uBAAf,CAAuC+G,SAAvC,CAAiDV,KAAjD,EAAwDW,EAAxD,KAA+D,EAAvE;AACA4C,YAAAA,KAAK,CAACvD,KAAD,CAAL;AACA,gBAAIxJ,MAAM,IAAIgI,CAAC,CAACiF,MAAhB,EAAwBjF,CAAC,CAACiF,MAAF,CAASC,YAAT,GAAwBlF,CAAC,CAACiF,MAAF,CAASE,cAAT,GAA0BC,IAAI,CAACC,GAAL,CAASrN,MAAT,EAAiBgI,CAAC,CAACiF,MAAF,CAASzO,KAAT,CAAenI,MAAhC,CAAlD;AACzB,WAND,MAMO;AACL,gBAAK2W,OAAO,IAAI,MAAX,IAAqBA,OAAO,IAAI,OAAhC,IAA2CA,OAAO,IAAI,MAAtD,IAAgEA,OAAO,IAAI,KAA3E,IAAoFA,OAAO,IAAI,OAApG,EACE7L,cAAc,CAACgC,uBAAf,CAAuCqH,KAAvC;AACH;;AACD,cAAI8C,WAAJ;;AACA,cAAI;AACFA,YAAAA,WAAW,GAAGf,iBAAiB,CAACzV,EAAD,EAAK0S,KAAL,EAC3B;AAAK;AADsB,cACH;AAAK;AADF,aAA/B;AAED,WAHD,CAGE,OAAOxB,CAAP,EAAU,CACV;AACD;;AACD,cAAIsF,WAAJ,EAAiB;AACfxW,YAAAA,EAAE,CAACyW,cAAH,CAAkBC,QAAQ,CAAC1W,EAAD,EAAK,CAAC3C,OAAN,EAAemZ,WAAf,CAA1B,EAAuD,EAAvD;AACD,WAFD,MAEO;AACLG,YAAAA,oBAAoB,CAAC3W,EAAD,CAApB;AACAA,YAAAA,EAAE,CAAC4V,QAAH,CAAYR,iBAAiB,CAACS,IAA9B,EAAoCT,iBAAiB,CAACU,GAAtD;AACD;AACF;;AACD,iBAASc,eAAT,CAAyB1F,CAAzB,EAA4BwB,KAA5B,EAAmCuD,KAAnC,EAA0C;AACxC,cAAIC,OAAO,GAAGxZ,UAAU,CAACwZ,OAAX,CAAmBhF,CAAnB,CAAd;;AACA,cAAIgF,OAAO,IAAI,KAAX,IAAoBA,OAAO,IAAI,QAA/B,IAA2CA,OAAO,IAAI,QAAtD,IACCA,OAAO,IAAI,WAAX,IAA0BxD,KAAK,IAAI,EADxC,EAC6C;AAC3CrI,YAAAA,cAAc,CAACgC,uBAAf,CAAuCmH,SAAvC,CAAiDd,KAAjD;AACArI,YAAAA,cAAc,CAACgC,uBAAf,CAAuCqH,KAAvC;AACA+B,YAAAA,iBAAiB,CAACzV,EAAD,EAAKkV,aAAL,CAAjB;AACAyB,YAAAA,oBAAoB,CAAC3W,EAAD,CAApB;AACAA,YAAAA,EAAE,CAAC4V,QAAH,CAAYR,iBAAiB,CAACS,IAA9B,EAAoCT,iBAAiB,CAACU,GAAtD;AACApZ,YAAAA,UAAU,CAACma,MAAX,CAAkB3F,CAAlB;AACAhC,YAAAA,eAAe,CAAClP,EAAD,CAAf;AACAiW,YAAAA,KAAK;AACLjW,YAAAA,EAAE,CAAC8W,KAAH;AACD,WAXD,MAWO,IAAIZ,OAAO,IAAI,IAAX,IAAmBA,OAAO,IAAI,MAAlC,EAA0C;AAC/CxZ,YAAAA,UAAU,CAACma,MAAX,CAAkB3F,CAAlB;AACD,WAFM,MAEA,IAAIgF,OAAO,IAAI,QAAf,EAAyB;AAC9B;AACAxZ,YAAAA,UAAU,CAACma,MAAX,CAAkB3F,CAAlB;AACA+E,YAAAA,KAAK,CAAC,EAAD,CAAL;AACD;AACF;;AACD,gBAAQjH,OAAO,CAAC7P,UAAR,CAAmBC,QAA3B;AACE,eAAK,QAAL;AACE,gBAAIgL,cAAc,GAAGC,cAAc,CAACD,cAApC;;AACA,gBAAIA,cAAc,CAACP,SAAnB,EAA8B;AAC5B,kBAAI6I,KAAK,GAAGtI,cAAc,CAACL,mBAAf,CAAmCgN,KAAnC,EAAZ;AACAzB,cAAAA,WAAW,CAAC5C,KAAD,EAAQ;AAAK;AAAb,gBAAgC;AAAM;AAAtC,eAAX;AACD,aAHD,MAGO;AACLsE,cAAAA,UAAU,CAAChX,EAAD,EAAK;AACXiX,gBAAAA,OAAO,EAAEtB,aADE;AAEXjH,gBAAAA,MAAM,EAAEuG,YAFG;AAGXiC,gBAAAA,IAAI,EAAE,qBAHK;AAIXC,gBAAAA,OAAO,EAAEnB,aAJE;AAKXoB,gBAAAA,SAAS,EAAER;AALA,eAAL,CAAV;AAOD;;AACD;;AACF,eAAK,iBAAL;AACE,gBAAIS,IAAI,GAAGC,qBAAqB,CAACtX,EAAD,EAAK;AAAM;AAAX,cAC5B;AAAK;AADuB,cACP;AAAM;AADC,cAE5B;AAAK;AAFuB,aAAhC;AAGA,gBAAIuX,SAAS,GAAG,IAAhB;;AACA,gBAAI,CAACF,IAAL,EAAW;AACTA,cAAAA,IAAI,GAAGC,qBAAqB,CAACtX,EAAD,EAAK;AAAM;AAAX,gBACxB;AAAK;AADmB,gBACH;AAAM;AADH,gBAExB;AAAM;AAFkB,eAA5B;AAGAuX,cAAAA,SAAS,GAAG,KAAZ;AACD;;AACD,gBAAI,CAACF,IAAL,EAAW;AACT;AACD;;AACD,gBAAI3E,KAAK,GAAG1S,EAAE,CAACuC,OAAH,CAAW8U,IAAI,CAACzR,KAAL,CAAWnD,IAAtB,EAA4BiN,SAA5B,CAAsC2H,IAAI,CAACzR,KAAL,CAAWlD,EAAjD,EACR2U,IAAI,CAACG,GAAL,CAAS9U,EADD,CAAZ;;AAEA,gBAAI6U,SAAS,IAAIlY,aAAjB,EAAgC;AAC5BqT,cAAAA,KAAK,GAAG,QAAQA,KAAR,GAAgB,KAAxB;AACH,aAFD,MAEO;AACLA,cAAAA,KAAK,GAAG+E,WAAW,CAAC/E,KAAD,CAAnB;AACD,aApBH,CAsBE;AACA;AACA;;;AACArI,YAAAA,cAAc,CAAC2B,QAAf,CAAwB1C,YAAxB,GAAuCtJ,EAAE,CAACoF,SAAH,EAAvC;AACApF,YAAAA,EAAE,CAACkF,SAAH,CAAamS,IAAI,CAACzR,KAAlB;AAEA0P,YAAAA,WAAW,CAAC5C,KAAD,EAAQ;AAAK;AAAb,cAAgC;AAAM;AAAtC,aAAX;AACA;AA7CJ;AA+CD,OA9PqB;AA+PtB8B,MAAAA,SAAS,EAAE,UAASxU,EAAT,EAAaY,GAAb,EAAkBoO,OAAlB,EAA2B;AACpC,iBAAS2G,aAAT,CAAuBtE,KAAvB,EAA8B;AAC5B;AACA;AACAhH,UAAAA,cAAc,CAACkC,0BAAf,CAA0CiH,SAA1C,CAAoDnC,KAApD;AACAhH,UAAAA,cAAc,CAACkC,0BAAf,CAA0CmH,KAA1C;AACApG,UAAAA,mBAAmB,CAAC2D,cAApB,CAAmCjR,EAAnC,EAAuCqR,KAAvC;AACD;;AACD,iBAASuF,eAAT,CAAyB1F,CAAzB,EAA4BG,KAA5B,EAAmC4E,KAAnC,EAA0C;AACxC,cAAIC,OAAO,GAAGxZ,UAAU,CAACwZ,OAAX,CAAmBhF,CAAnB,CAAd;AAAA,cAAqCmC,EAArC;AAAA,cAAyCnK,MAAzC;;AACA,cAAIgN,OAAO,IAAI,KAAX,IAAoBA,OAAO,IAAI,QAA/B,IAA2CA,OAAO,IAAI,QAAtD,IACCA,OAAO,IAAI,WAAX,IAA0B7E,KAAK,IAAI,EADxC,EAC6C;AAC3ChH,YAAAA,cAAc,CAACkC,0BAAf,CAA0CiH,SAA1C,CAAoDnC,KAApD;AACAhH,YAAAA,cAAc,CAACkC,0BAAf,CAA0CmH,KAA1C;AACAhX,YAAAA,UAAU,CAACma,MAAX,CAAkB3F,CAAlB;AACAhC,YAAAA,eAAe,CAAClP,EAAD,CAAf;AACAiW,YAAAA,KAAK;AACLjW,YAAAA,EAAE,CAAC8W,KAAH;AACD;;AACD,cAAIZ,OAAO,IAAI,IAAX,IAAmBA,OAAO,IAAI,MAAlC,EAA0C;AACxCxZ,YAAAA,UAAU,CAACma,MAAX,CAAkB3F,CAAlB;AACAmC,YAAAA,EAAE,GAAG6C,OAAO,IAAI,IAAX,GAAkB,IAAlB,GAAyB,KAA9B;AACAhN,YAAAA,MAAM,GAAGgI,CAAC,CAACiF,MAAF,GAAWjF,CAAC,CAACiF,MAAF,CAASC,YAApB,GAAmC,CAA5C;AACA/E,YAAAA,KAAK,GAAGhH,cAAc,CAACkC,0BAAf,CAA0C6G,SAA1C,CAAoD/B,KAApD,EAA2DgC,EAA3D,KAAkE,EAA1E;AACA4C,YAAAA,KAAK,CAAC5E,KAAD,CAAL;AACA,gBAAInI,MAAM,IAAIgI,CAAC,CAACiF,MAAhB,EAAwBjF,CAAC,CAACiF,MAAF,CAASC,YAAT,GAAwBlF,CAAC,CAACiF,MAAF,CAASE,cAAT,GAA0BC,IAAI,CAACC,GAAL,CAASrN,MAAT,EAAiBgI,CAAC,CAACiF,MAAF,CAASzO,KAAT,CAAenI,MAAhC,CAAlD;AACzB,WAPD,MAOO,IAAI2W,OAAO,IAAI,QAAf,EAAyB;AAC9B;AACAxZ,YAAAA,UAAU,CAACma,MAAX,CAAkB3F,CAAlB;AACA+E,YAAAA,KAAK,CAAC,EAAD,CAAL;AACD,WAJM,MAIA;AACL,gBAAKC,OAAO,IAAI,MAAX,IAAqBA,OAAO,IAAI,OAAhC,IAA2CA,OAAO,IAAI,MAAtD,IAAgEA,OAAO,IAAI,KAA3E,IAAoFA,OAAO,IAAI,OAApG,EACE7L,cAAc,CAACkC,0BAAf,CAA0CmH,KAA1C;AACH;AACF;;AACD,YAAI1E,OAAO,CAACnS,IAAR,IAAgB,SAApB,EAA+B;AAC7B;AACAyQ,UAAAA,mBAAmB,CAAC2D,cAApB,CAAmCjR,EAAnC,EAAuCgP,OAAO,CAAC0I,MAAR,CAAerG,KAAtD;AACD,SAHD,MAGO;AACL,cAAIzQ,GAAG,CAAC2K,UAAR,EAAoB;AAClByL,YAAAA,UAAU,CAAChX,EAAD,EAAK;AAAEiX,cAAAA,OAAO,EAAEtB,aAAX;AAA0BjH,cAAAA,MAAM,EAAE,GAAlC;AAAuChH,cAAAA,KAAK,EAAE,SAA9C;AACX0P,cAAAA,SAAS,EAAER,eADA;AACiBe,cAAAA,iBAAiB,EAAE;AADpC,aAAL,CAAV;AAED,WAHD,MAGO;AACLX,YAAAA,UAAU,CAAChX,EAAD,EAAK;AAAEiX,cAAAA,OAAO,EAAEtB,aAAX;AAA0BjH,cAAAA,MAAM,EAAE,GAAlC;AACX0I,cAAAA,SAAS,EAAER;AADA,aAAL,CAAV;AAED;AACF;AACF,OA9SqB;AA+StBlC,MAAAA,SAAS,EAAE,UAAS1U,EAAT,EAAaY,GAAb,EAAkB;AAC3B;AACA;AACA,YAAIkK,UAAU,GAAGlK,GAAG,CAACkK,UAArB;AACA,YAAI7N,MAAM,GAAG6N,UAAU,CAAC7N,MAAxB;AACA,YAAIC,UAAU,GAAG4N,UAAU,CAAC5N,UAAX,IAAyB,EAA1C;AACA,YAAIe,QAAQ,GAAG6M,UAAU,CAAC7M,QAA1B;AACA,YAAIC,YAAY,GAAG4M,UAAU,CAAC5M,YAAX,IAA2B,EAA9C;AACA,YAAIqM,YAAY,GAAGO,UAAU,CAACP,YAA9B;AACA,YAAIoB,GAAG,GAAG/K,GAAG,CAAC+K,GAAd,CAT2B,CAU3B;;AACA,YAAIiM,QAAQ,GAAGC,UAAU,CAACjX,GAAG,CAAC2K,UAAJ,GAAiBuM,mBAAmB,CAAC9X,EAAD,EAAK2L,GAAG,CAAC1D,IAAT,CAApC,GAAoDjI,EAAE,CAACoF,SAAH,CAAa,MAAb,CAArD,CAAzB;AACA,YAAI2S,UAAU,GAAGF,UAAU,CAACjX,GAAG,CAAC2K,UAAJ,GAAiBuM,mBAAmB,CAAC9X,EAAD,EAAK2L,GAAG,CAACnJ,MAAT,CAApC,GAAuDxC,EAAE,CAACoF,SAAH,CAAa,QAAb,CAAxD,CAA3B;AACA,YAAI4S,OAAO,GAAGH,UAAU,CAACD,QAAD,CAAxB;AACA,YAAIK,SAAS,GAAGJ,UAAU,CAACE,UAAD,CAA1B;AACA,YAAIG,OAAJ,EAAaC,SAAb;AACA,YAAIpG,MAAJ;;AACA,YAAI9T,QAAJ,EAAc;AACZ,eAAK4W,cAAL,CAAoBjU,GAApB,EAAyBkK,UAAzB;AACD;;AACD,YAAIA,UAAU,CAACoJ,cAAX,KAA8B5Q,SAAlC,EAA6C;AAC3C;AACA;AACAyO,UAAAA,MAAM,GAAGjH,UAAU,CAACoJ,cAApB;AACD,SAJD,MAIO;AACLnC,UAAAA,MAAM,GAAGjH,UAAU,CAACgH,SAAX,EAAT;AACD;;AACD,YAAIC,MAAM,GAAG,CAAT,IAAc7U,UAAU,CAACO,cAA7B,EAA6C;AAC3CP,UAAAA,UAAU,CAAC0X,gBAAX,GAA8B,IAA9B;AACD,SAFD,MAEO,IAAI1X,UAAU,CAACkb,QAAX,IACN,CAAClb,UAAU,CAACO,cAAZ,IAA8BsU,MAAM,KAAK,CADvC,EAC2C;AAChDA,UAAAA,MAAM,GAAG,CAAT;AACA7U,UAAAA,UAAU,CAAC0X,gBAAX,GAA8B,KAA9B;AACD;;AACD,YAAI9J,UAAU,CAACqB,iBAAf,EAAkC;AAChC;AACAjP,UAAAA,UAAU,CAACiP,iBAAX,GAA+BjO,YAAY,CAACiO,iBAAb,GAC3BrB,UAAU,CAACqB,iBADf;AAED;;AACDjP,QAAAA,UAAU,CAAC6U,MAAX,GAAoBA,MAApB;AACA7C,QAAAA,eAAe,CAAClP,EAAD,CAAf;;AACA,YAAI/C,MAAJ,EAAY;AACV,cAAIob,YAAY,GAAGC,OAAO,CAACrb,MAAD,CAAP,CAAgB+C,EAAhB,EAAoB4X,QAApB,EAA8B1a,UAA9B,EAA0C0D,GAA1C,EAA+CkK,UAA/C,CAAnB;AACAlK,UAAAA,GAAG,CAACwK,UAAJ,GAAiBkN,OAAO,CAACrb,MAAD,CAAxB;;AACA,cAAI,CAACob,YAAL,EAAmB;AACjB;AACD;;AACD,cAAInb,UAAU,CAACE,UAAf,EAA2B;AACzB,gBAAI4O,QAAQ,GAAG3B,cAAc,CAAC2B,QAA9B,CADyB,CAEzB;;AACA,gBAAI1C,YAAY,GAAG0C,QAAQ,CAAC1C,YAA5B;;AACA,gBAAIA,YAAJ,EAAkB;AAChBiP,cAAAA,kBAAkB,CAACvY,EAAD,EAAKsJ,YAAL,EAAmB+O,YAAnB,CAAlB;AACA,qBAAOrM,QAAQ,CAAC1C,YAAhB;AACD,aAHD,MAGO;AACLiP,cAAAA,kBAAkB,CAACvY,EAAD,EAAK4X,QAAL,EAAeS,YAAf,CAAlB;AACD;AACF;;AACD,cAAIA,YAAY,YAAYjQ,KAA5B,EAAmC;AACjC+P,YAAAA,SAAS,GAAGE,YAAY,CAAC,CAAD,CAAxB;AACAH,YAAAA,OAAO,GAAGG,YAAY,CAAC,CAAD,CAAtB;AACD,WAHD,MAGO;AACLH,YAAAA,OAAO,GAAGG,YAAV;AACD,WAtBS,CAuBV;;;AACA,cAAI,CAACH,OAAL,EAAc;AACZA,YAAAA,OAAO,GAAGL,UAAU,CAACD,QAAD,CAApB;AACD;;AACD,cAAIhX,GAAG,CAAC2K,UAAR,EAAoB;AAClB,gBAAI,EAAE3K,GAAG,CAAC4K,WAAJ,IAAmB0M,OAAO,CAACxV,EAAR,KAAe8V,QAApC,CAAJ,EAAmD;AACjDN,cAAAA,OAAO,GAAGJ,mBAAmB,CAAC9X,EAAD,EAAKkY,OAAL,CAA7B;AACD;;AACD,gBAAIC,SAAJ,EAAe;AACbA,cAAAA,SAAS,GAAGL,mBAAmB,CAAC9X,EAAD,EAAKmY,SAAL,CAA/B;AACD;;AACDA,YAAAA,SAAS,GAAGA,SAAS,IAAIF,SAAzB;AACAtM,YAAAA,GAAG,CAACnJ,MAAJ,GAAa2V,SAAb;AACAxM,YAAAA,GAAG,CAAC1D,IAAJ,GAAWiQ,OAAX;AACAvD,YAAAA,iBAAiB,CAAC3U,EAAD,CAAjB;AACAyY,YAAAA,UAAU,CAACzY,EAAD,EAAKY,GAAL,EAAU,GAAV,EACN8X,cAAc,CAACP,SAAD,EAAYD,OAAZ,CAAd,GAAqCC,SAArC,GACMD,OAFA,CAAV;AAGAO,YAAAA,UAAU,CAACzY,EAAD,EAAKY,GAAL,EAAU,GAAV,EACN8X,cAAc,CAACP,SAAD,EAAYD,OAAZ,CAAd,GAAqCA,OAArC,GACMC,SAFA,CAAV;AAGD,WAjBD,MAiBO,IAAI,CAACla,QAAL,EAAe;AACpBia,YAAAA,OAAO,GAAGJ,mBAAmB,CAAC9X,EAAD,EAAKkY,OAAL,CAA7B;AACAlY,YAAAA,EAAE,CAACkF,SAAH,CAAagT,OAAO,CAACzV,IAArB,EAA2ByV,OAAO,CAACxV,EAAnC;AACD;AACF;;AACD,YAAIzE,QAAJ,EAAc;AACZ,cAAIC,YAAY,CAACya,OAAjB,EAA0B;AACxB;AACAR,YAAAA,SAAS,GAAGF,SAAZ;AACA,gBAAIU,OAAO,GAAGza,YAAY,CAACya,OAA3B;AACA,gBAAIC,UAAU,GAAGtC,IAAI,CAACuC,GAAL,CAASF,OAAO,CAAC1Q,IAAR,CAAaxF,IAAb,GAAoBkW,OAAO,CAACnW,MAAR,CAAeC,IAA5C,CAAjB;AACA,gBAAIqW,QAAQ,GAAGxC,IAAI,CAACuC,GAAL,CAASF,OAAO,CAAC1Q,IAAR,CAAavF,EAAb,GAAkBiW,OAAO,CAACnW,MAAR,CAAeE,EAA1C,CAAf;;AACA,gBAAIiW,OAAO,CAACra,UAAZ,EAAwB;AACtB;AACA4Z,cAAAA,OAAO,GAAGrY,GAAG,CAACoY,SAAS,CAACxV,IAAV,GAAiBmW,UAAlB,EAA8BX,SAAS,CAACvV,EAAxC,CAAb;AACD,aAHD,MAGO,IAAIiW,OAAO,CAACnN,WAAZ,EAAyB;AAC9B;AACA0M,cAAAA,OAAO,GAAGrY,GAAG,CAACoY,SAAS,CAACxV,IAAV,GAAiBmW,UAAlB,EAA8BX,SAAS,CAACvV,EAAV,GAAeoW,QAA7C,CAAb;AACD,aAHM,MAGA,IAAIH,OAAO,CAAC1Q,IAAR,CAAaxF,IAAb,IAAqBkW,OAAO,CAACnW,MAAR,CAAeC,IAAxC,EAA8C;AACnD;AACAyV,cAAAA,OAAO,GAAGrY,GAAG,CAACoY,SAAS,CAACxV,IAAX,EAAiBwV,SAAS,CAACvV,EAAV,GAAeoW,QAAhC,CAAb;AACD,aAHM,MAGA;AACL;AACA;AACAZ,cAAAA,OAAO,GAAGrY,GAAG,CAACoY,SAAS,CAACxV,IAAV,GAAiBmW,UAAlB,EAA8BX,SAAS,CAACvV,EAAxC,CAAb;AACD;;AACD9B,YAAAA,GAAG,CAAC2K,UAAJ,GAAiB,IAAjB;AACA3K,YAAAA,GAAG,CAACtC,UAAJ,GAAiBqa,OAAO,CAACra,UAAzB;AACAsC,YAAAA,GAAG,CAAC4K,WAAJ,GAAkBmN,OAAO,CAACnN,WAA1B;AACAG,YAAAA,GAAG,GAAG/K,GAAG,CAAC+K,GAAJ,GAAU;AACdnJ,cAAAA,MAAM,EAAE2V,SADM;AAEdlQ,cAAAA,IAAI,EAAEiQ;AAFQ,aAAhB;AAIAvD,YAAAA,iBAAiB,CAAC3U,EAAD,CAAjB;AACD,WA5BD,MA4BO,IAAIY,GAAG,CAAC2K,UAAR,EAAoB;AACzBrN,YAAAA,YAAY,CAACya,OAAb,GAAuB;AACrBnW,cAAAA,MAAM,EAAEqV,UAAU,CAAClM,GAAG,CAACnJ,MAAL,CADG;AAErByF,cAAAA,IAAI,EAAE4P,UAAU,CAAClM,GAAG,CAAC1D,IAAL,CAFK;AAGrBuD,cAAAA,WAAW,EAAE5K,GAAG,CAAC4K,WAHI;AAIrBlN,cAAAA,UAAU,EAAEsC,GAAG,CAACtC;AAJK,aAAvB;AAMD;;AACD,cAAIya,QAAJ,EAAcC,MAAd,EAAsB7b,QAAtB,EAAgCgD,IAAhC;AACA,cAAI8Y,KAAJ;;AACA,cAAIrY,GAAG,CAAC2K,UAAR,EAAoB;AAClB;AACAwN,YAAAA,QAAQ,GAAGG,SAAS,CAACvN,GAAG,CAAC1D,IAAL,EAAW0D,GAAG,CAACnJ,MAAf,CAApB;AACAwW,YAAAA,MAAM,GAAGG,SAAS,CAACxN,GAAG,CAAC1D,IAAL,EAAW0D,GAAG,CAACnJ,MAAf,CAAlB;AACArF,YAAAA,QAAQ,GAAGyD,GAAG,CAACtC,UAAJ,IAAkBJ,YAAY,CAACf,QAA1C;AACAgD,YAAAA,IAAI,GAAGS,GAAG,CAAC4K,WAAJ,GAAkB,OAAlB,GACArO,QAAQ,GAAG,MAAH,GACR,MAFP;AAGA8b,YAAAA,KAAK,GAAGG,eAAe,CAACpZ,EAAD,EAAK;AAC1BwC,cAAAA,MAAM,EAAEuW,QADkB;AAE1B9Q,cAAAA,IAAI,EAAE+Q;AAFoB,aAAL,EAGpB7Y,IAHoB,CAAvB;;AAIA,gBAAIhD,QAAJ,EAAc;AACZ,kBAAI6E,MAAM,GAAGiX,KAAK,CAACjX,MAAnB;;AACA,kBAAI7B,IAAI,IAAI,OAAZ,EAAqB;AACnB;AACA,qBAAK,IAAIgC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,MAAM,CAACzC,MAA3B,EAAmC4C,CAAC,EAApC,EAAwC;AACtCH,kBAAAA,MAAM,CAACG,CAAD,CAAN,CAAU8F,IAAV,CAAevF,EAAf,GAAoBJ,UAAU,CAACtC,EAAD,EAAKgC,MAAM,CAACG,CAAD,CAAN,CAAU8F,IAAV,CAAexF,IAApB,CAA9B;AACD;AACF,eALD,MAKO,IAAItC,IAAI,IAAI,MAAZ,EAAoB;AACzB6B,gBAAAA,MAAM,CAAC,CAAD,CAAN,CAAUiG,IAAV,GAAiBpI,GAAG,CAACmC,MAAM,CAAC,CAAD,CAAN,CAAUiG,IAAV,CAAexF,IAAf,GAAsB,CAAvB,EAA0B,CAA1B,CAApB;AACD;AACF;AACF,WAvBD,MAuBO;AACL;AACAsW,YAAAA,QAAQ,GAAGlB,UAAU,CAACM,SAAS,IAAIF,SAAd,CAArB;AACAe,YAAAA,MAAM,GAAGnB,UAAU,CAACK,OAAO,IAAIF,OAAZ,CAAnB;;AACA,gBAAIU,cAAc,CAACM,MAAD,EAASD,QAAT,CAAlB,EAAsC;AACpC,kBAAIM,GAAG,GAAGN,QAAV;AACAA,cAAAA,QAAQ,GAAGC,MAAX;AACAA,cAAAA,MAAM,GAAGK,GAAT;AACD;;AACDlc,YAAAA,QAAQ,GAAGD,UAAU,CAACC,QAAX,IAAuBe,YAAY,CAACf,QAA/C;;AACA,gBAAIA,QAAJ,EAAc;AACZ;AACAmc,cAAAA,qBAAqB,CAACtZ,EAAD,EAAK+Y,QAAL,EAAeC,MAAf,CAArB;AACD,aAHD,MAGO,IAAI9b,UAAU,CAACG,OAAf,EAAwB;AAC7B;AACAkc,cAAAA,UAAU,CAACvZ,EAAD,EAAK+Y,QAAL,EAAeC,MAAf,CAAV;AACD;;AACD7Y,YAAAA,IAAI,GAAG,MAAP;AACA,gBAAIqZ,SAAS,GAAG,CAACtc,UAAU,CAACM,SAAZ,IAAyBL,QAAzC;AACA8b,YAAAA,KAAK,GAAGG,eAAe,CAACpZ,EAAD,EAAK;AAC1BwC,cAAAA,MAAM,EAAEuW,QADkB;AAE1B9Q,cAAAA,IAAI,EAAE+Q;AAFoB,aAAL,EAGpB7Y,IAHoB,EAGdqZ,SAHc,CAAvB;AAID;;AACDxZ,UAAAA,EAAE,CAACyZ,aAAH,CAAiBR,KAAK,CAACjX,MAAvB,EAA+BiX,KAAK,CAACS,OAArC;AACA9Y,UAAAA,GAAG,CAACwK,UAAJ,GAAiB,IAAjB;AACAlN,UAAAA,YAAY,CAAC6T,MAAb,GAAsBA,MAAtB,CAxFY,CAwFkB;;AAC9B7T,UAAAA,YAAY,CAACqM,YAAb,GAA4BA,YAA5B,CAzFY,CA0FZ;;AACArM,UAAAA,YAAY,CAACf,QAAb,GAAwBA,QAAxB;AACA,cAAIwc,cAAc,GAAGC,SAAS,CAAC3b,QAAD,CAAT,CACnB+B,EADmB,EACf9B,YADe,EACD+a,KAAK,CAACjX,MADL,EACaiW,SADb,EACwBC,OADxB,CAArB;;AAEA,cAAItX,GAAG,CAAC2K,UAAR,EAAoB;AAClB8D,YAAAA,cAAc,CAACrP,EAAD,EAAK2Z,cAAc,IAAI,IAAvB,CAAd;AACD;;AACD,cAAIA,cAAJ,EAAoB;AAClB3Z,YAAAA,EAAE,CAACkF,SAAH,CAAayU,cAAb;AACD;AACF;AACF,OA9eqB;AA+etB9E,MAAAA,cAAc,EAAE,UAASjU,GAAT,EAAckK,UAAd,EAA0B+O,aAA1B,EAAyC;AACvD,YAAIzP,cAAc,GAAGC,cAAc,CAACD,cAApC;;AACA,YAAIA,cAAc,CAACP,SAAnB,EAA8B;AAAE;AAAS;;AACzCjJ,QAAAA,GAAG,CAACoK,kBAAJ,GAAyBF,UAAzB;AACAlK,QAAAA,GAAG,CAACqK,qBAAJ,GAA4B4O,aAA5B;AACAzP,QAAAA,cAAc,CAACH,qBAAf,CAAqCR,OAArC,GAA+C,EAA/C;AACAW,QAAAA,cAAc,CAACH,qBAAf,CAAqCP,6BAArC,GAAqE,KAArE;AACAU,QAAAA,cAAc,CAACH,qBAAf,CAAqCuB,WAArC,GAAmD5K,GAAG,CAAC4K,WAAJ,GAAkB5K,GAAG,CAAC+K,GAAJ,CAAQ1D,IAAR,CAAaxF,IAAb,GAAoB7B,GAAG,CAAC+K,GAAJ,CAAQnJ,MAAR,CAAeC,IAArD,GAA4D,CAA/G;AACD;AAvfqB,KAAxB;AA0fA;AACJ;AACA;AACA;AACI;;AACA,QAAI6V,OAAO,GAAG;AACZwB,MAAAA,aAAa,EAAE,UAAS9Z,EAAT,EAAa+Z,KAAb,EAAoB7c,UAApB,EAAgC;AAC7C,YAAIuF,IAAI,GAAGuX,mBAAmB,CAACha,EAAD,CAAnB,CAAwB8V,GAAxB,GAA8B5Y,UAAU,CAAC6U,MAAzC,GAAiD,CAA5D;AACA,eAAOlS,GAAG,CAAC4C,IAAD,EAAOwX,+BAA+B,CAACja,EAAE,CAACuC,OAAH,CAAWE,IAAX,CAAD,CAAtC,CAAV;AACD,OAJW;AAKZyX,MAAAA,gBAAgB,EAAE,UAASla,EAAT,EAAa;AAC7B,YAAIoC,KAAK,GAAG4X,mBAAmB,CAACha,EAAD,CAA/B;AACA,YAAIyC,IAAI,GAAG6T,IAAI,CAAC6D,KAAL,CAAW,CAAC/X,KAAK,CAAC0T,GAAN,GAAY1T,KAAK,CAACyI,MAAnB,IAA6B,GAAxC,CAAX;AACA,eAAOhL,GAAG,CAAC4C,IAAD,EAAOwX,+BAA+B,CAACja,EAAE,CAACuC,OAAH,CAAWE,IAAX,CAAD,CAAtC,CAAV;AACD,OATW;AAUZ2X,MAAAA,gBAAgB,EAAE,UAASpa,EAAT,EAAa+Z,KAAb,EAAoB7c,UAApB,EAAgC;AAChD,YAAIuF,IAAI,GAAGuX,mBAAmB,CAACha,EAAD,CAAnB,CAAwB6K,MAAxB,GAAiC3N,UAAU,CAAC6U,MAA5C,GAAoD,CAA/D;AACA,eAAOlS,GAAG,CAAC4C,IAAD,EAAOwX,+BAA+B,CAACja,EAAE,CAACuC,OAAH,CAAWE,IAAX,CAAD,CAAtC,CAAV;AACD,OAbW;AAcZ4X,MAAAA,YAAY,EAAE,UAASC,GAAT,EAAcrS,IAAd,EAAoB/K,UAApB,EAAgC;AAC5C;AACA;AACA,YAAIqd,GAAG,GAAGtS,IAAV;AACA,eAAOpI,GAAG,CAAC0a,GAAG,CAAC9X,IAAJ,GAAWvF,UAAU,CAAC6U,MAAtB,GAA+B,CAAhC,EAAmCyG,QAAnC,CAAV;AACD,OAnBW;AAoBZ9B,MAAAA,QAAQ,EAAE,UAAS1W,EAAT,EAAa+Z,KAAb,EAAoB7c,UAApB,EAAgC;AACxC,YAAIyD,KAAK,GAAGoU,cAAc,CAAC/U,EAAD,CAA1B;AACA,YAAI0S,KAAK,GAAG/R,KAAK,CAACwU,QAAN,EAAZ;;AACA,YAAI,CAACzC,KAAL,EAAY;AACV;AACD;;AACD,YAAIhR,IAAI,GAAG,CAACxE,UAAU,CAACG,OAAvB,CANwC,CAOxC;;AACAqE,QAAAA,IAAI,GAAIf,KAAK,CAAC6Z,UAAN,EAAD,GAAuB,CAAC9Y,IAAxB,GAA+BA,IAAtC;AACA+Y,QAAAA,sBAAsB,CAACza,EAAD,EAAK0S,KAAL,CAAtB;AACA,eAAOgE,QAAQ,CAAC1W,EAAD,EAAK0B;AAAI;AAAT,UAAsBgR,KAAtB,EAA6BxV,UAAU,CAAC6U,MAAxC,CAAf;AACD,OA/BW;;AAgCZ;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACM2I,MAAAA,0BAA0B,EAAE,UAAS1a,EAAT,EAAa+Z,KAAb,EAAoB7c,UAApB,EAAgC0D,GAAhC,EAAqC+Z,cAArC,EAAqD;AAC/E,YAAIha,KAAK,GAAGoU,cAAc,CAAC/U,EAAD,CAA1B;AACA,YAAI0S,KAAK,GAAG/R,KAAK,CAACwU,QAAN,EAAZ;;AAEA,YAAI,CAACzC,KAAL,EAAY;AACV;AACD;;AAED,YAAIhR,IAAI,GAAG,CAACxE,UAAU,CAACG,OAAvB;AACAqE,QAAAA,IAAI,GAAIf,KAAK,CAAC6Z,UAAN,EAAD,GAAuB,CAAC9Y,IAAxB,GAA+BA,IAAtC,CAT+E,CAW/E;;AACA,YAAIZ,IAAI,GAAG8Z,0BAA0B,CAAC5a,EAAD,EAAK0B,IAAL,EAAWgR,KAAX,EAAkBxV,UAAU,CAAC6U,MAA7B,EAAqCnR,GAArC,CAArC,CAZ+E,CAc/E;;AACA,YAAI,CAACE,IAAL,EAAW;AACT;AACD,SAjB8E,CAmB/E;;;AACA,YAAI6Z,cAAc,CAAC1c,QAAnB,EAA6B;AAC3B,iBAAO6C,IAAP;AACD,SAtB8E,CAwB/E;AACA;;;AAEA,YAAI+Z,IAAI,GAAG/Z,IAAI,CAAC,CAAD,CAAf,CA3B+E,CA4B/E;AACA;AACA;;AACA,YAAIga,EAAE,GAAGjb,GAAG,CAACiB,IAAI,CAAC,CAAD,CAAJ,CAAQ2B,IAAT,EAAe3B,IAAI,CAAC,CAAD,CAAJ,CAAQ4B,EAAR,GAAa,CAA5B,CAAZ;;AAEA,YAAI9B,GAAG,CAAC2K,UAAR,EAAoB;AAClB;AACA,cAAI3K,GAAG,CAACtC,UAAJ,IAAkBsC,GAAG,CAAC4K,WAA1B,EAAuC;AACrC5K,YAAAA,GAAG,CAACtC,UAAJ,GAAiB,KAAjB;AACAsC,YAAAA,GAAG,CAAC4K,WAAJ,GAAkB,KAAlB;AACA9O,YAAAA,UAAU,CAACwD,MAAX,CAAkBF,EAAlB,EAAsB,iBAAtB,EAAyC;AAACG,cAAAA,IAAI,EAAE,QAAP;AAAiB4a,cAAAA,OAAO,EAAE;AAA1B,aAAzC;AACD,WANiB,CAQlB;AACA;;;AACA,cAAIvY,MAAM,GAAG5B,GAAG,CAAC+K,GAAJ,CAAQnJ,MAArB;;AACA,cAAIA,MAAJ,EAAY;AACV,gBAAI7B,KAAK,CAAC6Z,UAAN,EAAJ,EAAwB;AACtB,kBAAItd,UAAU,CAACG,OAAf,EAAwB;AACtB,uBAAO,CAACmF,MAAD,EAASqY,IAAT,CAAP;AACD;;AAED,qBAAO,CAACrY,MAAD,EAASsY,EAAT,CAAP;AACD,aAND,MAMO;AACL,kBAAI5d,UAAU,CAACG,OAAf,EAAwB;AACtB,uBAAO,CAACmF,MAAD,EAASsY,EAAT,CAAP;AACD;;AAED,qBAAO,CAACtY,MAAD,EAASqY,IAAT,CAAP;AACD;AACF;AACF,SA1BD,MA0BO;AACL;AACAja,UAAAA,GAAG,CAAC2K,UAAJ,GAAiB,IAAjB;AACA3K,UAAAA,GAAG,CAACtC,UAAJ,GAAiB,KAAjB;AACAsC,UAAAA,GAAG,CAAC4K,WAAJ,GAAkB,KAAlB;AACA9O,UAAAA,UAAU,CAACwD,MAAX,CAAkBF,EAAlB,EAAsB,iBAAtB,EAAyC;AAACG,YAAAA,IAAI,EAAE,QAAP;AAAiB4a,YAAAA,OAAO,EAAE;AAA1B,WAAzC;AACD;;AAED,eAAOrZ,IAAI,GAAG,CAACoZ,EAAD,EAAKD,IAAL,CAAH,GAAgB,CAACA,IAAD,EAAOC,EAAP,CAA3B;AACD,OAhHW;AAiHZE,MAAAA,QAAQ,EAAE,UAAShb,EAAT,EAAa+Z,KAAb,EAAoB7c,UAApB,EAAgC0D,GAAhC,EAAqC;AAC7C,YAAIqa,GAAG,GAAGC,UAAU,CAAClb,EAAD,EAAKY,GAAL,EAAU1D,UAAU,CAACiP,iBAArB,CAApB;;AACA,YAAI8O,GAAJ,EAAS;AACP,iBAAO/d,UAAU,CAACC,QAAX,GAAsB;AAAEsF,YAAAA,IAAI,EAAEwY,GAAG,CAACxY,IAAZ;AAAkBC,YAAAA,EAAE,EAAEuX,+BAA+B,CAACja,EAAE,CAACuC,OAAH,CAAW0Y,GAAG,CAACxY,IAAf,CAAD;AAArD,WAAtB,GAAsGwY,GAA7G;AACD;;AACD,eAAO,IAAP;AACD,OAvHW;AAwHZE,MAAAA,yBAAyB,EAAE,UAASnb,EAAT,EAAa+Z,KAAb,EAAoB7c,UAApB,EAAgC0D,GAAhC,EAAqC;AAC9D,YAAIA,GAAG,CAAC4K,WAAJ,IAAmBtO,UAAU,CAACc,QAAlC,EAA4C;AAC1C,cAAI2N,GAAG,GAAG/K,GAAG,CAAC+K,GAAd;AACA,iBAAO,CACLmM,mBAAmB,CAAC9X,EAAD,EAAKH,GAAG,CAAC8L,GAAG,CAACnJ,MAAJ,CAAWC,IAAZ,EAAkBkJ,GAAG,CAAC1D,IAAJ,CAASvF,EAA3B,CAAR,CADd,EAELoV,mBAAmB,CAAC9X,EAAD,EAAKH,GAAG,CAAC8L,GAAG,CAAC1D,IAAJ,CAASxF,IAAV,EAAgBkJ,GAAG,CAACnJ,MAAJ,CAAWE,EAA3B,CAAR,CAFd,CAAP;AAID,SAND,MAMO;AACL,iBAAQ,CAAC9B,GAAG,CAAC+K,GAAJ,CAAQ1D,IAAT,EAAerH,GAAG,CAAC+K,GAAJ,CAAQnJ,MAAvB,CAAR;AACD;AACF,OAlIW;AAmIZ4Y,MAAAA,UAAU,EAAE,UAASpb,EAAT,EAAaiI,IAAb,EAAmB/K,UAAnB,EAA+B0D,GAA/B,EAAoC;AAC9C,YAAIya,IAAI,GAAGpT,IAAX;;AACA,aAAK,IAAI9F,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGjF,UAAU,CAAC6U,MAA/B,EAAuC5P,CAAC,EAAxC,EAA4C;AAC1C,cAAIwG,MAAM,GAAG0S,IAAb;;AACA,eAAK,IAAIhY,GAAT,IAAgBzC,GAAG,CAACkC,KAApB,EAA2B;AACzB,gBAAI,CAAC8D,WAAW,CAACvD,GAAD,CAAhB,EAAuB;AACrB;AACD;;AACD,gBAAI8F,IAAI,GAAGvI,GAAG,CAACkC,KAAJ,CAAUO,GAAV,EAAe0F,IAAf,EAAX;AACA,gBAAIuS,gBAAgB,GAAIpe,UAAU,CAACG,OAAZ,GACrBqb,cAAc,CAACvP,IAAD,EAAOR,MAAP,CADO,GACU+P,cAAc,CAAC/P,MAAD,EAASQ,IAAT,CAD/C;;AAGA,gBAAImS,gBAAJ,EAAsB;AACpB;AACD;;AACD,gBAAIpe,UAAU,CAACC,QAAX,IAAwBgM,IAAI,CAAC1G,IAAL,IAAakG,MAAM,CAAClG,IAAhD,EAAuD;AACrD;AACD;;AAED,gBAAI8Y,KAAK,GAAGvS,WAAW,CAACL,MAAD,EAAS0S,IAAT,CAAvB;AACA,gBAAIG,OAAO,GAAIte,UAAU,CAACG,OAAZ,GACZoe,eAAe,CAAC9S,MAAD,EAASQ,IAAT,EAAekS,IAAf,CADH,GAEZI,eAAe,CAACJ,IAAD,EAAOlS,IAAP,EAAaR,MAAb,CAFjB;;AAIA,gBAAI4S,KAAK,IAAIC,OAAb,EAAsB;AACpBH,cAAAA,IAAI,GAAGlS,IAAP;AACD;AACF;AACF;;AAED,YAAIjM,UAAU,CAACC,QAAf,EAAyB;AACvB;AACA;AACA;AACAke,UAAAA,IAAI,GAAGxb,GAAG,CAACwb,IAAI,CAAC5Y,IAAN,EAAYwX,+BAA+B,CAACja,EAAE,CAACuC,OAAH,CAAW8Y,IAAI,CAAC5Y,IAAhB,CAAD,CAA3C,CAAV;AACD;;AACD,eAAO4Y,IAAP;AACD,OAxKW;AAyKZK,MAAAA,gBAAgB,EAAE,UAASpB,GAAT,EAAcrS,IAAd,EAAoB/K,UAApB,EAAgC;AAChD,YAAIqd,GAAG,GAAGtS,IAAV;AACA,YAAI8J,MAAM,GAAG7U,UAAU,CAAC6U,MAAxB;AACA,YAAIrP,EAAE,GAAGxF,UAAU,CAACG,OAAX,GAAqBkd,GAAG,CAAC7X,EAAJ,GAASqP,MAA9B,GAAuCwI,GAAG,CAAC7X,EAAJ,GAASqP,MAAzD;AACA,eAAOlS,GAAG,CAAC0a,GAAG,CAAC9X,IAAL,EAAWC,EAAX,CAAV;AACD,OA9KW;AA+KZiZ,MAAAA,WAAW,EAAE,UAAS3b,EAAT,EAAaiI,IAAb,EAAmB/K,UAAnB,EAA+B0D,GAA/B,EAAoC;AAC/C,YAAI2Z,GAAG,GAAGtS,IAAV;AACA,YAAI2T,KAAK,GAAGrB,GAAG,CAAC7X,EAAhB,CAF+C,CAG/C;AACA;AACA;AACA;AACA;;AACA,gBAAQ9B,GAAG,CAACwK,UAAZ;AACE,eAAK,KAAKuQ,WAAV;AACA,eAAK,KAAKE,kBAAV;AACA,eAAK,KAAKC,YAAV;AACA,eAAK,KAAKC,YAAV;AACA,eAAK,KAAKC,SAAV;AACEJ,YAAAA,KAAK,GAAGhb,GAAG,CAACsK,QAAZ;AACA;;AACF;AACEtK,YAAAA,GAAG,CAACsK,QAAJ,GAAe0Q,KAAf;AATJ;;AAWA,YAAI7J,MAAM,GAAG7U,UAAU,CAAC6U,MAAX,IAAmB7U,UAAU,CAACS,YAAX,IAAyB,CAA5C,CAAb;AACA,YAAI8E,IAAI,GAAGvF,UAAU,CAACG,OAAX,GAAqBkd,GAAG,CAAC9X,IAAJ,GAAWsP,MAAhC,GAAyCwI,GAAG,CAAC9X,IAAJ,GAAWsP,MAA/D;AACA,YAAIkK,KAAK,GAAGjc,EAAE,CAAC0G,SAAH,EAAZ;AACA,YAAIwV,IAAI,GAAGlc,EAAE,CAAC2G,QAAH,EAAX;AACA,YAAIwV,IAAI,GAAGnc,EAAE,CAACoc,QAAH,CAAY7B,GAAZ,EAAkBrd,UAAU,CAACG,OAAX,GAAqB0U,MAArB,GAA8B,CAACA,MAAjD,EAA0D,MAA1D,EAAkEnR,GAAG,CAACuK,SAAtE,CAAX;AACA,YAAIkR,aAAa,GAAGnf,UAAU,CAACG,OAAX,GAAqB8e,IAAI,CAAC1Z,IAAL,GAAYA,IAAjC,GAAwC0Z,IAAI,CAAC1Z,IAAL,GAAYA,IAAxE;;AACA,YAAI4Z,aAAJ,EAAmB;AACjB5Z,UAAAA,IAAI,GAAG0Z,IAAI,CAAC1Z,IAAZ;AACAmZ,UAAAA,KAAK,GAAGO,IAAI,CAACzZ,EAAb;AACD,SA5B8C,CA6B/C;AACA;;;AACA,YAAID,IAAI,GAAGwZ,KAAP,IAAgB1B,GAAG,CAAC9X,IAAJ,IAAYwZ,KAAhC,EAAsC;AACpC,iBAAO,KAAKK,iBAAL,CAAuBtc,EAAvB,EAA2BiI,IAA3B,EAAiC/K,UAAjC,EAA6C0D,GAA7C,CAAP;AACD,SAFD,MAEO,IAAI6B,IAAI,GAAGyZ,IAAP,IAAe3B,GAAG,CAAC9X,IAAJ,IAAYyZ,IAA/B,EAAoC;AACvC,iBAAOF,SAAS,CAAChc,EAAD,EAAKiI,IAAL,EAAW/K,UAAX,EAAuB0D,GAAvB,EAA4B,IAA5B,CAAhB;AACH;;AACD,YAAI1D,UAAU,CAACQ,WAAf,EAA2B;AACzBke,UAAAA,KAAK,GAAC3B,+BAA+B,CAACja,EAAE,CAACuC,OAAH,CAAWE,IAAX,CAAD,CAArC;AACA7B,UAAAA,GAAG,CAACsK,QAAJ,GAAe0Q,KAAf;AACD;;AACDhb,QAAAA,GAAG,CAACuK,SAAJ,GAAgBnL,EAAE,CAACuc,UAAH,CAAc1c,GAAG,CAAC4C,IAAD,EAAOmZ,KAAP,CAAjB,EAA+B,KAA/B,EAAsC/F,IAAtD;AACA,eAAOhW,GAAG,CAAC4C,IAAD,EAAOmZ,KAAP,CAAV;AACD,OAzNW;AA0NZC,MAAAA,kBAAkB,EAAE,UAAS7b,EAAT,EAAaiI,IAAb,EAAmB/K,UAAnB,EAA+B0D,GAA/B,EAAoC;AACtD,YAAI2Z,GAAG,GAAGtS,IAAV;;AACA,gBAAQrH,GAAG,CAACwK,UAAZ;AACE,eAAK,KAAKyQ,kBAAV;AACA,eAAK,KAAKC,YAAV;AACA,eAAK,KAAKH,WAAV;AACA,eAAK,KAAKI,YAAV;AACA,eAAK,KAAKC,SAAV;AACE;;AACF;AACEpb,YAAAA,GAAG,CAACuK,SAAJ,GAAgBnL,EAAE,CAACuc,UAAH,CAAchC,GAAd,EAAkB,KAAlB,EAAyB1E,IAAzC;AARJ;;AAUA,YAAI9D,MAAM,GAAG7U,UAAU,CAAC6U,MAAxB;AACA,YAAIyK,GAAG,GAACxc,EAAE,CAACoc,QAAH,CAAY7B,GAAZ,EAAiBrd,UAAU,CAACG,OAAX,GAAqB0U,MAArB,GAA8B,CAACA,MAAhD,EAAwD,MAAxD,EAA+DnR,GAAG,CAACuK,SAAnE,CAAR;;AACA,YAAIqR,GAAG,CAACC,OAAR,EAAiB;AACf,cAAIvf,UAAU,CAACG,OAAf,EAAwB;AACtB,gBAAIqf,cAAc,GAAG1c,EAAE,CAACuc,UAAH,CAAcC,GAAd,EAAmB,KAAnB,CAArB;AACA,gBAAIG,UAAU,GAAG;AAAE7G,cAAAA,GAAG,EAAE4G,cAAc,CAAC5G,GAAf,GAAqB,CAA5B;AAA+BD,cAAAA,IAAI,EAAEjV,GAAG,CAACuK;AAAzC,aAAjB;AACA,gBAAIqR,GAAG,GAAGxc,EAAE,CAAC4c,UAAH,CAAcD,UAAd,EAA0B,KAA1B,CAAV;AACD,WAJD,MAIO;AACL,gBAAIE,SAAS,GAAG7c,EAAE,CAACuc,UAAH,CAAc1c,GAAG,CAACG,EAAE,CAAC0G,SAAH,EAAD,EAAiB,CAAjB,CAAjB,EAAsC,KAAtC,CAAhB;AACAmW,YAAAA,SAAS,CAAChH,IAAV,GAAiBjV,GAAG,CAACuK,SAArB;AACAqR,YAAAA,GAAG,GAAGxc,EAAE,CAAC4c,UAAH,CAAcC,SAAd,EAAyB,KAAzB,CAAN;AACD;AACF;;AACDjc,QAAAA,GAAG,CAACsK,QAAJ,GAAesR,GAAG,CAAC9Z,EAAnB;AACA,eAAO8Z,GAAP;AACD,OArPW;AAsPZM,MAAAA,UAAU,EAAE,UAAS9c,EAAT,EAAaiI,IAAb,EAAmB/K,UAAnB,EAA+B;AACzC;AACA;AACA;AACA,YAAI6b,QAAQ,GAAG9Q,IAAf;AACA,YAAI8J,MAAM,GAAG7U,UAAU,CAAC6U,MAAxB;AACA,eAAO/R,EAAE,CAACoc,QAAH,CAAYrD,QAAZ,EAAuB7b,UAAU,CAACG,OAAX,GAAqB0U,MAArB,GAA8B,CAACA,MAAtD,EAA+D,MAA/D,CAAP;AACD,OA7PW;AA8PZgL,MAAAA,eAAe,EAAE,UAAS/c,EAAT,EAAaiI,IAAb,EAAmB/K,UAAnB,EAA+B;AAC9C,YAAIoW,GAAG,GAAGpW,UAAU,CAACG,OAAX,GAAqB,CAArB,GAAyB,CAAC,CAApC;AACA,eAAO2f,aAAa,CAAChd,EAAD,EAAKiI,IAAL,EAAW/K,UAAU,CAAC6U,MAAtB,EAA8BuB,GAA9B,CAApB;AACD,OAjQW;AAkQZ2J,MAAAA,cAAc,EAAE,UAASjd,EAAT,EAAaiI,IAAb,EAAmB/K,UAAnB,EAA+B;AAC7C,YAAIoW,GAAG,GAAGpW,UAAU,CAACG,OAAX,GAAqB,CAArB,GAAyB,CAAC,CAApC;AACA,eAAO6f,YAAY,CAACld,EAAD,EAAKiI,IAAL,EAAW/K,UAAU,CAAC6U,MAAtB,EAA8BuB,GAA9B,CAAnB;AACD,OArQW;AAsQZwI,MAAAA,YAAY,EAAE,UAAS9b,EAAT,EAAaiI,IAAb,EAAmB/K,UAAnB,EAA+B0D,GAA/B,EAAoC;AAChD,YAAIuc,SAAS,GAAGnd,EAAE,CAACqV,aAAH,EAAhB;AACA,YAAI2D,MAAM,GAAG,IAAb;AACA,YAAIjH,MAAM,GAAG7U,UAAU,CAAC6U,MAAxB;;AACA,YAAI,CAACA,MAAL,EAAa;AACXA,UAAAA,MAAM,GAAGoL,SAAS,CAACC,YAAV,IAA0B,IAAIpd,EAAE,CAACqd,iBAAH,EAA9B,CAAT;AACD;;AACD,YAAIC,IAAI,GAAGtd,EAAE,CAACuc,UAAH,CAActU,IAAd,EAAoB,OAApB,CAAX;AACA/K,QAAAA,UAAU,CAAC6U,MAAX,GAAoBA,MAApB;AACA,YAAIiH,MAAM,GAAGV,OAAO,CAACuD,kBAAR,CAA2B7b,EAA3B,EAA+BiI,IAA/B,EAAqC/K,UAArC,EAAiD0D,GAAjD,CAAb;;AACA,YAAI,CAACoY,MAAL,EAAa;AACX,iBAAO,IAAP;AACD;;AACD,YAAIuE,IAAI,GAAGvd,EAAE,CAACuc,UAAH,CAAcvD,MAAd,EAAsB,OAAtB,CAAX;AACAhZ,QAAAA,EAAE,CAAC4V,QAAH,CAAY,IAAZ,EAAkBuH,SAAS,CAACrH,GAAV,GAAgByH,IAAI,CAACzH,GAArB,GAA2BwH,IAAI,CAACxH,GAAlD;AACA,eAAOkD,MAAP;AACD,OAtRW;AAuRZwE,MAAAA,WAAW,EAAE,UAASxd,EAAT,EAAaiI,IAAb,EAAmB/K,UAAnB,EAA+B;AAC1C,eAAOugB,UAAU,CAACzd,EAAD,EAAKiI,IAAL,EAAW/K,UAAU,CAAC6U,MAAtB,EAA8B,CAAC,CAAC7U,UAAU,CAACG,OAA3C,EACb,CAAC,CAACH,UAAU,CAACI,OADA,EACS,CAAC,CAACJ,UAAU,CAACK,OADtB,CAAjB;AAED,OA1RW;AA2RZmgB,MAAAA,iBAAiB,EAAE,UAAS1d,EAAT,EAAa+Z,KAAb,EAAoB7c,UAApB,EAAgC;AACjD,YAAI6U,MAAM,GAAG7U,UAAU,CAAC6U,MAAxB;AACA,YAAIiH,MAAM,GAAG2E,eAAe,CAAC3d,EAAD,EAAK+R,MAAL,EAAa7U,UAAU,CAACG,OAAxB,EACxBH,UAAU,CAACiP,iBADa,CAA5B;AAEA,YAAID,SAAS,GAAGhP,UAAU,CAACG,OAAX,GAAqB,CAAC,CAAtB,GAA0B,CAA1C;AACAugB,QAAAA,yBAAyB,CAAC1R,SAAD,EAAYhP,UAAZ,CAAzB;AACA,YAAI,CAAC8b,MAAL,EAAa,OAAO,IAAP;AACbA,QAAAA,MAAM,CAACtW,EAAP,IAAawJ,SAAb;AACA,eAAO8M,MAAP;AACD,OApSW;AAqSZ2E,MAAAA,eAAe,EAAE,UAAS3d,EAAT,EAAaiI,IAAb,EAAmB/K,UAAnB,EAA+B;AAC9C,YAAI6U,MAAM,GAAG7U,UAAU,CAAC6U,MAAxB;AACA6L,QAAAA,yBAAyB,CAAC,CAAD,EAAI1gB,UAAJ,CAAzB;AACA,eAAOygB,eAAe,CAAC3d,EAAD,EAAK+R,MAAL,EAAa7U,UAAU,CAACG,OAAxB,EAClBH,UAAU,CAACiP,iBADO,CAAf,IAC8BlE,IADrC;AAED,OA1SW;AA2SZ4V,MAAAA,YAAY,EAAE,UAAS7d,EAAT,EAAaiI,IAAb,EAAmB/K,UAAnB,EAA+B;AAC3C,YAAI6U,MAAM,GAAG7U,UAAU,CAAC6U,MAAxB;AACA,eAAO+L,UAAU,CAAC9d,EAAD,EAAK+R,MAAL,EAAa7U,UAAU,CAACG,OAAxB,EACbH,UAAU,CAACiP,iBADE,CAAV,IAC8BlE,IADrC;AAED,OA/SW;AAgTZ8T,MAAAA,YAAY,EAAE,UAAS/b,EAAT,EAAaiI,IAAb,EAAmB/K,UAAnB,EAA+B0D,GAA/B,EAAoC;AAChD,YAAImR,MAAM,GAAG7U,UAAU,CAAC6U,MAAxB,CADgD,CAEhD;;AACAnR,QAAAA,GAAG,CAACsK,QAAJ,GAAe6G,MAAM,GAAG,CAAxB;AACAnR,QAAAA,GAAG,CAACuK,SAAJ,GAAgBnL,EAAE,CAACuc,UAAH,CAActU,IAAd,EAAmB,KAAnB,EAA0B4N,IAA1C;AACA,eAAOkG,YAAY,CAAC/b,EAAD,EAAK+R,MAAL,CAAnB;AACD,OAtTW;AAuTZiK,MAAAA,SAAS,EAAE,UAAShc,EAAT,EAAaiI,IAAb,EAAmB/K,UAAnB,EAA+B0D,GAA/B,EAAoC;AAC7C,eAAOob,SAAS,CAAChc,EAAD,EAAKiI,IAAL,EAAW/K,UAAX,EAAuB0D,GAAvB,EAA4B,KAA5B,CAAhB;AACD,OAzTW;AA0TZmd,MAAAA,iCAAiC,EAAE,UAAS/d,EAAT,EAAaiI,IAAb,EAAmB;AACpD;AACA;AACA,YAAIU,MAAM,GAAGV,IAAb;AACA,eAAOpI,GAAG,CAAC8I,MAAM,CAAClG,IAAR,EACCwX,+BAA+B,CAACja,EAAE,CAACuC,OAAH,CAAWoG,MAAM,CAAClG,IAAlB,CAAD,CADhC,CAAV;AAED,OAhUW;AAiUZub,MAAAA,mBAAmB,EAAE,UAAShe,EAAT,EAAaiI,IAAb,EAAmB;AACtC,YAAIU,MAAM,GAAGV,IAAb;AACA,YAAIxF,IAAI,GAAGkG,MAAM,CAAClG,IAAlB;AACA,YAAIC,EAAE,GAAGiG,MAAM,CAACjG,EAAhB;AACA,YAAIub,QAAQ,GAAGje,EAAE,CAACuC,OAAH,CAAWE,IAAX,CAAf;AACA,YAAIyb,MAAJ;;AACA,eAAOxb,EAAE,GAAGub,QAAQ,CAAC1e,MAArB,EAA6BmD,EAAE,EAA/B,EAAmC;AACjCwb,UAAAA,MAAM,GAAGD,QAAQ,CAAC1Z,MAAT,CAAgB7B,EAAhB,CAAT;;AACA,cAAIwb,MAAM,IAAIpX,iBAAiB,CAACoX,MAAD,CAA/B,EAAyC;AACvC,gBAAI7c,KAAK,GAAGrB,EAAE,CAACme,cAAH,CAAkBte,GAAG,CAAC4C,IAAD,EAAOC,EAAE,GAAG,CAAZ,CAArB,CAAZ;;AACA,gBAAIrB,KAAK,KAAK,QAAV,IAAsBA,KAAK,KAAK,SAApC,EAA+C;AAC7C;AACD;AACF;AACF;;AACD,YAAIqB,EAAE,GAAGub,QAAQ,CAAC1e,MAAlB,EAA0B;AACxB;AACA,cAAI6e,EAAE,GAAI1b,EAAE,KAAK,GAAP,IAAcA,EAAE,KAAK,GAAtB,GAA6B,aAA7B,GAA6C,WAAtD;AACA,cAAI2b,OAAO,GAAGre,EAAE,CAACse,mBAAH,CAAuBze,GAAG,CAAC4C,IAAD,EAAOC,EAAP,CAA1B,EAAsC;AAAC6b,YAAAA,YAAY,EAAEH;AAAf,WAAtC,CAAd;AACA,iBAAOC,OAAO,CAACvD,EAAf;AACD,SALD,MAKO;AACL,iBAAOnS,MAAP;AACD;AACF,OAxVW;AAyVZ2T,MAAAA,iBAAiB,EAAE,UAAShC,GAAT,EAAcrS,IAAd,EAAoB;AACrC,eAAOpI,GAAG,CAACoI,IAAI,CAACxF,IAAN,EAAY,CAAZ,CAAV;AACD,OA3VW;AA4VZ+b,MAAAA,0BAA0B,EAAE,UAASxe,EAAT,EAAa+Z,KAAb,EAAoB7c,UAApB,EAAgC;AAC1D,YAAIuhB,OAAO,GAAGvhB,UAAU,CAACG,OAAX,GAAqB2C,EAAE,CAAC2G,QAAH,EAArB,GAAqC3G,EAAE,CAAC0G,SAAH,EAAnD;;AACA,YAAIxJ,UAAU,CAAC0X,gBAAf,EAAiC;AAC/B6J,UAAAA,OAAO,GAAGvhB,UAAU,CAAC6U,MAAX,GAAoB/R,EAAE,CAACkB,SAAH,CAAa,iBAAb,CAA9B;AACD;;AACD,eAAOrB,GAAG,CAAC4e,OAAD,EACCxE,+BAA+B,CAACja,EAAE,CAACuC,OAAH,CAAWkc,OAAX,CAAD,CADhC,CAAV;AAED,OAnWW;AAoWZC,MAAAA,sBAAsB,EAAE,UAAS1e,EAAT,EAAaiI,IAAb,EAAmB/K,UAAnB,EAA+B0D,GAA/B,EAAoC;AAC1D;AACA;AACA,YAAI+d,aAAa,GAAG;AAAC,eAAK,GAAN;AAAW,eAAK,GAAhB;AACC,eAAK,GADN;AACW,eAAK,GADhB;AAEC,eAAK,GAFN;AAEW,eAAK,GAFhB;AAGC,eAAK,GAHN;AAGW,eAAK;AAHhB,SAApB;AAIA,YAAIC,UAAU,GAAG;AAAC,gBAAM,IAAP;AAAa,eAAK,IAAlB;AAAwB,eAAK;AAA7B,SAAjB;AAEA,YAAI5K,SAAS,GAAG9W,UAAU,CAACiP,iBAA3B,CAT0D,CAU1D;AACA;;AACA,YAAI6H,SAAS,IAAI,GAAjB,EAAsB;AACpBA,UAAAA,SAAS,GAAG,GAAZ;AACD,SAFD,MAEO,IAAIA,SAAS,IAAI,GAAjB,EAAsB;AAC3BA,UAAAA,SAAS,GAAG,GAAZ;AACD,SAhByD,CAkB1D;AACA;AACA;AACA;AACA;;;AACA,YAAIxW,SAAS,GAAG,CAACN,UAAU,CAACgC,eAA5B;AAEA,YAAIma,GAAJ;;AACA,YAAIsF,aAAa,CAAC3K,SAAD,CAAjB,EAA8B;AAC5BqF,UAAAA,GAAG,GAAGwF,qBAAqB,CAAC7e,EAAD,EAAKiI,IAAL,EAAW+L,SAAX,EAAsBxW,SAAtB,CAA3B;AACD,SAFD,MAEO,IAAIohB,UAAU,CAAC5K,SAAD,CAAd,EAA2B;AAChCqF,UAAAA,GAAG,GAAGyF,mBAAmB,CAAC9e,EAAD,EAAKiI,IAAL,EAAW+L,SAAX,EAAsBxW,SAAtB,CAAzB;AACD,SAFM,MAEA,IAAIwW,SAAS,KAAK,GAAlB,EAAuB;AAC5BqF,UAAAA,GAAG,GAAG/B,qBAAqB,CAACtX,EAAD,EAAKxC,SAAL,EAAgB;AAAK;AAArB,YACgB;AAAK;AADrB,WAA3B;AAED,SAHM,MAGA,IAAIwW,SAAS,KAAK,GAAlB,EAAuB;AAC5BqF,UAAAA,GAAG,GAAG/B,qBAAqB,CAACtX,EAAD,EAAKxC,SAAL,EAAgB;AAAK;AAArB,YACgB;AAAM;AADtB,WAA3B;AAED,SAHM,MAGA,IAAIwW,SAAS,KAAK,GAAlB,EAAuB;AAC5BqF,UAAAA,GAAG,GAAG2D,aAAa,CAAChd,EAAD,EAAKiI,IAAL,EAAW/K,UAAU,CAAC6U,MAAtB,EAA8B,CAA9B,EAAiCvU,SAAjC,CAAnB;AACAN,UAAAA,UAAU,CAACC,QAAX,GAAsB,IAAtB;;AACA,cAAIyD,GAAG,CAAC2K,UAAR,EAAoB;AAClB,gBAAI,CAAC3K,GAAG,CAACtC,UAAT,EAAqB;AAAEsC,cAAAA,GAAG,CAACtC,UAAJ,GAAiB,IAAjB;AAAwB;AAChD,WAFD,MAEO;AACL,gBAAIJ,YAAY,GAAG0C,GAAG,CAACkK,UAAJ,CAAe5M,YAAlC;;AACA,gBAAIA,YAAJ,EAAkB;AAAEA,cAAAA,YAAY,CAACf,QAAb,GAAwB,IAAxB;AAA+B;;AACnDkc,YAAAA,GAAG,CAAC7B,GAAJ,CAAQ/U,IAAR;AACD;AACF,SAVM,MAUA,IAAIuR,SAAS,KAAK,GAAlB,EAAuB;AAC5BqF,UAAAA,GAAG,GAAG0F,oBAAoB,CAAC/e,EAAD,EAAKiI,IAAL,EAAWzK,SAAX,CAA1B;AACD,SAFM,MAEA;AACL;AACA,iBAAO,IAAP;AACD;;AAED,YAAI,CAACwC,EAAE,CAACW,KAAH,CAASC,GAAT,CAAa2K,UAAlB,EAA8B;AAC5B,iBAAO,CAAC8N,GAAG,CAACzT,KAAL,EAAYyT,GAAG,CAAC7B,GAAhB,CAAP;AACD,SAFD,MAEO;AACL,iBAAOwH,eAAe,CAAChf,EAAD,EAAKqZ,GAAG,CAACzT,KAAT,EAAgByT,GAAG,CAAC7B,GAApB,CAAtB;AACD;AACF,OA9ZW;AAgaZyH,MAAAA,yBAAyB,EAAE,UAASjf,EAAT,EAAaiI,IAAb,EAAmB/K,UAAnB,EAA+B;AACxD,YAAIgiB,UAAU,GAAG7U,cAAc,CAAC4B,mBAAhC;AACA,YAAI8F,MAAM,GAAG7U,UAAU,CAAC6U,MAAxB;AACA,YAAI1U,OAAO,GAAGH,UAAU,CAACG,OAAX,KAAuB6hB,UAAU,CAAC7hB,OAAhD;AACA,YAAI6O,SAAS,GAAG,CAACgT,UAAU,CAAChT,SAAX,GAAuB,CAAvB,GAA2B,CAA5B,KAAkC7O,OAAO,GAAG,CAAC,CAAJ,GAAQ,CAAjD,CAAhB;AACA2C,QAAAA,EAAE,CAACmf,KAAH,CAAS,CAACjT,SAAV,EAAqB,MAArB;AACAhP,QAAAA,UAAU,CAACM,SAAX,GAAuBH,OAAO,GAAG,IAAH,GAAU,KAAxC;AACA,YAAI2b,MAAM,GAAG2E,eAAe,CAAC3d,EAAD,EAAK+R,MAAL,EAAa1U,OAAb,EAAsB6hB,UAAU,CAAC/S,iBAAjC,CAA5B;;AACA,YAAI,CAAC6M,MAAL,EAAa;AACXhZ,UAAAA,EAAE,CAACmf,KAAH,CAASjT,SAAT,EAAoB,MAApB;AACA,iBAAOjE,IAAP;AACD;;AACD+Q,QAAAA,MAAM,CAACtW,EAAP,IAAawJ,SAAb;AACA,eAAO8M,MAAP;AACD;AA9aW,KAAd;;AAibA,aAAS1H,YAAT,CAAsB7R,IAAtB,EAA4B2f,EAA5B,EAAgC;AAC9B9G,MAAAA,OAAO,CAAC7Y,IAAD,CAAP,GAAgB2f,EAAhB;AACD;;AAED,aAASC,SAAT,CAAmBpc,GAAnB,EAAwBqc,KAAxB,EAA+B;AAC7B,UAAIlY,GAAG,GAAG,EAAV;;AACA,WAAK,IAAIjF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGmd,KAApB,EAA2Bnd,CAAC,EAA5B,EAAgC;AAC9BiF,QAAAA,GAAG,CAACzE,IAAJ,CAASM,GAAT;AACD;;AACD,aAAOmE,GAAP;AACD;AACD;AACJ;AACA;AACA;AACA;;;AACI,QAAIwS,SAAS,GAAG;AACd2F,MAAAA,MAAM,EAAE,UAASvf,EAAT,EAAawf,IAAb,EAAmBxd,MAAnB,EAA2B;AACjC,YAAIyd,SAAJ,EAAetN,IAAf;AACA,YAAIvR,GAAG,GAAGZ,EAAE,CAACW,KAAH,CAASC,GAAnB;AACA,YAAI4B,MAAM,GAAGR,MAAM,CAAC,CAAD,CAAN,CAAUQ,MAAvB;AAAA,YACIyF,IAAI,GAAGjG,MAAM,CAAC,CAAD,CAAN,CAAUiG,IADrB;;AAEA,YAAI,CAACrH,GAAG,CAAC2K,UAAT,EAAqB;AACnB4G,UAAAA,IAAI,GAAGnS,EAAE,CAAC0f,QAAH,CAAYld,MAAZ,EAAoByF,IAApB,CAAP;AACA,cAAI0X,SAAS,GAAG/e,GAAG,CAACoK,kBAAJ,IAA0B,EAA1C;;AACA,cAAI2U,SAAS,CAAC1iB,MAAV,IAAoB,aAApB,IAAqC,CAACgK,kBAAkB,CAACkL,IAAD,CAA5D,EAAoE;AAClE;AACA,gBAAI3C,KAAK,GAAI,MAAD,CAASC,IAAT,CAAc0C,IAAd,CAAZ;;AACA,gBAAI3C,KAAK,IAAImQ,SAAS,CAACziB,UAAnB,IAAiCyiB,SAAS,CAACziB,UAAV,CAAqBG,OAA1D,EAAmE;AACjE4K,cAAAA,IAAI,GAAG9C,YAAY,CAAC8C,IAAD,EAAO,CAAP,EAAU,CAAEuH,KAAK,CAAC,CAAD,CAAL,CAASjQ,MAArB,CAAnB;AACA4S,cAAAA,IAAI,GAAGA,IAAI,CAAC7D,KAAL,CAAW,CAAX,EAAc,CAAEkB,KAAK,CAAC,CAAD,CAAL,CAASjQ,MAAzB,CAAP;AACD;AACF;;AACD,cAAIqgB,WAAW,GAAG,IAAI/f,GAAJ,CAAQ2C,MAAM,CAACC,IAAP,GAAc,CAAtB,EAAyBod,MAAM,CAACC,SAAhC,CAAlB;AACA,cAAIC,WAAW,GAAG/f,EAAE,CAAC0G,SAAH,MAAkB1G,EAAE,CAAC2G,QAAH,EAApC;;AACA,cAAIsB,IAAI,CAACxF,IAAL,GAAYzC,EAAE,CAAC2G,QAAH,EAAZ,IAA6B6Y,IAAI,CAACriB,QAAlC,IAA8C,CAAC4iB,WAAnD,EAAgE;AAC9D/f,YAAAA,EAAE,CAACuQ,YAAH,CAAgB,EAAhB,EAAoBqP,WAApB,EAAiC3X,IAAjC;AACD,WAFD,MAEO;AACLjI,YAAAA,EAAE,CAACuQ,YAAH,CAAgB,EAAhB,EAAoB/N,MAApB,EAA4ByF,IAA5B;AACD;;AACD,cAAIuX,IAAI,CAACriB,QAAT,EAAmB;AACjB;AACA,gBAAI,CAAC4iB,WAAL,EAAkB;AAChB/f,cAAAA,EAAE,CAACkF,SAAH,CAAa0a,WAAb;AACAljB,cAAAA,UAAU,CAACsjB,QAAX,CAAoBC,gBAApB,CAAqCjgB,EAArC;AACD,aALgB,CAMjB;;;AACAwC,YAAAA,MAAM,CAACE,EAAP,GAAYmd,MAAM,CAACC,SAAnB;AACD;;AACDL,UAAAA,SAAS,GAAGjd,MAAZ;AACD,SA5BD,MA4BO,IAAIgd,IAAI,CAAC3gB,QAAT,EAAmB;AACtBoJ,UAAAA,IAAI,CAACvF,EAAL,GAAUmd,MAAM,CAACC,SAAjB;AACA7X,UAAAA,IAAI,CAACxF,IAAL;AACAzC,UAAAA,EAAE,CAACkgB,YAAH,CAAgB1d,MAAhB,EAAwByF,IAAxB;AACAkK,UAAAA,IAAI,GAAGnS,EAAE,CAACmgB,YAAH,EAAP;AACAngB,UAAAA,EAAE,CAACogB,gBAAH,CAAoB,EAApB;AACAX,UAAAA,SAAS,GAAGjd,MAAZ;AACH,SAPM,MAOA;AACL2P,UAAAA,IAAI,GAAGnS,EAAE,CAACmgB,YAAH,EAAP;AACA,cAAIE,WAAW,GAAGhB,SAAS,CAAC,EAAD,EAAKrd,MAAM,CAACzC,MAAZ,CAA3B;AACAS,UAAAA,EAAE,CAACsgB,iBAAH,CAAqBD,WAArB;AACAZ,UAAAA,SAAS,GAAGvG,SAAS,CAAClX,MAAM,CAAC,CAAD,CAAN,CAAUiG,IAAX,EAAiBjG,MAAM,CAAC,CAAD,CAAN,CAAUQ,MAA3B,CAArB;AACD;;AACD6H,QAAAA,cAAc,CAACI,kBAAf,CAAkC8H,QAAlC,CACIiN,IAAI,CAACjV,YADT,EACuB,QADvB,EACiC4H,IADjC,EAEIqN,IAAI,CAACriB,QAFT,EAEmB6E,MAAM,CAACzC,MAAP,GAAgB,CAFnC;AAGA8F,QAAAA,OAAO,CAACC,eAAR,CAAwBtF,EAAxB,EAA4B;AAACiI,UAAAA,IAAI,EAAEwX;AAAP,SAA5B,EAA+Czf,EAAE,CAACW,KAAH,CAASC,GAAxD;AACD,OAnDa;AAoDd;AACA,gBAAU,UAASZ,EAAT,EAAawf,IAAb,EAAmBxd,MAAnB,EAA2B;AACnC,YAAIyd,SAAJ,EAAetN,IAAf;AACA,YAAIvR,GAAG,GAAGZ,EAAE,CAACW,KAAH,CAASC,GAAnB;;AACA,YAAI,CAACA,GAAG,CAAC4K,WAAT,EAAsB;AACpB,cAAIhJ,MAAM,GAAGR,MAAM,CAAC,CAAD,CAAN,CAAUQ,MAAvB;AAAA,cACIyF,IAAI,GAAGjG,MAAM,CAAC,CAAD,CAAN,CAAUiG,IADrB;;AAEA,cAAIuX,IAAI,CAACriB,QAAL,IACA8K,IAAI,CAACxF,IAAL,IAAazC,EAAE,CAAC0G,SAAH,EADb,IAEAlE,MAAM,CAACC,IAAP,IAAezC,EAAE,CAAC2G,QAAH,EAFf,IAGAnE,MAAM,CAACC,IAAP,IAAewF,IAAI,CAACxF,IAAL,GAAY,CAH/B,EAGkC;AAChC;AACA,gBAAID,MAAM,CAACC,IAAP,IAAezC,EAAE,CAAC0G,SAAH,EAAnB,EAAmC;AACjClE,cAAAA,MAAM,CAACE,EAAP,GAAY,CAAZ;AACD,aAFD,MAEO;AACLF,cAAAA,MAAM,GAAG3C,GAAG,CAAC2C,MAAM,CAACC,IAAP,GAAc,CAAf,EAAkBH,UAAU,CAACtC,EAAD,EAAKwC,MAAM,CAACC,IAAP,GAAc,CAAnB,CAA5B,CAAZ;AACD;AACF;;AACD0P,UAAAA,IAAI,GAAGnS,EAAE,CAAC0f,QAAH,CAAYld,MAAZ,EAAoByF,IAApB,CAAP;AACAjI,UAAAA,EAAE,CAACuQ,YAAH,CAAgB,EAAhB,EAAoB/N,MAApB,EAA4ByF,IAA5B;AACAwX,UAAAA,SAAS,GAAGjd,MAAZ;;AACA,cAAIgd,IAAI,CAACriB,QAAT,EAAmB;AACjBsiB,YAAAA,SAAS,GAAGnH,OAAO,CAACyF,iCAAR,CAA0C/d,EAA1C,EAA8CwC,MAA9C,CAAZ;AACD;AACF,SApBD,MAoBO;AACL2P,UAAAA,IAAI,GAAGnS,EAAE,CAACmgB,YAAH,EAAP;AACA,cAAIE,WAAW,GAAGhB,SAAS,CAAC,EAAD,EAAKrd,MAAM,CAACzC,MAAZ,CAA3B;AACAS,UAAAA,EAAE,CAACsgB,iBAAH,CAAqBD,WAArB;AACAZ,UAAAA,SAAS,GAAGzd,MAAM,CAAC,CAAD,CAAN,CAAUQ,MAAtB;AACD;;AACD6H,QAAAA,cAAc,CAACI,kBAAf,CAAkC8H,QAAlC,CACIiN,IAAI,CAACjV,YADT,EACuB,QADvB,EACiC4H,IADjC,EAEIqN,IAAI,CAACriB,QAFT,EAEmByD,GAAG,CAAC4K,WAFvB;AAGA,eAAOsM,mBAAmB,CAAC9X,EAAD,EAAKyf,SAAL,CAA1B;AACD,OAtFa;AAuFdc,MAAAA,MAAM,EAAE,UAASvgB,EAAT,EAAawf,IAAb,EAAmBxd,MAAnB,EAA2B;AACjC,YAAIpB,GAAG,GAAGZ,EAAE,CAACW,KAAH,CAASC,GAAnB;AACA,YAAI4f,SAAS,GAAGxe,MAAM,CAAC,CAAD,CAAN,CAAUQ,MAAV,CAAiBC,IAAjC;AACA,YAAIge,OAAO,GAAG7f,GAAG,CAAC4K,WAAJ,GACZxJ,MAAM,CAACA,MAAM,CAACzC,MAAP,GAAgB,CAAjB,CAAN,CAA0BiD,MAA1B,CAAiCC,IADrB,GAEZT,MAAM,CAAC,CAAD,CAAN,CAAUiG,IAAV,CAAexF,IAFjB,CAHiC,CAMjC;AACA;;AACA,YAAIsP,MAAM,GAAInR,GAAG,CAAC2K,UAAL,GAAmBiU,IAAI,CAACzN,MAAxB,GAAiC,CAA9C;;AACA,YAAIyN,IAAI,CAACriB,QAAT,EAAmB;AACjB;AACA;AACA;AACAsjB,UAAAA,OAAO;AACR;;AACD,aAAK,IAAIte,CAAC,GAAGqe,SAAb,EAAwBre,CAAC,IAAIse,OAA7B,EAAsCte,CAAC,EAAvC,EAA2C;AACzC,eAAK,IAAIqM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGuD,MAApB,EAA4BvD,CAAC,EAA7B,EAAiC;AAC/BxO,YAAAA,EAAE,CAAC0gB,UAAH,CAAcve,CAAd,EAAiBqd,IAAI,CAACrhB,WAAtB;AACD;AACF;;AACD,eAAOma,OAAO,CAACyF,iCAAR,CAA0C/d,EAA1C,EAA8CgC,MAAM,CAAC,CAAD,CAAN,CAAUQ,MAAxD,CAAP;AACD,OA5Ga;AA6Gdme,MAAAA,UAAU,EAAE,UAAS3gB,EAAT,EAAa4gB,KAAb,EAAoB5e,MAApB,EAA4B;AACtChC,QAAAA,EAAE,CAAC6gB,WAAH,CAAe,YAAf;AACA,eAAOvI,OAAO,CAACyF,iCAAR,CAA0C/d,EAA1C,EAA8CgC,MAAM,CAAC,CAAD,CAAN,CAAUQ,MAAxD,CAAP;AACD,OAhHa;AAiHdse,MAAAA,UAAU,EAAE,UAAS9gB,EAAT,EAAawf,IAAb,EAAmBxd,MAAnB,EAA2BiW,SAA3B,EAAsCC,OAAtC,EAA+C;AACzD,YAAI7H,UAAU,GAAGrQ,EAAE,CAAC+gB,aAAH,EAAjB;AACA,YAAIC,OAAO,GAAG,EAAd;AACA,YAAI5iB,OAAO,GAAGohB,IAAI,CAACphB,OAAnB;;AACA,aAAK,IAAIoQ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG6B,UAAU,CAAC9Q,MAA/B,EAAuCiP,CAAC,EAAxC,EAA4C;AAC1C,cAAIyS,MAAM,GAAG5Q,UAAU,CAAC7B,CAAD,CAAvB;AACA,cAAI2D,IAAI,GAAG,EAAX;;AACA,cAAI/T,OAAO,KAAK,IAAhB,EAAsB;AACpB+T,YAAAA,IAAI,GAAG8O,MAAM,CAACnc,WAAP,EAAP;AACD,WAFD,MAEO,IAAI1G,OAAO,KAAK,KAAhB,EAAuB;AAC5B+T,YAAAA,IAAI,GAAG8O,MAAM,CAACC,WAAP,EAAP;AACD,WAFM,MAEA;AACL,iBAAK,IAAI/e,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG8e,MAAM,CAAC1hB,MAA3B,EAAmC4C,CAAC,EAApC,EAAwC;AACtC,kBAAI6R,SAAS,GAAGiN,MAAM,CAAC1c,MAAP,CAAcpC,CAAd,CAAhB;AACAgQ,cAAAA,IAAI,IAAItN,WAAW,CAACmP,SAAD,CAAX,GAAyBA,SAAS,CAAClP,WAAV,EAAzB,GACJkP,SAAS,CAACkN,WAAV,EADJ;AAED;AACF;;AACDF,UAAAA,OAAO,CAACre,IAAR,CAAawP,IAAb;AACD;;AACDnS,QAAAA,EAAE,CAACsgB,iBAAH,CAAqBU,OAArB;;AACA,YAAIxB,IAAI,CAACjhB,gBAAT,EAA0B;AACxB,iBAAO2Z,OAAP;AACD,SAFD,MAEO,IAAI,CAAClY,EAAE,CAACW,KAAH,CAASC,GAAT,CAAa2K,UAAd,IAA4BiU,IAAI,CAACriB,QAAjC,IAA6C6E,MAAM,CAAC,CAAD,CAAN,CAAUQ,MAAV,CAAiBC,IAAjB,GAAwB,CAAxB,IAA6BT,MAAM,CAAC,CAAD,CAAN,CAAUiG,IAAV,CAAexF,IAA7F,EAAmG;AACxG,iBAAO6V,OAAO,CAACyF,iCAAR,CAA0C/d,EAA1C,EAA8CiY,SAA9C,CAAP;AACD,SAFM,MAEA,IAAIuH,IAAI,CAACriB,QAAT,EAAkB;AACvB,iBAAO8a,SAAP;AACD,SAFM,MAEA;AACL,iBAAOiB,SAAS,CAAClX,MAAM,CAAC,CAAD,CAAN,CAAUQ,MAAX,EAAmBR,MAAM,CAAC,CAAD,CAAN,CAAUiG,IAA7B,CAAhB;AACD;AACF,OA/Ia;AAgJdkZ,MAAAA,IAAI,EAAE,UAASnhB,EAAT,EAAawf,IAAb,EAAmBxd,MAAnB,EAA2BiW,SAA3B,EAAsC;AAC1C,YAAIrX,GAAG,GAAGZ,EAAE,CAACW,KAAH,CAASC,GAAnB;AACA,YAAIuR,IAAI,GAAGnS,EAAE,CAACmgB,YAAH,EAAX;AACA,YAAIiB,MAAM,GAAGxgB,GAAG,CAAC2K,UAAJ,GACT2N,SAAS,CAACtY,GAAG,CAAC+K,GAAJ,CAAQnJ,MAAT,EAAiB5B,GAAG,CAAC+K,GAAJ,CAAQ1D,IAAzB,EAA+BjG,MAAM,CAAC,CAAD,CAAN,CAAUiG,IAAzC,EAA+CjG,MAAM,CAAC,CAAD,CAAN,CAAUQ,MAAzD,CADA,GAETyV,SAFJ;AAGA5N,QAAAA,cAAc,CAACI,kBAAf,CAAkC8H,QAAlC,CACIiN,IAAI,CAACjV,YADT,EACuB,MADvB,EAEI4H,IAFJ,EAEUqN,IAAI,CAACriB,QAFf,EAEyByD,GAAG,CAAC4K,WAF7B;AAGA,eAAO4V,MAAP;AACD;AA1Ja,KAAhB;;AA6JA,aAAS5P,cAAT,CAAwB/R,IAAxB,EAA8B2f,EAA9B,EAAkC;AAChCxF,MAAAA,SAAS,CAACna,IAAD,CAAT,GAAkB2f,EAAlB;AACD;;AAED,QAAI/Z,OAAO,GAAG;AACZgc,MAAAA,YAAY,EAAE,UAASrhB,EAAT,EAAanC,UAAb,EAAyB+C,GAAzB,EAA8B;AAC1C,YAAIA,GAAG,CAAC2K,UAAR,EAAoB;AAClB;AACD;;AACD,YAAIwG,MAAM,GAAGlU,UAAU,CAACkU,MAAxB;AACA,YAAI1U,OAAO,GAAGQ,UAAU,CAACR,OAAzB;AACA,YAAI2O,QAAQ,GAAG3B,cAAc,CAAC2B,QAA9B;AAEA,YAAI7C,IAAI,GAAG6C,QAAQ,CAAC/C,IAAT,CAAcjJ,EAAd,EAAkB3C,OAAO,GAAG0U,MAAH,GAAY,CAACA,MAAtC,CAAX;AACA,YAAIjJ,OAAO,GAAGK,IAAI,GAAGA,IAAI,CAACJ,IAAL,EAAH,GAAiBzF,SAAnC;AACAwF,QAAAA,OAAO,GAAGA,OAAO,GAAGA,OAAH,GAAa9I,EAAE,CAACoF,SAAH,EAA9B;AACApF,QAAAA,EAAE,CAACkF,SAAH,CAAa4D,OAAb;AACD,OAbW;AAcZwY,MAAAA,MAAM,EAAE,UAASthB,EAAT,EAAanC,UAAb,EAAyB+C,GAAzB,EAA8B;AACpC,YAAIA,GAAG,CAAC2K,UAAR,EAAoB;AAClB;AACD;;AACD,YAAIwG,MAAM,GAAGlU,UAAU,CAACkU,MAAX,IAAqB,CAAlC;AACA,YAAIwP,UAAU,GAAGvhB,EAAE,CAACqd,iBAAH,EAAjB;AACA,YAAIvH,GAAG,GAAG9V,EAAE,CAACqV,aAAH,GAAmBS,GAA7B;AACA,YAAI0L,KAAK,GAAGD,UAAU,GAAGxP,MAAzB;AACA,YAAI0P,MAAM,GAAG5jB,UAAU,CAACR,OAAX,GAAqByY,GAAG,GAAG0L,KAA3B,GAAmC1L,GAAG,GAAG0L,KAAtD;AACA,YAAI7Y,MAAM,GAAGkP,UAAU,CAAC7X,EAAE,CAACoF,SAAH,EAAD,CAAvB;AACA,YAAIsc,YAAY,GAAG1hB,EAAE,CAACuc,UAAH,CAAc5T,MAAd,EAAsB,OAAtB,CAAnB;;AACA,YAAI9K,UAAU,CAACR,OAAf,EAAwB;AACtB,cAAIokB,MAAM,GAAGC,YAAY,CAAC5L,GAA1B,EAA+B;AAC5BnN,YAAAA,MAAM,CAAClG,IAAP,IAAe,CAACgf,MAAM,GAAGC,YAAY,CAAC5L,GAAvB,IAA8ByL,UAA7C;AACA5Y,YAAAA,MAAM,CAAClG,IAAP,GAAc6T,IAAI,CAACqL,IAAL,CAAUhZ,MAAM,CAAClG,IAAjB,CAAd;AACAzC,YAAAA,EAAE,CAACkF,SAAH,CAAayD,MAAb;AACA+Y,YAAAA,YAAY,GAAG1hB,EAAE,CAACuc,UAAH,CAAc5T,MAAd,EAAsB,OAAtB,CAAf;AACA3I,YAAAA,EAAE,CAAC4V,QAAH,CAAY,IAAZ,EAAkB8L,YAAY,CAAC5L,GAA/B;AACF,WAND,MAMO;AACJ;AACA9V,YAAAA,EAAE,CAAC4V,QAAH,CAAY,IAAZ,EAAkB6L,MAAlB;AACF;AACF,SAXD,MAWO;AACL,cAAIG,SAAS,GAAGH,MAAM,GAAGzhB,EAAE,CAACqV,aAAH,GAAmB+H,YAA5C;;AACA,cAAIwE,SAAS,GAAGF,YAAY,CAAC7W,MAA7B,EAAqC;AAClClC,YAAAA,MAAM,CAAClG,IAAP,IAAe,CAACif,YAAY,CAAC7W,MAAb,GAAsB+W,SAAvB,IAAoCL,UAAnD;AACA5Y,YAAAA,MAAM,CAAClG,IAAP,GAAc6T,IAAI,CAAC6D,KAAL,CAAWxR,MAAM,CAAClG,IAAlB,CAAd;AACAzC,YAAAA,EAAE,CAACkF,SAAH,CAAayD,MAAb;AACA+Y,YAAAA,YAAY,GAAG1hB,EAAE,CAACuc,UAAH,CAAc5T,MAAd,EAAsB,OAAtB,CAAf;AACA3I,YAAAA,EAAE,CAAC4V,QAAH,CACI,IADJ,EACU8L,YAAY,CAAC7W,MAAb,GAAsB7K,EAAE,CAACqV,aAAH,GAAmB+H,YADnD;AAEF,WAPD,MAOO;AACJ;AACApd,YAAAA,EAAE,CAAC4V,QAAH,CAAY,IAAZ,EAAkB6L,MAAlB;AACF;AACF;AACF,OAlDW;AAmDZI,MAAAA,cAAc,EAAE,UAAS7hB,EAAT,EAAanC,UAAb,EAAyB;AACvC,YAAI4gB,OAAO,GAAGze,EAAE,CAACoF,SAAH,GAAe3C,IAA7B;AACA,YAAI8Z,UAAU,GAAGvc,EAAE,CAACuc,UAAH,CAAc1c,GAAG,CAAC4e,OAAD,EAAU,CAAV,CAAjB,EAA+B,OAA/B,CAAjB;AACA,YAAIqD,MAAM,GAAG9hB,EAAE,CAACqV,aAAH,GAAmB+H,YAAhC;AACA,YAAI2E,CAAC,GAAGxF,UAAU,CAACzG,GAAnB;AACA,YAAIyL,UAAU,GAAGhF,UAAU,CAAC1R,MAAX,GAAoBkX,CAArC;;AACA,gBAAQlkB,UAAU,CAACkB,QAAnB;AACE,eAAK,QAAL;AAAegjB,YAAAA,CAAC,GAAGA,CAAC,GAAID,MAAM,GAAG,CAAd,GAAmBP,UAAvB;AACb;;AACF,eAAK,QAAL;AAAeQ,YAAAA,CAAC,GAAGA,CAAC,GAAGD,MAAJ,GAAaP,UAAjB;AACb;AAJJ;;AAMAvhB,QAAAA,EAAE,CAAC4V,QAAH,CAAY,IAAZ,EAAkBmM,CAAlB;AACD,OAhEW;AAiEZC,MAAAA,WAAW,EAAE,UAAShiB,EAAT,EAAanC,UAAb,EAAyB+C,GAAzB,EAA8B;AACzC,YAAI2J,YAAY,GAAG1M,UAAU,CAACsO,iBAA9B;AACA,YAAI4F,MAAM,GAAGlU,UAAU,CAACkU,MAAxB;AACA,YAAI3H,cAAc,GAAGC,cAAc,CAACD,cAApC;;AACA,YAAIG,YAAY,IAAI,GAApB,EAAyB;AACvBA,UAAAA,YAAY,GAAGH,cAAc,CAACR,cAA9B;AACD,SAFD,MAEO;AACLQ,UAAAA,cAAc,CAACR,cAAf,GAAgCW,YAAhC;AACD;;AACD,eAAMwH,MAAM,EAAZ,EAAe;AACbkQ,UAAAA,oBAAoB,CAACjiB,EAAD,EAAKY,GAAL,EAAUwJ,cAAV,EAA0BG,YAA1B,CAApB;AACD;AACF,OA7EW;AA8EZD,MAAAA,oBAAoB,EAAE,UAAStK,EAAT,EAAanC,UAAb,EAAyB;AAC7C,YAAIuM,cAAc,GAAGC,cAAc,CAACD,cAApC;AACA,YAAIG,YAAY,GAAG1M,UAAU,CAACsO,iBAA9B;;AACA,YAAI9B,cAAc,CAACI,kBAAf,CAAkCqI,eAAlC,CAAkDvI,YAAlD,CAAJ,EAAqE;AACnEH,UAAAA,cAAc,CAACE,oBAAf,CAAoCtK,EAApC,EAAwCuK,YAAxC;AACD;AACF,OApFW;AAqFZ2X,MAAAA,eAAe,EAAE,UAASliB,EAAT,EAAa;AAC5B,YAAI,CAACA,EAAE,CAACW,KAAH,CAASwhB,SAAd,EAAyB;AACvBniB,UAAAA,EAAE,CAACkiB,eAAH,CAAmB,IAAnB;AACAliB,UAAAA,EAAE,CAACC,SAAH,CAAa,QAAb,EAAuB,aAAvB;AACAvD,UAAAA,UAAU,CAACwD,MAAX,CAAkBF,EAAlB,EAAsB,iBAAtB,EAAyC;AAACG,YAAAA,IAAI,EAAE;AAAP,WAAzC;AACD,SAJD,MAIO;AACLH,UAAAA,EAAE,CAACkiB,eAAH,CAAmB,KAAnB;AACAliB,UAAAA,EAAE,CAACC,SAAH,CAAa,QAAb,EAAuB,YAAvB;AACAvD,UAAAA,UAAU,CAACwD,MAAX,CAAkBF,EAAlB,EAAsB,iBAAtB,EAAyC;AAACG,YAAAA,IAAI,EAAE;AAAP,WAAzC;AACD;AACF,OA/FW;AAgGZmF,MAAAA,eAAe,EAAE,UAAStF,EAAT,EAAanC,UAAb,EAAyB+C,GAAzB,EAA8B;AAC7C,YAAIZ,EAAE,CAACkB,SAAH,CAAa,UAAb,CAAJ,EAA8B;AAAE;AAAS;;AACzCN,QAAAA,GAAG,CAACqE,UAAJ,GAAiB,IAAjB;AACArE,QAAAA,GAAG,CAAC0K,gBAAJ,GAAuBzN,UAAU,IAAIA,UAAU,CAACkU,MAAzB,IAAmC,CAA1D;AACA,YAAIvT,QAAQ,GAAIX,UAAD,GAAeA,UAAU,CAACW,QAA1B,GAAqC,IAApD;AACA,YAAImN,GAAG,GAAG/K,GAAG,CAAC+K,GAAd;AACA,YAAI1D,IAAI,GAAGpK,UAAU,CAACoK,IAAX,IAAmBjI,EAAE,CAACoF,SAAH,CAAa,MAAb,CAA9B;AACA,YAAI0c,MAAM,GAAG9hB,EAAE,CAACiC,cAAH,GAAoB1C,MAAjC;;AACA,YAAIf,QAAQ,IAAI,KAAhB,EAAuB;AACrByJ,UAAAA,IAAI,GAAGpI,GAAG,CAACoI,IAAI,CAACxF,IAAN,EAAYH,UAAU,CAACtC,EAAD,EAAKiI,IAAI,CAACxF,IAAV,CAAtB,CAAV;AACD,SAFD,MAEO,IAAIjE,QAAQ,IAAI,KAAhB,EAAuB;AAC5ByJ,UAAAA,IAAI,GAAGpI,GAAG,CAACoI,IAAI,CAACxF,IAAN,EAAY,CAAZ,CAAV;AACD,SAFM,MAEA,IAAIjE,QAAQ,IAAI,WAAhB,EAA6B;AAClCyJ,UAAAA,IAAI,GAAG9C,YAAY,CAAC8C,IAAD,EAAO,CAAP,EAAU,CAAV,CAAnB;AACD,SAFM,MAEA,IAAIzJ,QAAQ,IAAI,eAAhB,EAAiC;AACtCyJ,UAAAA,IAAI,GAAGqQ,OAAO,CAACyF,iCAAR,CAA0C/d,EAA1C,EAA8CiI,IAA9C,CAAP;AACD,SAFM,MAEA,IAAIzJ,QAAQ,IAAI,qBAAhB,EAAuC;AAC5C,cAAI,CAACoC,GAAG,CAAC2K,UAAT,EACI;;AACJ,cAAI,CAAC3K,GAAG,CAAC4K,WAAT,EAAsB;AACpB,gBAAIG,GAAG,CAAC1D,IAAJ,CAASxF,IAAT,GAAgBkJ,GAAG,CAACnJ,MAAJ,CAAWC,IAA/B,EAAqC;AACnCwF,cAAAA,IAAI,GAAG0D,GAAG,CAAC1D,IAAX;AACD,aAFD,MAEO;AACLA,cAAAA,IAAI,GAAGpI,GAAG,CAAC8L,GAAG,CAACnJ,MAAJ,CAAWC,IAAZ,EAAkB,CAAlB,CAAV;AACD;AACF,WAND,MAMO;AACLwF,YAAAA,IAAI,GAAGpI,GAAG,CACNyW,IAAI,CAACC,GAAL,CAAS5K,GAAG,CAAC1D,IAAJ,CAASxF,IAAlB,EAAwBkJ,GAAG,CAACnJ,MAAJ,CAAWC,IAAnC,CADM,EAEN6T,IAAI,CAACC,GAAL,CAAS5K,GAAG,CAAC1D,IAAJ,CAASvF,EAAlB,EAAsBiJ,GAAG,CAACnJ,MAAJ,CAAWE,EAAjC,CAFM,CAAV;AAGAof,YAAAA,MAAM,GAAGxL,IAAI,CAACuC,GAAL,CAASlN,GAAG,CAAC1D,IAAJ,CAASxF,IAAT,GAAgBkJ,GAAG,CAACnJ,MAAJ,CAAWC,IAApC,IAA4C,CAArD;AACD;AACF,SAfM,MAeA,IAAIjE,QAAQ,IAAI,mBAAhB,EAAqC;AACxC,cAAI,CAACoC,GAAG,CAAC2K,UAAT,EACE;;AACJ,cAAI,CAAC3K,GAAG,CAAC4K,WAAT,EAAsB;AACpB,gBAAIG,GAAG,CAAC1D,IAAJ,CAASxF,IAAT,IAAiBkJ,GAAG,CAACnJ,MAAJ,CAAWC,IAAhC,EAAsC;AACpCwF,cAAAA,IAAI,GAAG9C,YAAY,CAACwG,GAAG,CAAC1D,IAAL,EAAW,CAAX,EAAc,CAAd,CAAnB;AACD,aAFD,MAEO;AACLA,cAAAA,IAAI,GAAGpI,GAAG,CAAC8L,GAAG,CAACnJ,MAAJ,CAAWC,IAAZ,EAAkB,CAAlB,CAAV;AACD;AACF,WAND,MAMO;AACLwF,YAAAA,IAAI,GAAGpI,GAAG,CACNyW,IAAI,CAACC,GAAL,CAAS5K,GAAG,CAAC1D,IAAJ,CAASxF,IAAlB,EAAwBkJ,GAAG,CAACnJ,MAAJ,CAAWC,IAAnC,CADM,EAEN6T,IAAI,CAAC8L,GAAL,CAASzW,GAAG,CAAC1D,IAAJ,CAASvF,EAAT,GAAc,CAAvB,EAA0BiJ,GAAG,CAACnJ,MAAJ,CAAWE,EAArC,CAFM,CAAV;AAGAof,YAAAA,MAAM,GAAGxL,IAAI,CAACuC,GAAL,CAASlN,GAAG,CAAC1D,IAAJ,CAASxF,IAAT,GAAgBkJ,GAAG,CAACnJ,MAAJ,CAAWC,IAApC,IAA4C,CAArD;AACD;AACF,SAfM,MAeA,IAAIjE,QAAQ,IAAI,SAAhB,EAA2B;AAChC,cAAIoC,GAAG,CAAC2K,UAAR,EAAmB;AACjB;AACD;AACF,SAJM,MAIA,IAAI/M,QAAQ,IAAI,UAAhB,EAA4B;AACjCyJ,UAAAA,IAAI,GAAGoa,cAAc,CAACriB,EAAD,CAAd,IAAsBiI,IAA7B;AACD;;AACDjI,QAAAA,EAAE,CAACC,SAAH,CAAa,cAAb,EAA6B,KAA7B;;AACA,YAAIpC,UAAU,IAAIA,UAAU,CAACe,OAA7B,EAAsC;AACpC;AACAoB,UAAAA,EAAE,CAACkiB,eAAH,CAAmB,IAAnB;AACAliB,UAAAA,EAAE,CAACC,SAAH,CAAa,QAAb,EAAuB,aAAvB;AACAvD,UAAAA,UAAU,CAACwD,MAAX,CAAkBF,EAAlB,EAAsB,iBAAtB,EAAyC;AAACG,YAAAA,IAAI,EAAE;AAAP,WAAzC;AACD,SALD,MAKO;AACLH,UAAAA,EAAE,CAACkiB,eAAH,CAAmB,KAAnB;AACAliB,UAAAA,EAAE,CAACC,SAAH,CAAa,QAAb,EAAuB,YAAvB;AACAvD,UAAAA,UAAU,CAACwD,MAAX,CAAkBF,EAAlB,EAAsB,iBAAtB,EAAyC;AAACG,YAAAA,IAAI,EAAE;AAAP,WAAzC;AACD;;AACD,YAAI,CAACkK,cAAc,CAACD,cAAf,CAA8BP,SAAnC,EAA8C;AAC5C;AACA7J,UAAAA,EAAE,CAACI,EAAH,CAAM,QAAN,EAAgBkiB,QAAhB;AACA5lB,UAAAA,UAAU,CAAC0D,EAAX,CAAcJ,EAAE,CAACO,aAAH,EAAd,EAAkC,SAAlC,EAA6CgiB,uBAA7C;AACD;;AACD,YAAI3hB,GAAG,CAAC2K,UAAR,EAAoB;AAClB8D,UAAAA,cAAc,CAACrP,EAAD,CAAd;AACD;;AACDwiB,QAAAA,eAAe,CAACxiB,EAAD,EAAKiI,IAAL,EAAW6Z,MAAX,CAAf;AACD,OAzKW;AA0KZW,MAAAA,gBAAgB,EAAE,UAASziB,EAAT,EAAanC,UAAb,EAAyB+C,GAAzB,EAA8B;AAC9C,YAAImR,MAAM,GAAGlU,UAAU,CAACkU,MAAxB;AACA,YAAIvP,MAAM,GAAGxC,EAAE,CAACoF,SAAH,EAAb;AACA,YAAI6C,IAAJ,CAH8C,CAI9C;AACA;AACA;;AACA,YAAI,CAACrH,GAAG,CAAC2K,UAAT,EAAqB;AACnB;AACA3K,UAAAA,GAAG,CAAC2K,UAAJ,GAAiB,IAAjB;AACA3K,UAAAA,GAAG,CAACtC,UAAJ,GAAiB,CAAC,CAACT,UAAU,CAACV,QAA9B;AACAyD,UAAAA,GAAG,CAAC4K,WAAJ,GAAkB,CAAC,CAAC3N,UAAU,CAACa,SAA/B;AACAuJ,UAAAA,IAAI,GAAG6P,mBAAmB,CACtB9X,EADsB,EAClBH,GAAG,CAAC2C,MAAM,CAACC,IAAR,EAAcD,MAAM,CAACE,EAAP,GAAYqP,MAAZ,GAAqB,CAAnC,CADe,CAA1B;AAEAnR,UAAAA,GAAG,CAAC+K,GAAJ,GAAU;AACRnJ,YAAAA,MAAM,EAAEA,MADA;AAERyF,YAAAA,IAAI,EAAEA;AAFE,WAAV;AAIAvL,UAAAA,UAAU,CAACwD,MAAX,CAAkBF,EAAlB,EAAsB,iBAAtB,EAAyC;AAACG,YAAAA,IAAI,EAAE,QAAP;AAAiB4a,YAAAA,OAAO,EAAEna,GAAG,CAACtC,UAAJ,GAAiB,UAAjB,GAA8BsC,GAAG,CAAC4K,WAAJ,GAAkB,WAAlB,GAAgC;AAAxF,WAAzC;AACAmJ,UAAAA,iBAAiB,CAAC3U,EAAD,CAAjB;AACAyY,UAAAA,UAAU,CAACzY,EAAD,EAAKY,GAAL,EAAU,GAAV,EAAesY,SAAS,CAAC1W,MAAD,EAASyF,IAAT,CAAxB,CAAV;AACAwQ,UAAAA,UAAU,CAACzY,EAAD,EAAKY,GAAL,EAAU,GAAV,EAAeuY,SAAS,CAAC3W,MAAD,EAASyF,IAAT,CAAxB,CAAV;AACD,SAfD,MAeO,IAAIrH,GAAG,CAACtC,UAAJ,GAAiBT,UAAU,CAACV,QAA5B,IACPyD,GAAG,CAAC4K,WAAJ,GAAkB3N,UAAU,CAACa,SAD1B,EACqC;AAC1C;AACAkC,UAAAA,GAAG,CAACtC,UAAJ,GAAiB,CAAC,CAACT,UAAU,CAACV,QAA9B;AACAyD,UAAAA,GAAG,CAAC4K,WAAJ,GAAkB,CAAC,CAAC3N,UAAU,CAACa,SAA/B;AACAhC,UAAAA,UAAU,CAACwD,MAAX,CAAkBF,EAAlB,EAAsB,iBAAtB,EAAyC;AAACG,YAAAA,IAAI,EAAE,QAAP;AAAiB4a,YAAAA,OAAO,EAAEna,GAAG,CAACtC,UAAJ,GAAiB,UAAjB,GAA8BsC,GAAG,CAAC4K,WAAJ,GAAkB,WAAlB,GAAgC;AAAxF,WAAzC;AACAmJ,UAAAA,iBAAiB,CAAC3U,EAAD,CAAjB;AACD,SAPM,MAOA;AACLqP,UAAAA,cAAc,CAACrP,EAAD,CAAd;AACD;AACF,OA1MW;AA2MZ0iB,MAAAA,qBAAqB,EAAE,UAAS1iB,EAAT,EAAa2iB,WAAb,EAA0B/hB,GAA1B,EAA+B;AACpD,YAAI6K,aAAa,GAAG7K,GAAG,CAAC6K,aAAxB;;AACA,YAAI7K,GAAG,CAAC2K,UAAR,EAAoB;AAClBqX,UAAAA,mBAAmB,CAAC5iB,EAAD,EAAKY,GAAL,CAAnB;AACD;;AACD,YAAI6K,aAAJ,EAAmB;AACjB,cAAIjJ,MAAM,GAAGiJ,aAAa,CAACoX,UAAd,CAAyB9Z,IAAzB,EAAb;AACA,cAAId,IAAI,GAAGwD,aAAa,CAACqX,QAAd,CAAuB/Z,IAAvB,EAAX;;AACA,cAAI,CAACvG,MAAD,IAAW,CAACyF,IAAhB,EAAsB;AACpB;AACA;AACD;;AACDrH,UAAAA,GAAG,CAAC+K,GAAJ,GAAU;AACRnJ,YAAAA,MAAM,EAAEA,MADA;AAERyF,YAAAA,IAAI,EAAEA;AAFE,WAAV;AAIArH,UAAAA,GAAG,CAAC2K,UAAJ,GAAiB,IAAjB;AACA3K,UAAAA,GAAG,CAACtC,UAAJ,GAAiBmN,aAAa,CAACnN,UAA/B;AACAsC,UAAAA,GAAG,CAAC4K,WAAJ,GAAkBC,aAAa,CAACD,WAAhC;AACAmJ,UAAAA,iBAAiB,CAAC3U,EAAD,CAAjB;AACAyY,UAAAA,UAAU,CAACzY,EAAD,EAAKY,GAAL,EAAU,GAAV,EAAesY,SAAS,CAAC1W,MAAD,EAASyF,IAAT,CAAxB,CAAV;AACAwQ,UAAAA,UAAU,CAACzY,EAAD,EAAKY,GAAL,EAAU,GAAV,EAAeuY,SAAS,CAAC3W,MAAD,EAASyF,IAAT,CAAxB,CAAV;AACAvL,UAAAA,UAAU,CAACwD,MAAX,CAAkBF,EAAlB,EAAsB,iBAAtB,EAAyC;AACvCG,YAAAA,IAAI,EAAE,QADiC;AAEvC4a,YAAAA,OAAO,EAAEna,GAAG,CAACtC,UAAJ,GAAiB,UAAjB,GACAsC,GAAG,CAAC4K,WAAJ,GAAkB,WAAlB,GAAgC;AAHF,WAAzC;AAID;AACF,OAtOW;AAuOZuX,MAAAA,SAAS,EAAE,UAAS/iB,EAAT,EAAanC,UAAb,EAAyB+C,GAAzB,EAA8B;AACvC,YAAImY,QAAJ,EAAcC,MAAd;;AACA,YAAIpY,GAAG,CAAC2K,UAAR,EAAoB;AAClBwN,UAAAA,QAAQ,GAAG/Y,EAAE,CAACoF,SAAH,CAAa,QAAb,CAAX;AACA4T,UAAAA,MAAM,GAAGhZ,EAAE,CAACoF,SAAH,CAAa,MAAb,CAAT;;AACA,cAAIsT,cAAc,CAACM,MAAD,EAASD,QAAT,CAAlB,EAAsC;AACpC,gBAAIM,GAAG,GAAGL,MAAV;AACAA,YAAAA,MAAM,GAAGD,QAAT;AACAA,YAAAA,QAAQ,GAAGM,GAAX;AACD;;AACDL,UAAAA,MAAM,CAACtW,EAAP,GAAYJ,UAAU,CAACtC,EAAD,EAAKgZ,MAAM,CAACvW,IAAZ,CAAV,GAA8B,CAA1C;AACD,SATD,MASO;AACL;AACA,cAAIsP,MAAM,GAAGuE,IAAI,CAAC8L,GAAL,CAASvkB,UAAU,CAACkU,MAApB,EAA4B,CAA5B,CAAb;AACAgH,UAAAA,QAAQ,GAAG/Y,EAAE,CAACoF,SAAH,EAAX;AACA4T,UAAAA,MAAM,GAAGlB,mBAAmB,CAAC9X,EAAD,EAAKH,GAAG,CAACkZ,QAAQ,CAACtW,IAAT,GAAgBsP,MAAhB,GAAyB,CAA1B,EACCyG,QADD,CAAR,CAA5B;AAED;;AACD,YAAIwK,OAAO,GAAG,CAAd;;AACA,aAAK,IAAI7gB,CAAC,GAAG4W,QAAQ,CAACtW,IAAtB,EAA4BN,CAAC,GAAG6W,MAAM,CAACvW,IAAvC,EAA6CN,CAAC,EAA9C,EAAkD;AAChD6gB,UAAAA,OAAO,GAAG1gB,UAAU,CAACtC,EAAD,EAAK+Y,QAAQ,CAACtW,IAAd,CAApB;AACA,cAAI4W,GAAG,GAAGxZ,GAAG,CAACkZ,QAAQ,CAACtW,IAAT,GAAgB,CAAjB,EACCH,UAAU,CAACtC,EAAD,EAAK+Y,QAAQ,CAACtW,IAAT,GAAgB,CAArB,CADX,CAAb;AAEA,cAAI0P,IAAI,GAAGnS,EAAE,CAAC0f,QAAH,CAAY3G,QAAZ,EAAsBM,GAAtB,CAAX;AACAlH,UAAAA,IAAI,GAAGtU,UAAU,CAACc,UAAX,GACHwT,IAAI,CAACvT,OAAL,CAAa,QAAb,EAAuB,EAAvB,CADG,GAEHuT,IAAI,CAACvT,OAAL,CAAa,QAAb,EAAuB,GAAvB,CAFJ;AAGAoB,UAAAA,EAAE,CAACuQ,YAAH,CAAgB4B,IAAhB,EAAsB4G,QAAtB,EAAgCM,GAAhC;AACD;;AACD,YAAI4J,WAAW,GAAGpjB,GAAG,CAACkZ,QAAQ,CAACtW,IAAV,EAAgBugB,OAAhB,CAArB;;AACA,YAAIpiB,GAAG,CAAC2K,UAAR,EAAoB;AAClB8D,UAAAA,cAAc,CAACrP,EAAD,EAAK,KAAL,CAAd;AACD;;AACDA,QAAAA,EAAE,CAACkF,SAAH,CAAa+d,WAAb;AACD,OAzQW;AA0QZC,MAAAA,yBAAyB,EAAE,UAASljB,EAAT,EAAanC,UAAb,EAAyB+C,GAAzB,EAA8B;AACvDA,QAAAA,GAAG,CAACqE,UAAJ,GAAiB,IAAjB;AACA,YAAIzG,QAAQ,GAAGqZ,UAAU,CAAC7X,EAAE,CAACoF,SAAH,EAAD,CAAzB;;AACA,YAAI5G,QAAQ,CAACiE,IAAT,KAAkBzC,EAAE,CAAC0G,SAAH,EAAlB,IAAoC,CAAC7I,UAAU,CAACC,KAApD,EAA2D;AACzD;AACAkC,UAAAA,EAAE,CAACuQ,YAAH,CAAgB,IAAhB,EAAsB1Q,GAAG,CAACG,EAAE,CAAC0G,SAAH,EAAD,EAAiB,CAAjB,CAAzB;AACA1G,UAAAA,EAAE,CAACkF,SAAH,CAAalF,EAAE,CAAC0G,SAAH,EAAb,EAA6B,CAA7B;AACD,SAJD,MAIO;AACLlI,UAAAA,QAAQ,CAACiE,IAAT,GAAiB5E,UAAU,CAACC,KAAZ,GAAqBU,QAAQ,CAACiE,IAA9B,GACZjE,QAAQ,CAACiE,IAAT,GAAgB,CADpB;AAEAjE,UAAAA,QAAQ,CAACkE,EAAT,GAAcJ,UAAU,CAACtC,EAAD,EAAKxB,QAAQ,CAACiE,IAAd,CAAxB;AACAzC,UAAAA,EAAE,CAACkF,SAAH,CAAa1G,QAAb;AACA,cAAI2kB,SAAS,GAAGzmB,UAAU,CAACsjB,QAAX,CAAoBoD,+BAApB,IACZ1mB,UAAU,CAACsjB,QAAX,CAAoBC,gBADxB;AAEAkD,UAAAA,SAAS,CAACnjB,EAAD,CAAT;AACD;;AACD,aAAKsF,eAAL,CAAqBtF,EAArB,EAAyB;AAAE+R,UAAAA,MAAM,EAAElU,UAAU,CAACkU;AAArB,SAAzB,EAAwDnR,GAAxD;AACD,OA3RW;AA4RZyiB,MAAAA,KAAK,EAAE,UAASrjB,EAAT,EAAanC,UAAb,EAAyB+C,GAAzB,EAA8B;AACnC,YAAI2Z,GAAG,GAAG1C,UAAU,CAAC7X,EAAE,CAACoF,SAAH,EAAD,CAApB;AACA,YAAIoF,QAAQ,GAAGH,cAAc,CAACI,kBAAf,CAAkCC,WAAlC,CACX7M,UAAU,CAAC0M,YADA,CAAf;AAEA,YAAI4H,IAAI,GAAG3H,QAAQ,CAACmI,QAAT,EAAX;;AACA,YAAI,CAACR,IAAL,EAAW;AACT;AACD;;AACD,YAAItU,UAAU,CAACE,WAAf,EAA4B;AAC1B,cAAIulB,OAAO,GAAGtjB,EAAE,CAACkB,SAAH,CAAa,SAAb,CAAd,CAD0B,CAE1B;;AACA,cAAIqiB,gBAAgB,GAAG,UAASC,GAAT,EAAc;AACnC,gBAAIC,IAAI,GAAID,GAAG,CAAC/e,KAAJ,CAAU,IAAV,EAAgBlF,MAAhB,GAAyB,CAArC;AACA,gBAAImkB,MAAM,GAAIF,GAAG,CAAC/e,KAAJ,CAAU,GAAV,EAAelF,MAAf,GAAwB,CAAtC;AACA,mBAAOkkB,IAAI,GAAGH,OAAP,GAAiBI,MAAM,GAAG,CAAjC;AACD,WAJD;;AAKA,cAAIC,WAAW,GAAG3jB,EAAE,CAACuC,OAAH,CAAWvC,EAAE,CAACoF,SAAH,GAAe3C,IAA1B,CAAlB;AACA,cAAI8d,MAAM,GAAGgD,gBAAgB,CAACI,WAAW,CAACnU,KAAZ,CAAkB,MAAlB,EAA0B,CAA1B,CAAD,CAA7B,CAT0B,CAU1B;;AACA,cAAIoU,WAAW,GAAGzR,IAAI,CAACvT,OAAL,CAAa,KAAb,EAAoB,EAApB,CAAlB;AACA,cAAIilB,UAAU,GAAG1R,IAAI,KAAKyR,WAA1B;AACA,cAAIE,WAAW,GAAGP,gBAAgB,CAACpR,IAAI,CAAC3C,KAAL,CAAW,MAAX,EAAmB,CAAnB,CAAD,CAAlC;AACA,cAAI2C,IAAI,GAAGyR,WAAW,CAAChlB,OAAZ,CAAoB,QAApB,EAA8B,UAASmlB,MAAT,EAAiB;AACxD,gBAAIC,SAAS,GAAGzD,MAAM,IAAIgD,gBAAgB,CAACQ,MAAD,CAAhB,GAA2BD,WAA/B,CAAtB;;AACA,gBAAIE,SAAS,GAAG,CAAhB,EAAmB;AACjB,qBAAO,EAAP;AACD,aAFD,MAGK,IAAIhkB,EAAE,CAACkB,SAAH,CAAa,gBAAb,CAAJ,EAAoC;AACvC,kBAAI+iB,QAAQ,GAAG3N,IAAI,CAAC6D,KAAL,CAAW6J,SAAS,GAAGV,OAAvB,CAAf;AACA,qBAAOlb,KAAK,CAAC6b,QAAQ,GAAG,CAAZ,CAAL,CAAoBlf,IAApB,CAAyB,IAAzB,CAAP;AACD,aAHI,MAIA;AACH,qBAAOqD,KAAK,CAAC4b,SAAS,GAAG,CAAb,CAAL,CAAqBjf,IAArB,CAA0B,GAA1B,CAAP;AACD;AACF,WAZU,CAAX;AAaAoN,UAAAA,IAAI,IAAI0R,UAAU,GAAG,IAAH,GAAU,EAA5B;AACD;;AACD,YAAIhmB,UAAU,CAACkU,MAAX,GAAoB,CAAxB,EAA2B;AACzB,cAAII,IAAI,GAAG/J,KAAK,CAACvK,UAAU,CAACkU,MAAX,GAAoB,CAArB,CAAL,CAA6BhN,IAA7B,CAAkCoN,IAAlC,CAAX;AACD;;AACD,YAAIhV,QAAQ,GAAGqN,QAAQ,CAACrN,QAAxB;AACA,YAAIuB,SAAS,GAAG8L,QAAQ,CAAC9L,SAAzB;;AACA,YAAIA,SAAJ,EAAe;AACbyT,UAAAA,IAAI,GAAGA,IAAI,CAAC1N,KAAL,CAAW,IAAX,CAAP;;AACA,cAAItH,QAAJ,EAAc;AACVgV,YAAAA,IAAI,CAAC3B,GAAL;AACH;;AACD,eAAK,IAAIrO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGgQ,IAAI,CAAC5S,MAAzB,EAAiC4C,CAAC,EAAlC,EAAsC;AACpCgQ,YAAAA,IAAI,CAAChQ,CAAD,CAAJ,GAAWgQ,IAAI,CAAChQ,CAAD,CAAJ,IAAW,EAAZ,GAAkB,GAAlB,GAAwBgQ,IAAI,CAAChQ,CAAD,CAAtC;AACD;;AACDoY,UAAAA,GAAG,CAAC7X,EAAJ,IAAU7E,UAAU,CAACC,KAAX,GAAmB,CAAnB,GAAuB,CAAjC;AACAyc,UAAAA,GAAG,CAAC7X,EAAJ,GAAS4T,IAAI,CAACC,GAAL,CAASjU,UAAU,CAACtC,EAAD,EAAKua,GAAG,CAAC9X,IAAT,CAAnB,EAAmC8X,GAAG,CAAC7X,EAAvC,CAAT;AACD,SAVD,MAUO,IAAIvF,QAAJ,EAAc;AACnB,cAAGyD,GAAG,CAAC2K,UAAP,EAAmB;AACjB4G,YAAAA,IAAI,GAAGvR,GAAG,CAACtC,UAAJ,GAAiB6T,IAAI,CAAC7D,KAAL,CAAW,CAAX,EAAc,CAAC,CAAf,CAAjB,GAAqC,OAAO6D,IAAI,CAAC7D,KAAL,CAAW,CAAX,EAAc6D,IAAI,CAAC5S,MAAL,GAAc,CAA5B,CAAP,GAAwC,IAApF;AACD,WAFD,MAEO,IAAI1B,UAAU,CAACC,KAAf,EAAsB;AAC3B;AACA;AACAqU,YAAAA,IAAI,GAAG,OAAOA,IAAI,CAAC7D,KAAL,CAAW,CAAX,EAAc6D,IAAI,CAAC5S,MAAL,GAAc,CAA5B,CAAd;AACAgb,YAAAA,GAAG,CAAC7X,EAAJ,GAASJ,UAAU,CAACtC,EAAD,EAAKua,GAAG,CAAC9X,IAAT,CAAnB;AACD,WALM,MAKA;AACL8X,YAAAA,GAAG,CAAC7X,EAAJ,GAAS,CAAT;AACD;AACF,SAXM,MAWA;AACL6X,UAAAA,GAAG,CAAC7X,EAAJ,IAAU7E,UAAU,CAACC,KAAX,GAAmB,CAAnB,GAAuB,CAAjC;AACD;;AACD,YAAIomB,WAAJ;AACA,YAAIC,GAAJ;;AACA,YAAIvjB,GAAG,CAAC2K,UAAR,EAAoB;AAClB;AACA3K,UAAAA,GAAG,CAAC8K,cAAJ,GAAqByG,IAArB;AACA,cAAIiS,mBAAJ;AACA,cAAIC,YAAY,GAAGC,oBAAoB,CAACtkB,EAAD,EAAKY,GAAL,CAAvC;AACA,cAAIyV,cAAc,GAAGgO,YAAY,CAAC,CAAD,CAAjC;AACA,cAAIjO,YAAY,GAAGiO,YAAY,CAAC,CAAD,CAA/B;AACA,cAAIE,YAAY,GAAGvkB,EAAE,CAACmgB,YAAH,EAAnB;AACA,cAAI9P,UAAU,GAAGrQ,EAAE,CAACiC,cAAH,EAAjB;AACA,cAAIuiB,YAAY,GAAG,IAAIpc,KAAJ,CAAUiI,UAAU,CAAC9Q,MAArB,EAA6BwF,IAA7B,CAAkC,GAAlC,EAAuCN,KAAvC,CAA6C,GAA7C,CAAnB,CATkB,CAUlB;;AACA,cAAI7D,GAAG,CAAC6K,aAAR,EAAuB;AACrB2Y,YAAAA,mBAAmB,GAAGxjB,GAAG,CAAC6K,aAAJ,CAAkBqX,QAAlB,CAA2B/Z,IAA3B,EAAtB;AACD,WAbiB,CAclB;;;AACAsB,UAAAA,cAAc,CAACI,kBAAf,CAAkCoI,eAAlC,CAAkDP,OAAlD,CAA0DiS,YAA1D;;AACA,cAAI7lB,SAAJ,EAAe;AACb;AACAsB,YAAAA,EAAE,CAACsgB,iBAAH,CAAqBkE,YAArB,EAFa,CAGb;;AACApO,YAAAA,YAAY,GAAGvW,GAAG,CAACwW,cAAc,CAAC5T,IAAf,GAAsB0P,IAAI,CAAC5S,MAA3B,GAAkC,CAAnC,EAAsC8W,cAAc,CAAC3T,EAArD,CAAlB;AACA1C,YAAAA,EAAE,CAACkF,SAAH,CAAamR,cAAb;AACAoO,YAAAA,WAAW,CAACzkB,EAAD,EAAKoW,YAAL,CAAX;AACApW,YAAAA,EAAE,CAACsgB,iBAAH,CAAqBnO,IAArB;AACA+R,YAAAA,WAAW,GAAG7N,cAAd;AACD,WATD,MASO,IAAIzV,GAAG,CAAC4K,WAAR,EAAqB;AAC1BxL,YAAAA,EAAE,CAACsgB,iBAAH,CAAqBkE,YAArB;AACAxkB,YAAAA,EAAE,CAACkF,SAAH,CAAamR,cAAb;AACArW,YAAAA,EAAE,CAACuQ,YAAH,CAAgB4B,IAAhB,EAAsBkE,cAAtB,EAAsCA,cAAtC;AACA6N,YAAAA,WAAW,GAAG7N,cAAd;AACD,WALM,MAKA;AACLrW,YAAAA,EAAE,CAACuQ,YAAH,CAAgB4B,IAAhB,EAAsBkE,cAAtB,EAAsCD,YAAtC;AACA8N,YAAAA,WAAW,GAAGlkB,EAAE,CAAC0kB,YAAH,CAAgB1kB,EAAE,CAAC2kB,YAAH,CAAgBtO,cAAhB,IAAkClE,IAAI,CAAC5S,MAAvC,GAAgD,CAAhE,CAAd;AACD,WAjCiB,CAkClB;;;AACA,cAAG6kB,mBAAH,EAAwB;AACtBxjB,YAAAA,GAAG,CAAC6K,aAAJ,CAAkBqX,QAAlB,GAA6B9iB,EAAE,CAAC6I,WAAH,CAAeub,mBAAf,CAA7B;AACD;;AACD,cAAIjnB,QAAJ,EAAc;AACZ+mB,YAAAA,WAAW,CAACxhB,EAAZ,GAAe,CAAf;AACD;AACF,SAzCD,MAyCO;AACL,cAAIhE,SAAJ,EAAe;AACbsB,YAAAA,EAAE,CAACkF,SAAH,CAAaqV,GAAb;;AACA,iBAAK,IAAIpY,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGgQ,IAAI,CAAC5S,MAAzB,EAAiC4C,CAAC,EAAlC,EAAsC;AACpC,kBAAIM,IAAI,GAAG8X,GAAG,CAAC9X,IAAJ,GAASN,CAApB;;AACA,kBAAIM,IAAI,GAAGzC,EAAE,CAAC2G,QAAH,EAAX,EAA0B;AACxB3G,gBAAAA,EAAE,CAACuQ,YAAH,CAAgB,IAAhB,EAAuB1Q,GAAG,CAAC4C,IAAD,EAAO,CAAP,CAA1B;AACD;;AACD,kBAAImiB,MAAM,GAAGtiB,UAAU,CAACtC,EAAD,EAAKyC,IAAL,CAAvB;;AACA,kBAAImiB,MAAM,GAAGrK,GAAG,CAAC7X,EAAjB,EAAqB;AACnBmiB,gBAAAA,kBAAkB,CAAC7kB,EAAD,EAAKyC,IAAL,EAAW8X,GAAG,CAAC7X,EAAf,CAAlB;AACD;AACF;;AACD1C,YAAAA,EAAE,CAACkF,SAAH,CAAaqV,GAAb;AACAkK,YAAAA,WAAW,CAACzkB,EAAD,EAAKH,GAAG,CAAC0a,GAAG,CAAC9X,IAAJ,GAAW0P,IAAI,CAAC5S,MAAhB,GAAuB,CAAxB,EAA2Bgb,GAAG,CAAC7X,EAA/B,CAAR,CAAX;AACA1C,YAAAA,EAAE,CAACsgB,iBAAH,CAAqBnO,IAArB;AACA+R,YAAAA,WAAW,GAAG3J,GAAd;AACD,WAhBD,MAgBO;AACLva,YAAAA,EAAE,CAACuQ,YAAH,CAAgB4B,IAAhB,EAAsBoI,GAAtB,EADK,CAEL;;AACA,gBAAIpd,QAAQ,IAAIU,UAAU,CAACC,KAA3B,EAAkC;AAChComB,cAAAA,WAAW,GAAGrkB,GAAG,CACjB0a,GAAG,CAAC9X,IAAJ,GAAW,CADM,EAEjBwX,+BAA+B,CAACja,EAAE,CAACuC,OAAH,CAAWgY,GAAG,CAAC9X,IAAJ,GAAW,CAAtB,CAAD,CAFd,CAAjB;AAGD,aAJD,MAIO,IAAItF,QAAQ,IAAI,CAACU,UAAU,CAACC,KAA5B,EAAmC;AACxComB,cAAAA,WAAW,GAAGrkB,GAAG,CACf0a,GAAG,CAAC9X,IADW,EAEfwX,+BAA+B,CAACja,EAAE,CAACuC,OAAH,CAAWgY,GAAG,CAAC9X,IAAf,CAAD,CAFhB,CAAjB;AAGD,aAJM,MAIA,IAAI,CAACtF,QAAD,IAAaU,UAAU,CAACC,KAA5B,EAAmC;AACxCqmB,cAAAA,GAAG,GAAGnkB,EAAE,CAAC2kB,YAAH,CAAgBpK,GAAhB,CAAN;AACA2J,cAAAA,WAAW,GAAGlkB,EAAE,CAAC0kB,YAAH,CAAgBP,GAAG,GAAGhS,IAAI,CAAC5S,MAAX,GAAoB,CAApC,CAAd;AACD,aAHM,MAGA;AACL4kB,cAAAA,GAAG,GAAGnkB,EAAE,CAAC2kB,YAAH,CAAgBpK,GAAhB,CAAN;AACA2J,cAAAA,WAAW,GAAGlkB,EAAE,CAAC0kB,YAAH,CAAgBP,GAAG,GAAGhS,IAAI,CAAC5S,MAA3B,CAAd;AACD;AACF;AACF;;AACD,YAAIqB,GAAG,CAAC2K,UAAR,EAAoB;AAClB8D,UAAAA,cAAc,CAACrP,EAAD,EAAK,KAAL,CAAd;AACD;;AACDA,QAAAA,EAAE,CAACkF,SAAH,CAAagf,WAAb;AACD,OAlbW;AAmbZY,MAAAA,IAAI,EAAE,UAAS9kB,EAAT,EAAanC,UAAb,EAAyB;AAC7BmC,QAAAA,EAAE,CAAC8Q,SAAH,CAAa,YAAW;AACtBiU,UAAAA,QAAQ,CAAC/kB,EAAD,EAAKtD,UAAU,CAACsjB,QAAX,CAAoB8E,IAAzB,EAA+BjnB,UAAU,CAACkU,MAA1C,CAAR;AACA/R,UAAAA,EAAE,CAACkF,SAAH,CAAalF,EAAE,CAACoF,SAAH,CAAa,QAAb,CAAb;AACD,SAHD;AAID,OAxbW;AAybZ4f,MAAAA,IAAI,EAAE,UAAShlB,EAAT,EAAanC,UAAb,EAAyB;AAC7BknB,QAAAA,QAAQ,CAAC/kB,EAAD,EAAKtD,UAAU,CAACsjB,QAAX,CAAoBgF,IAAzB,EAA+BnnB,UAAU,CAACkU,MAA1C,CAAR;AACD,OA3bW;AA4bZkT,MAAAA,WAAW,EAAE,UAAS3K,GAAT,EAAczc,UAAd,EAA0B+C,GAA1B,EAA+B;AAC1CA,QAAAA,GAAG,CAACkK,UAAJ,CAAeP,YAAf,GAA8B1M,UAAU,CAACsO,iBAAzC;AACD,OA9bW;AA+bZ+Y,MAAAA,OAAO,EAAE,UAASllB,EAAT,EAAanC,UAAb,EAAyB+C,GAAzB,EAA8B;AACrC,YAAIukB,QAAQ,GAAGtnB,UAAU,CAACsO,iBAA1B;AACAsM,QAAAA,UAAU,CAACzY,EAAD,EAAKY,GAAL,EAAUukB,QAAV,EAAoBnlB,EAAE,CAACoF,SAAH,EAApB,CAAV;AACD,OAlcW;AAmcZxG,MAAAA,OAAO,EAAE,UAASoB,EAAT,EAAanC,UAAb,EAAyB+C,GAAzB,EAA8B;AACrC,YAAIwkB,WAAW,GAAGvnB,UAAU,CAACsO,iBAA7B;AACA,YAAI4M,QAAQ,GAAG/Y,EAAE,CAACoF,SAAH,EAAf;AACA,YAAIigB,SAAJ;AACA,YAAIrM,MAAJ;AACA,YAAI3I,UAAU,GAAGrQ,EAAE,CAACiC,cAAH,EAAjB;;AACA,YAAIrB,GAAG,CAAC2K,UAAR,EAAoB;AAClBwN,UAAAA,QAAQ,GAAG/Y,EAAE,CAACoF,SAAH,CAAa,OAAb,CAAX;AACA4T,UAAAA,MAAM,GAAGhZ,EAAE,CAACoF,SAAH,CAAa,KAAb,CAAT;AACD,SAHD,MAGO;AACL,cAAI3C,IAAI,GAAGzC,EAAE,CAACuC,OAAH,CAAWwW,QAAQ,CAACtW,IAApB,CAAX;AACA4iB,UAAAA,SAAS,GAAGtM,QAAQ,CAACrW,EAAT,GAAc7E,UAAU,CAACkU,MAArC;;AACA,cAAIsT,SAAS,GAAG5iB,IAAI,CAAClD,MAArB,EAA6B;AAC3B8lB,YAAAA,SAAS,GAAC5iB,IAAI,CAAClD,MAAf;AACD;;AACDyZ,UAAAA,MAAM,GAAGnZ,GAAG,CAACkZ,QAAQ,CAACtW,IAAV,EAAgB4iB,SAAhB,CAAZ;AACD;;AACD,YAAID,WAAW,IAAE,IAAjB,EAAuB;AACrB,cAAI,CAACxkB,GAAG,CAAC2K,UAAT,EAAqBvL,EAAE,CAACuQ,YAAH,CAAgB,EAAhB,EAAoBwI,QAApB,EAA8BC,MAA9B,EADA,CAErB;;AACA,WAACtc,UAAU,CAACsjB,QAAX,CAAoBoD,+BAApB,IAAuD1mB,UAAU,CAACsjB,QAAX,CAAoBC,gBAA5E,EAA8FjgB,EAA9F;AACD,SAJD,MAIO;AACL,cAAIslB,cAAc,GAAGtlB,EAAE,CAAC0f,QAAH,CAAY3G,QAAZ,EAAsBC,MAAtB,CAArB,CADK,CAEL;;AACAsM,UAAAA,cAAc,GAAGA,cAAc,CAAC1mB,OAAf,CAAuB,QAAvB,EAAiCwmB,WAAjC,CAAjB;;AACA,cAAIxkB,GAAG,CAAC4K,WAAR,EAAqB;AACnB;AACA,gBAAIkY,MAAM,GAAG,IAAItb,KAAJ,CAAUpI,EAAE,CAACkB,SAAH,CAAa,SAAb,IAAwB,CAAlC,EAAqC6D,IAArC,CAA0C,GAA1C,CAAb;AACAugB,YAAAA,cAAc,GAAGtlB,EAAE,CAACmgB,YAAH,EAAjB;AACAmF,YAAAA,cAAc,GAAGA,cAAc,CAAC1mB,OAAf,CAAuB,KAAvB,EAA8B8kB,MAA9B,EAAsC9kB,OAAtC,CAA8C,QAA9C,EAAwDwmB,WAAxD,EAAqE3gB,KAArE,CAA2E,IAA3E,CAAjB;AACAzE,YAAAA,EAAE,CAACsgB,iBAAH,CAAqBgF,cAArB;AACD,WAND,MAMO;AACLtlB,YAAAA,EAAE,CAACuQ,YAAH,CAAgB+U,cAAhB,EAAgCvM,QAAhC,EAA0CC,MAA1C;AACD;;AACD,cAAIpY,GAAG,CAAC2K,UAAR,EAAoB;AAClBwN,YAAAA,QAAQ,GAAGL,cAAc,CAACrI,UAAU,CAAC,CAAD,CAAV,CAAc7N,MAAf,EAAuB6N,UAAU,CAAC,CAAD,CAAV,CAAcpI,IAArC,CAAd,GACEoI,UAAU,CAAC,CAAD,CAAV,CAAc7N,MADhB,GACyB6N,UAAU,CAAC,CAAD,CAAV,CAAcpI,IADlD;AAEAjI,YAAAA,EAAE,CAACkF,SAAH,CAAa6T,QAAb;AACA1J,YAAAA,cAAc,CAACrP,EAAD,EAAK,KAAL,CAAd;AACD,WALD,MAKO;AACLA,YAAAA,EAAE,CAACkF,SAAH,CAAaC,YAAY,CAAC6T,MAAD,EAAS,CAAT,EAAY,CAAC,CAAb,CAAzB;AACD;AACF;AACF,OA9eW;AA+eZuM,MAAAA,oBAAoB,EAAE,UAASvlB,EAAT,EAAanC,UAAb,EAAyB;AAC7C,YAAI0c,GAAG,GAAGva,EAAE,CAACoF,SAAH,EAAV;AACA,YAAIogB,OAAO,GAAGxlB,EAAE,CAACuC,OAAH,CAAWgY,GAAG,CAAC9X,IAAf,CAAd;AACA,YAAI2b,EAAE,GAAG,uCAAT;AACA,YAAI5O,KAAJ;AACA,YAAI5J,KAAJ;AACA,YAAI4R,GAAJ;AACA,YAAIiO,SAAJ;;AACA,eAAO,CAACjW,KAAK,GAAG4O,EAAE,CAAC3O,IAAH,CAAQ+V,OAAR,CAAT,MAA+B,IAAtC,EAA4C;AAC1C5f,UAAAA,KAAK,GAAG4J,KAAK,CAACG,KAAd;AACA6H,UAAAA,GAAG,GAAG5R,KAAK,GAAG4J,KAAK,CAAC,CAAD,CAAL,CAASjQ,MAAvB;AACA,cAAIgb,GAAG,CAAC7X,EAAJ,GAAS8U,GAAb,EAAiB;AAClB;;AACD,YAAI,CAAC3Z,UAAU,CAACoB,SAAZ,IAA0BuY,GAAG,IAAI+C,GAAG,CAAC7X,EAAzC,EAA6C;;AAC7C,YAAI8M,KAAJ,EAAW;AACT,cAAIkW,OAAO,GAAGlW,KAAK,CAAC,CAAD,CAAL,IAAYA,KAAK,CAAC,CAAD,CAA/B;AACA,cAAImW,MAAM,GAAGnW,KAAK,CAAC,CAAD,CAAL,IAAYA,KAAK,CAAC,CAAD,CAA9B;AACA,cAAItD,SAAS,GAAGrO,UAAU,CAACmB,QAAX,GAAsB,CAAtB,GAA0B,CAAC,CAA3C;AACA,cAAI4mB,IAAI,GAAG;AAAC,kBAAM,CAAP;AAAU,iBAAK,CAAf;AAAkB,gBAAI,EAAtB;AAA0B,kBAAM;AAAhC,YAAoCF,OAAO,CAAC5gB,WAAR,EAApC,CAAX;AACA,cAAI+gB,MAAM,GAAG7T,QAAQ,CAACxC,KAAK,CAAC,CAAD,CAAL,GAAWmW,MAAZ,EAAoBC,IAApB,CAAR,GAAqC1Z,SAAS,GAAGrO,UAAU,CAACkU,MAAzE;AACA0T,UAAAA,SAAS,GAAGI,MAAM,CAAClT,QAAP,CAAgBiT,IAAhB,CAAZ;AACA,cAAIE,WAAW,GAAGJ,OAAO,GAAG,IAAItd,KAAJ,CAAUud,MAAM,CAACpmB,MAAP,GAAgBkmB,SAAS,CAAClmB,MAA1B,GAAmC,CAAnC,GAAuCiQ,KAAK,CAAC,CAAD,CAAL,CAASjQ,MAA1D,EAAkEwF,IAAlE,CAAuE,GAAvE,CAAH,GAAiF,EAA1G;;AACA,cAAI0gB,SAAS,CAAClhB,MAAV,CAAiB,CAAjB,MAAwB,GAA5B,EAAiC;AAC/BkhB,YAAAA,SAAS,GAAG,MAAMC,OAAN,GAAgBI,WAAhB,GAA8BL,SAAS,CAAC3X,MAAV,CAAiB,CAAjB,CAA1C;AACD,WAFD,MAEO;AACL2X,YAAAA,SAAS,GAAGC,OAAO,GAAGI,WAAV,GAAwBL,SAApC;AACD;;AACD,cAAI5K,IAAI,GAAGhb,GAAG,CAAC0a,GAAG,CAAC9X,IAAL,EAAWmD,KAAX,CAAd;AACA,cAAIkV,EAAE,GAAGjb,GAAG,CAAC0a,GAAG,CAAC9X,IAAL,EAAW+U,GAAX,CAAZ;AACAxX,UAAAA,EAAE,CAACuQ,YAAH,CAAgBkV,SAAhB,EAA2B5K,IAA3B,EAAiCC,EAAjC;AACD,SAhBD,MAgBO;AACL;AACD;;AACD9a,QAAAA,EAAE,CAACkF,SAAH,CAAarF,GAAG,CAAC0a,GAAG,CAAC9X,IAAL,EAAWmD,KAAK,GAAG6f,SAAS,CAAClmB,MAAlB,GAA2B,CAAtC,CAAhB;AACD,OAjhBW;AAkhBZwmB,MAAAA,cAAc,EAAE,UAAS/lB,EAAT,EAAanC,UAAb,EAAyB+C,GAAzB,EAA8B;AAC5C,YAAIoK,kBAAkB,GAAGpK,GAAG,CAACoK,kBAA7B;;AACA,YAAI,CAACA,kBAAL,EAAyB;AAAE;AAAS;;AACpC,YAAI+G,MAAM,GAAGlU,UAAU,CAACkU,MAAxB;;AACA,YAAIA,MAAM,IAAIlU,UAAU,CAAC+W,gBAAzB,EAA2C;AACzChU,UAAAA,GAAG,CAACoK,kBAAJ,CAAuBkJ,cAAvB,GAAwCnC,MAAxC;AACD,SAFD,MAEO;AACLA,UAAAA,MAAM,GAAGnR,GAAG,CAACoK,kBAAJ,CAAuBkJ,cAAvB,IAAyCnC,MAAlD;AACD;;AACDgU,QAAAA,cAAc,CAAC/lB,EAAD,EAAKY,GAAL,EAAUmR,MAAV,EAAkB;AAAM;AAAxB,SAAd;AACD,OA5hBW;AA6hBZwO,MAAAA,MAAM,EAAE,UAASvgB,EAAT,EAAanC,UAAb,EAAyB;AAC/BmC,QAAAA,EAAE,CAAC0gB,UAAH,CAAc1gB,EAAE,CAACoF,SAAH,GAAe3C,IAA7B,EAAmC5E,UAAU,CAACM,WAA9C;AACD,OA/hBW;AAgiBZmR,MAAAA,cAAc,EAAEA;AAhiBJ,KAAd;;AAmiBA,aAASiC,YAAT,CAAsB9R,IAAtB,EAA4B2f,EAA5B,EAAgC;AAC9B/Z,MAAAA,OAAO,CAAC5F,IAAD,CAAP,GAAgB2f,EAAhB;AACD;AAED;AACJ;AACA;;AAEI;AACJ;AACA;AACA;;;AACI,aAAStH,mBAAT,CAA6B9X,EAA7B,EAAiCua,GAAjC,EAAsC;AACpC,UAAI3Z,GAAG,GAAGZ,EAAE,CAACW,KAAH,CAASC,GAAnB;AACA,UAAIolB,gBAAgB,GAAGplB,GAAG,CAACqE,UAAJ,IAAkBrE,GAAG,CAAC2K,UAA7C;AACA,UAAI9I,IAAI,GAAG6T,IAAI,CAACC,GAAL,CAASD,IAAI,CAAC8L,GAAL,CAASpiB,EAAE,CAAC0G,SAAH,EAAT,EAAyB6T,GAAG,CAAC9X,IAA7B,CAAT,EAA6CzC,EAAE,CAAC2G,QAAH,EAA7C,CAAX;AACA,UAAIsf,KAAK,GAAG3jB,UAAU,CAACtC,EAAD,EAAKyC,IAAL,CAAV,GAAuB,CAAvB,GAA2B,CAAC,CAACujB,gBAAzC;AACA,UAAItjB,EAAE,GAAG4T,IAAI,CAACC,GAAL,CAASD,IAAI,CAAC8L,GAAL,CAAS,CAAT,EAAY7H,GAAG,CAAC7X,EAAhB,CAAT,EAA8BujB,KAA9B,CAAT;AACA,aAAOpmB,GAAG,CAAC4C,IAAD,EAAOC,EAAP,CAAV;AACD;;AACD,aAAS+R,QAAT,CAAkB+K,IAAlB,EAAwB;AACtB,UAAI0G,GAAG,GAAG,EAAV;;AACA,WAAK,IAAIC,IAAT,IAAiB3G,IAAjB,EAAuB;AACrB,YAAIA,IAAI,CAAC4G,cAAL,CAAoBD,IAApB,CAAJ,EAA+B;AAC7BD,UAAAA,GAAG,CAACC,IAAD,CAAH,GAAY3G,IAAI,CAAC2G,IAAD,CAAhB;AACD;AACF;;AACD,aAAOD,GAAP;AACD;;AACD,aAAS/gB,YAAT,CAAsBoV,GAAtB,EAA2B8L,UAA3B,EAAuCC,QAAvC,EAAiD;AAC/C,UAAI,OAAOD,UAAP,KAAsB,QAA1B,EAAoC;AAClCC,QAAAA,QAAQ,GAAGD,UAAU,CAAC3jB,EAAtB;AACA2jB,QAAAA,UAAU,GAAGA,UAAU,CAAC5jB,IAAxB;AACD;;AACD,aAAO5C,GAAG,CAAC0a,GAAG,CAAC9X,IAAJ,GAAW4jB,UAAZ,EAAwB9L,GAAG,CAAC7X,EAAJ,GAAS4jB,QAAjC,CAAV;AACD;;AACD,aAAS1S,cAAT,CAAwBhX,IAAxB,EAA8BmE,MAA9B,EAAsChE,OAAtC,EAA+C+N,UAA/C,EAA2D;AACzD;AACA;AACA;AACA,UAAI0E,KAAJ;AAAA,UAAWsE,OAAO,GAAG,EAArB;AAAA,UAAyBD,IAAI,GAAG,EAAhC;;AACA,WAAK,IAAI1R,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGpB,MAAM,CAACxB,MAA3B,EAAmC4C,CAAC,EAApC,EAAwC;AACtC,YAAI6M,OAAO,GAAGjO,MAAM,CAACoB,CAAD,CAApB;;AACA,YAAIpF,OAAO,IAAI,QAAX,IAAuBiS,OAAO,CAACjS,OAAR,IAAmB,QAA1C,IACAiS,OAAO,CAACjS,OAAR,IAAmBiS,OAAO,CAACjS,OAAR,IAAmBA,OADtC,IAEA+N,UAAU,CAAC7M,QAAX,IAAuB+Q,OAAO,CAACnS,IAAR,IAAgB,QAFvC,IAGA,EAAE2S,KAAK,GAAG+W,YAAY,CAAC3pB,IAAD,EAAOoS,OAAO,CAACpS,IAAf,CAAtB,CAHJ,EAGiD;AAAE;AAAW;;AAC9D,YAAI4S,KAAK,IAAI,SAAb,EAAwB;AAAEsE,UAAAA,OAAO,CAACnR,IAAR,CAAaqM,OAAb;AAAwB;;AAClD,YAAIQ,KAAK,IAAI,MAAb,EAAqB;AAAEqE,UAAAA,IAAI,CAAClR,IAAL,CAAUqM,OAAV;AAAqB;AAC7C;;AACD,aAAO;AACL8E,QAAAA,OAAO,EAAEA,OAAO,CAACvU,MAAR,IAAkBuU,OADtB;AAELD,QAAAA,IAAI,EAAEA,IAAI,CAACtU,MAAL,IAAesU;AAFhB,OAAP;AAID;;AACD,aAAS0S,YAAT,CAAsBC,OAAtB,EAA+BC,MAA/B,EAAuC;AACrC,UAAIA,MAAM,CAACnY,KAAP,CAAa,CAAC,EAAd,KAAqB,aAAzB,EAAwC;AACtC;AACA,YAAIoY,SAAS,GAAGD,MAAM,CAAClnB,MAAP,GAAgB,EAAhC;AACA,YAAIonB,aAAa,GAAGH,OAAO,CAAClY,KAAR,CAAc,CAAd,EAAiBoY,SAAjB,CAApB;AACA,YAAIE,YAAY,GAAGH,MAAM,CAACnY,KAAP,CAAa,CAAb,EAAgBoY,SAAhB,CAAnB;AACA,eAAOC,aAAa,IAAIC,YAAjB,IAAiCJ,OAAO,CAACjnB,MAAR,GAAiBmnB,SAAlD,GAA8D,MAA9D,GACAE,YAAY,CAAC7f,OAAb,CAAqB4f,aAArB,KAAuC,CAAvC,GAA2C,SAA3C,GAAuD,KAD9D;AAED,OAPD,MAOO;AACL,eAAOH,OAAO,IAAIC,MAAX,GAAoB,MAApB,GACAA,MAAM,CAAC1f,OAAP,CAAeyf,OAAf,KAA2B,CAA3B,GAA+B,SAA/B,GAA2C,KADlD;AAED;AACF;;AACD,aAASvS,QAAT,CAAkBrX,IAAlB,EAAwB;AACtB,UAAI4S,KAAK,GAAG,gBAAgBC,IAAhB,CAAqB7S,IAArB,CAAZ;AACA,UAAIuP,iBAAiB,GAAGqD,KAAK,GAAGA,KAAK,CAAC,CAAD,CAAR,GAAc5S,IAAI,CAAC0R,KAAL,CAAW,CAAC,CAAZ,CAA3C;;AACA,UAAInC,iBAAiB,CAAC5M,MAAlB,GAA2B,CAA/B,EAAiC;AAC/B,gBAAO4M,iBAAP;AACE,eAAK,MAAL;AACEA,YAAAA,iBAAiB,GAAC,IAAlB;AACA;;AACF,eAAK,SAAL;AACEA,YAAAA,iBAAiB,GAAC,GAAlB;AACA;;AACF;AACEA,YAAAA,iBAAiB,GAAC,EAAlB;AACA;AATJ;AAWD;;AACD,aAAOA,iBAAP;AACD;;AACD,aAAS4Y,QAAT,CAAkB/kB,EAAlB,EAAsBof,EAAtB,EAA0BrN,MAA1B,EAAkC;AAChC,aAAO,YAAW;AAChB,aAAK,IAAI5P,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG4P,MAApB,EAA4B5P,CAAC,EAA7B,EAAiC;AAC/Bid,UAAAA,EAAE,CAACpf,EAAD,CAAF;AACD;AACF,OAJD;AAKD;;AACD,aAAS6X,UAAT,CAAoB0C,GAApB,EAAyB;AACvB,aAAO1a,GAAG,CAAC0a,GAAG,CAAC9X,IAAL,EAAW8X,GAAG,CAAC7X,EAAf,CAAV;AACD;;AACD,aAASsG,WAAT,CAAqB6d,IAArB,EAA2BC,IAA3B,EAAiC;AAC/B,aAAOD,IAAI,CAACnkB,EAAL,IAAWokB,IAAI,CAACpkB,EAAhB,IAAsBmkB,IAAI,CAACpkB,IAAL,IAAaqkB,IAAI,CAACrkB,IAA/C;AACD;;AACD,aAASiW,cAAT,CAAwBmO,IAAxB,EAA8BC,IAA9B,EAAoC;AAClC,UAAID,IAAI,CAACpkB,IAAL,GAAYqkB,IAAI,CAACrkB,IAArB,EAA2B;AACzB,eAAO,IAAP;AACD;;AACD,UAAIokB,IAAI,CAACpkB,IAAL,IAAaqkB,IAAI,CAACrkB,IAAlB,IAA0BokB,IAAI,CAACnkB,EAAL,GAAUokB,IAAI,CAACpkB,EAA7C,EAAiD;AAC/C,eAAO,IAAP;AACD;;AACD,aAAO,KAAP;AACD;;AACD,aAASwW,SAAT,CAAmB2N,IAAnB,EAAyBC,IAAzB,EAA+B;AAC7B,UAAIC,SAAS,CAACxnB,MAAV,GAAmB,CAAvB,EAA0B;AACxBunB,QAAAA,IAAI,GAAG5N,SAAS,CAAC8N,KAAV,CAAgB1jB,SAAhB,EAA2B8E,KAAK,CAAC8B,SAAN,CAAgBoE,KAAhB,CAAsB2Y,IAAtB,CAA2BF,SAA3B,EAAsC,CAAtC,CAA3B,CAAP;AACD;;AACD,aAAOrO,cAAc,CAACmO,IAAD,EAAOC,IAAP,CAAd,GAA6BD,IAA7B,GAAoCC,IAA3C;AACD;;AACD,aAAS3N,SAAT,CAAmB0N,IAAnB,EAAyBC,IAAzB,EAA+B;AAC7B,UAAIC,SAAS,CAACxnB,MAAV,GAAmB,CAAvB,EAA0B;AACxBunB,QAAAA,IAAI,GAAG3N,SAAS,CAAC6N,KAAV,CAAgB1jB,SAAhB,EAA2B8E,KAAK,CAAC8B,SAAN,CAAgBoE,KAAhB,CAAsB2Y,IAAtB,CAA2BF,SAA3B,EAAsC,CAAtC,CAA3B,CAAP;AACD;;AACD,aAAOrO,cAAc,CAACmO,IAAD,EAAOC,IAAP,CAAd,GAA6BA,IAA7B,GAAoCD,IAA3C;AACD;;AACD,aAASpL,eAAT,CAAyBoL,IAAzB,EAA+BC,IAA/B,EAAqCI,IAArC,EAA2C;AACzC;AACA,UAAIC,WAAW,GAAGzO,cAAc,CAACmO,IAAD,EAAOC,IAAP,CAAhC;AACA,UAAIM,WAAW,GAAG1O,cAAc,CAACoO,IAAD,EAAOI,IAAP,CAAhC;AACA,aAAOC,WAAW,IAAIC,WAAtB;AACD;;AACD,aAAS9kB,UAAT,CAAoBtC,EAApB,EAAwBye,OAAxB,EAAiC;AAC/B,aAAOze,EAAE,CAACuC,OAAH,CAAWkc,OAAX,EAAoBlf,MAA3B;AACD;;AACD,aAAS8nB,IAAT,CAAcC,CAAd,EAAiB;AACf,UAAIA,CAAC,CAACD,IAAN,EAAY;AACV,eAAOC,CAAC,CAACD,IAAF,EAAP;AACD;;AACD,aAAOC,CAAC,CAAC1oB,OAAF,CAAU,YAAV,EAAwB,EAAxB,CAAP;AACD;;AACD,aAAS6Y,WAAT,CAAqB6P,CAArB,EAAwB;AACtB,aAAOA,CAAC,CAAC1oB,OAAF,CAAU,2BAAV,EAAuC,MAAvC,CAAP;AACD;;AACD,aAASimB,kBAAT,CAA4B7kB,EAA5B,EAAgCye,OAAhC,EAAyC8I,MAAzC,EAAiD;AAC/C,UAAI3L,KAAK,GAAGtZ,UAAU,CAACtC,EAAD,EAAKye,OAAL,CAAtB;AACA,UAAIiF,MAAM,GAAG,IAAItb,KAAJ,CAAUmf,MAAM,GAAC3L,KAAP,GAAa,CAAvB,EAA0B7W,IAA1B,CAA+B,GAA/B,CAAb;AACA/E,MAAAA,EAAE,CAACkF,SAAH,CAAarF,GAAG,CAAC4e,OAAD,EAAU7C,KAAV,CAAhB;AACA5b,MAAAA,EAAE,CAACuQ,YAAH,CAAgBmT,MAAhB,EAAwB1jB,EAAE,CAACoF,SAAH,EAAxB;AACD,KAtvFkB,CAuvFnB;AACA;AACA;AACA;AACA;AACA;;;AACA,aAASqf,WAAT,CAAqBzkB,EAArB,EAAyBoW,YAAzB,EAAuC;AACrC,UAAI/F,UAAU,GAAG,EAAjB;AAAA,UAAqBrO,MAAM,GAAGhC,EAAE,CAACiC,cAAH,EAA9B;AACA,UAAIgG,IAAI,GAAG4P,UAAU,CAAC7X,EAAE,CAACwnB,OAAH,CAAWpR,YAAX,CAAD,CAArB;AACA,UAAIqR,SAAS,GAAG,CAACze,WAAW,CAACoN,YAAD,EAAenO,IAAf,CAA5B;AACA,UAAIyf,OAAO,GAAG1nB,EAAE,CAACoF,SAAH,CAAa,MAAb,CAAd;AACA,UAAIuiB,SAAS,GAAGC,QAAQ,CAAC5lB,MAAD,EAAS0lB,OAAT,CAAxB;AACA,UAAIG,UAAU,GAAG7e,WAAW,CAAChH,MAAM,CAAC2lB,SAAD,CAAN,CAAkB1f,IAAnB,EAAyBjG,MAAM,CAAC2lB,SAAD,CAAN,CAAkBnlB,MAA3C,CAA5B;AACA,UAAI4f,GAAG,GAAGpgB,MAAM,CAACzC,MAAP,GAAgB,CAA1B;AACA,UAAIoQ,KAAK,GAAGyS,GAAG,GAAGuF,SAAN,GAAkBA,SAAlB,GAA8BvF,GAA9B,GAAoC,CAAhD;AACA,UAAIwD,IAAI,GAAG5jB,MAAM,CAAC2N,KAAD,CAAN,CAAcnN,MAAzB;AAEA,UAAIkE,SAAS,GAAG4P,IAAI,CAACC,GAAL,CAASqP,IAAI,CAACnjB,IAAd,EAAoBwF,IAAI,CAACxF,IAAzB,CAAhB;AACA,UAAIkE,QAAQ,GAAG2P,IAAI,CAAC8L,GAAL,CAASwD,IAAI,CAACnjB,IAAd,EAAoBwF,IAAI,CAACxF,IAAzB,CAAf;AACA,UAAIqlB,MAAM,GAAGlC,IAAI,CAACljB,EAAlB;AAAA,UAAsBqlB,MAAM,GAAG9f,IAAI,CAACvF,EAApC;AAEA,UAAI4Q,GAAG,GAAGtR,MAAM,CAAC2N,KAAD,CAAN,CAAc1H,IAAd,CAAmBvF,EAAnB,GAAwBolB,MAAlC;AACA,UAAIE,MAAM,GAAGD,MAAM,GAAGD,MAAtB;;AACA,UAAIxU,GAAG,GAAG,CAAN,IAAW0U,MAAM,IAAI,CAAzB,EAA4B;AAC1BF,QAAAA,MAAM;;AACN,YAAI,CAACL,SAAL,EAAgB;AAAEM,UAAAA,MAAM;AAAK;AAC9B,OAHD,MAGO,IAAIzU,GAAG,GAAG,CAAN,IAAW0U,MAAM,IAAI,CAAzB,EAA4B;AACjCF,QAAAA,MAAM;;AACN,YAAI,CAACD,UAAL,EAAiB;AAAEE,UAAAA,MAAM;AAAK;AAC/B,OAHM,MAGA,IAAIzU,GAAG,GAAG,CAAN,IAAW0U,MAAM,IAAI,CAAC,CAA1B,EAA6B;AAClCF,QAAAA,MAAM;AACNC,QAAAA,MAAM;AACP;;AACD,WAAK,IAAItlB,IAAI,GAAGiE,SAAhB,EAA2BjE,IAAI,IAAIkE,QAAnC,EAA6ClE,IAAI,EAAjD,EAAqD;AACnD,YAAIL,KAAK,GAAG;AAACI,UAAAA,MAAM,EAAE,IAAI3C,GAAJ,CAAQ4C,IAAR,EAAcqlB,MAAd,CAAT;AAAgC7f,UAAAA,IAAI,EAAE,IAAIpI,GAAJ,CAAQ4C,IAAR,EAAcslB,MAAd;AAAtC,SAAZ;AACA1X,QAAAA,UAAU,CAAC1N,IAAX,CAAgBP,KAAhB;AACD;;AACDpC,MAAAA,EAAE,CAACyZ,aAAH,CAAiBpJ,UAAjB;AACA+F,MAAAA,YAAY,CAAC1T,EAAb,GAAkBqlB,MAAlB;AACAnC,MAAAA,IAAI,CAACljB,EAAL,GAAUolB,MAAV;AACA,aAAOlC,IAAP;AACD;;AACD,aAASpD,eAAT,CAAyBxiB,EAAzB,EAA6BiI,IAA7B,EAAmC6Z,MAAnC,EAA2C;AACzC,UAAInW,GAAG,GAAG,EAAV;;AACA,WAAK,IAAIxJ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG2f,MAApB,EAA4B3f,CAAC,EAA7B,EAAiC;AAC/B,YAAI8lB,QAAQ,GAAG9iB,YAAY,CAAC8C,IAAD,EAAO9F,CAAP,EAAU,CAAV,CAA3B;AACAwJ,QAAAA,GAAG,CAAChJ,IAAJ,CAAS;AAACH,UAAAA,MAAM,EAAEylB,QAAT;AAAmBhgB,UAAAA,IAAI,EAAEggB;AAAzB,SAAT;AACD;;AACDjoB,MAAAA,EAAE,CAACyZ,aAAH,CAAiB9N,GAAjB,EAAsB,CAAtB;AACD,KAxyFkB,CAyyFnB;;;AACA,aAASic,QAAT,CAAkB5lB,MAAlB,EAA0B2G,MAA1B,EAAkC6O,GAAlC,EAAuC;AACrC,WAAK,IAAIrV,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,MAAM,CAACzC,MAA3B,EAAmC4C,CAAC,EAApC,EAAwC;AACtC,YAAI+lB,QAAQ,GAAG1Q,GAAG,IAAI,MAAP,IAAiBxO,WAAW,CAAChH,MAAM,CAACG,CAAD,CAAN,CAAUK,MAAX,EAAmBmG,MAAnB,CAA3C;AACA,YAAIwf,MAAM,GAAG3Q,GAAG,IAAI,QAAP,IAAmBxO,WAAW,CAAChH,MAAM,CAACG,CAAD,CAAN,CAAU8F,IAAX,EAAiBU,MAAjB,CAA3C;;AACA,YAAIuf,QAAQ,IAAIC,MAAhB,EAAwB;AACtB,iBAAOhmB,CAAP;AACD;AACF;;AACD,aAAO,CAAC,CAAR;AACD;;AACD,aAASmiB,oBAAT,CAA8BtkB,EAA9B,EAAkCY,GAAlC,EAAuC;AACrC,UAAI6K,aAAa,GAAG7K,GAAG,CAAC6K,aAAxB;;AACA,UAAI2c,2BAA2B,GAAG,YAAW;AAC3C,YAAI/X,UAAU,GAAGrQ,EAAE,CAACiC,cAAH,EAAjB;AACA,YAAI2D,KAAK,GAAIyK,UAAU,CAAC,CAAD,CAAvB;AACA,YAAImH,GAAG,GAAGnH,UAAU,CAACA,UAAU,CAAC9Q,MAAX,GAAkB,CAAnB,CAApB;AACA,YAAI8W,cAAc,GAAGqC,cAAc,CAAC9S,KAAK,CAACpD,MAAP,EAAeoD,KAAK,CAACqC,IAArB,CAAd,GAA2CrC,KAAK,CAACpD,MAAjD,GAA0DoD,KAAK,CAACqC,IAArF;AACA,YAAImO,YAAY,GAAGsC,cAAc,CAAClB,GAAG,CAAChV,MAAL,EAAagV,GAAG,CAACvP,IAAjB,CAAd,GAAuCuP,GAAG,CAACvP,IAA3C,GAAkDuP,GAAG,CAAChV,MAAzE;AACA,eAAO,CAAC6T,cAAD,EAAiBD,YAAjB,CAAP;AACD,OAPD;;AAQA,UAAIiS,wBAAwB,GAAG,YAAW;AACxC,YAAIhS,cAAc,GAAGrW,EAAE,CAACoF,SAAH,EAArB;AACA,YAAIgR,YAAY,GAAGpW,EAAE,CAACoF,SAAH,EAAnB;AACA,YAAIkjB,KAAK,GAAG7c,aAAa,CAACD,WAA1B;;AACA,YAAI8c,KAAJ,EAAW;AACT,cAAIC,KAAK,GAAGD,KAAK,CAACC,KAAlB;AACA,cAAIzG,MAAM,GAAGwG,KAAK,CAACxG,MAAnB;AACA1L,UAAAA,YAAY,GAAGvW,GAAG,CAACwW,cAAc,CAAC5T,IAAf,GAAsBqf,MAAvB,EAA+BzL,cAAc,CAAC3T,EAAf,GAAoB6lB,KAAnD,CAAlB;AACA,cAAIlY,UAAU,GAAG,EAAjB,CAJS,CAKT;AACA;;AACA,eAAK,IAAIlO,CAAC,GAAGkU,cAAc,CAAC5T,IAA5B,EAAkCN,CAAC,GAAGiU,YAAY,CAAC3T,IAAnD,EAAyDN,CAAC,EAA1D,EAA8D;AAC5D,gBAAIK,MAAM,GAAG3C,GAAG,CAACsC,CAAD,EAAIkU,cAAc,CAAC3T,EAAnB,CAAhB;AACA,gBAAIuF,IAAI,GAAGpI,GAAG,CAACsC,CAAD,EAAIiU,YAAY,CAAC1T,EAAjB,CAAd;AACA,gBAAIN,KAAK,GAAG;AAACI,cAAAA,MAAM,EAAEA,MAAT;AAAiByF,cAAAA,IAAI,EAAEA;AAAvB,aAAZ;AACAoI,YAAAA,UAAU,CAAC1N,IAAX,CAAgBP,KAAhB;AACD;;AACDpC,UAAAA,EAAE,CAACyZ,aAAH,CAAiBpJ,UAAjB;AACD,SAdD,MAcO;AACL,cAAIzK,KAAK,GAAG6F,aAAa,CAACoX,UAAd,CAAyB9Z,IAAzB,EAAZ;AACA,cAAIyO,GAAG,GAAG/L,aAAa,CAACqX,QAAd,CAAuB/Z,IAAvB,EAAV;AACA,cAAItG,IAAI,GAAG+U,GAAG,CAAC/U,IAAJ,GAAWmD,KAAK,CAACnD,IAA5B;AACA,cAAIC,EAAE,GAAG8U,GAAG,CAAC9U,EAAJ,GAASkD,KAAK,CAAClD,EAAxB;AACA0T,UAAAA,YAAY,GAAG;AAAC3T,YAAAA,IAAI,EAAE2T,YAAY,CAAC3T,IAAb,GAAoBA,IAA3B;AAAiCC,YAAAA,EAAE,EAAED,IAAI,GAAG2T,YAAY,CAAC1T,EAAhB,GAAqBA,EAAE,GAAG0T,YAAY,CAAC1T;AAAhF,WAAf;;AACA,cAAI+I,aAAa,CAACnN,UAAlB,EAA8B;AAC5B+X,YAAAA,cAAc,GAAGxW,GAAG,CAACwW,cAAc,CAAC5T,IAAhB,EAAsB,CAAtB,CAApB;AACA2T,YAAAA,YAAY,GAAGvW,GAAG,CAACuW,YAAY,CAAC3T,IAAd,EAAoBH,UAAU,CAACtC,EAAD,EAAKoW,YAAY,CAAC3T,IAAlB,CAA9B,CAAlB;AACD;;AACDzC,UAAAA,EAAE,CAACkgB,YAAH,CAAgB7J,cAAhB,EAAgCD,YAAhC;AACD;;AACD,eAAO,CAACC,cAAD,EAAiBD,YAAjB,CAAP;AACD,OA/BD;;AAgCA,UAAI,CAACxV,GAAG,CAAC2K,UAAT,EAAqB;AACrB;AACE,eAAO8c,wBAAwB,EAA/B;AACD,OAHD,MAGO;AACL,eAAOD,2BAA2B,EAAlC;AACD;AACF,KAp2FkB,CAq2FnB;AACA;;;AACA,aAASxF,mBAAT,CAA6B5iB,EAA7B,EAAiCY,GAAjC,EAAsC;AACpC,UAAI4B,MAAM,GAAG5B,GAAG,CAAC+K,GAAJ,CAAQnJ,MAArB;AACA,UAAIyF,IAAI,GAAGrH,GAAG,CAAC+K,GAAJ,CAAQ1D,IAAnB,CAFoC,CAGpC;;AACA,UAAIrH,GAAG,CAAC8K,cAAR,EAAwB;AACtBzD,QAAAA,IAAI,GAAGjI,EAAE,CAAC0kB,YAAH,CAAgB1kB,EAAE,CAAC2kB,YAAH,CAAgBniB,MAAhB,IAA0B5B,GAAG,CAAC8K,cAAJ,CAAmBnM,MAA7D,CAAP;AACAqB,QAAAA,GAAG,CAAC8K,cAAJ,GAAqB,IAArB;AACD;;AACD9K,MAAAA,GAAG,CAAC6K,aAAJ,GAAoB;AAAC,sBAAczL,EAAE,CAAC6I,WAAH,CAAerG,MAAf,CAAf;AACC,oBAAYxC,EAAE,CAAC6I,WAAH,CAAeZ,IAAf,CADb;AAEC,kBAAU4P,UAAU,CAACrV,MAAD,CAFrB;AAGC,gBAAQqV,UAAU,CAAC5P,IAAD,CAHnB;AAIC,sBAAcrH,GAAG,CAAC2K,UAJnB;AAKC,sBAAc3K,GAAG,CAACtC,UALnB;AAMC,uBAAesC,GAAG,CAAC4K;AANpB,OAApB;AAOD;;AACD,aAASwT,eAAT,CAAyBhf,EAAzB,EAA6B4F,KAA7B,EAAoC4R,GAApC,EAAyC;AACvC,UAAI7L,GAAG,GAAG3L,EAAE,CAACW,KAAH,CAASC,GAAT,CAAa+K,GAAvB;AACA,UAAI1D,IAAI,GAAG0D,GAAG,CAAC1D,IAAf;AACA,UAAIzF,MAAM,GAAGmJ,GAAG,CAACnJ,MAAjB;AACA,UAAI6W,GAAJ;;AACA,UAAIX,cAAc,CAAClB,GAAD,EAAM5R,KAAN,CAAlB,EAAgC;AAC9ByT,QAAAA,GAAG,GAAG7B,GAAN;AACAA,QAAAA,GAAG,GAAG5R,KAAN;AACAA,QAAAA,KAAK,GAAGyT,GAAR;AACD;;AACD,UAAIX,cAAc,CAACzQ,IAAD,EAAOzF,MAAP,CAAlB,EAAkC;AAChCyF,QAAAA,IAAI,GAAGiR,SAAS,CAACtT,KAAD,EAAQqC,IAAR,CAAhB;AACAzF,QAAAA,MAAM,GAAG2W,SAAS,CAAC3W,MAAD,EAASgV,GAAT,CAAlB;AACD,OAHD,MAGO;AACLhV,QAAAA,MAAM,GAAG0W,SAAS,CAACtT,KAAD,EAAQpD,MAAR,CAAlB;AACAyF,QAAAA,IAAI,GAAGkR,SAAS,CAAClR,IAAD,EAAOuP,GAAP,CAAhB;AACAvP,QAAAA,IAAI,GAAG9C,YAAY,CAAC8C,IAAD,EAAO,CAAP,EAAU,CAAC,CAAX,CAAnB;;AACA,YAAIA,IAAI,CAACvF,EAAL,IAAW,CAAC,CAAZ,IAAiBuF,IAAI,CAACxF,IAAL,IAAazC,EAAE,CAAC0G,SAAH,EAAlC,EAAkD;AAChDuB,UAAAA,IAAI,GAAGpI,GAAG,CAACoI,IAAI,CAACxF,IAAL,GAAY,CAAb,EAAgBH,UAAU,CAACtC,EAAD,EAAKiI,IAAI,CAACxF,IAAL,GAAY,CAAjB,CAA1B,CAAV;AACD;AACF;;AACD,aAAO,CAACD,MAAD,EAASyF,IAAT,CAAP;AACD;AACD;AACJ;AACA;AACA;;;AACI,aAAS0M,iBAAT,CAA2B3U,EAA3B,EAA+B2L,GAA/B,EAAoCxL,IAApC,EAA0C;AACxC,UAAIS,GAAG,GAAGZ,EAAE,CAACW,KAAH,CAASC,GAAnB;AACA+K,MAAAA,GAAG,GAAGA,GAAG,IAAI/K,GAAG,CAAC+K,GAAjB;AACA,UAAIxL,IAAI,GAAGA,IAAI,IACbS,GAAG,CAACtC,UADK,GACQ,MADR,GACiBsC,GAAG,CAAC4K,WAAJ,GAAkB,OAAlB,GAA4B,MADxD;AAEA,UAAIyN,KAAK,GAAGG,eAAe,CAACpZ,EAAD,EAAK2L,GAAL,EAAUxL,IAAV,CAA3B;AACAH,MAAAA,EAAE,CAACyZ,aAAH,CAAiBR,KAAK,CAACjX,MAAvB,EAA+BiX,KAAK,CAACS,OAArC;AACA8O,MAAAA,gBAAgB,CAACxoB,EAAD,CAAhB;AACD;;AACD,aAASoZ,eAAT,CAAyBpZ,EAAzB,EAA6B2L,GAA7B,EAAkCxL,IAAlC,EAAwCqZ,SAAxC,EAAmD;AACjD,UAAIvR,IAAI,GAAG4P,UAAU,CAAClM,GAAG,CAAC1D,IAAL,CAArB;AACA,UAAIzF,MAAM,GAAGqV,UAAU,CAAClM,GAAG,CAACnJ,MAAL,CAAvB;;AACA,UAAIrC,IAAI,IAAI,MAAZ,EAAoB;AAClB,YAAIsoB,UAAU,GAAG,CAACjP,SAAD,IAAc,CAACd,cAAc,CAAC/M,GAAG,CAAC1D,IAAL,EAAW0D,GAAG,CAACnJ,MAAf,CAA7B,GAAsD,CAAtD,GAA0D,CAA3E;AACA,YAAIkmB,YAAY,GAAGhQ,cAAc,CAAC/M,GAAG,CAAC1D,IAAL,EAAW0D,GAAG,CAACnJ,MAAf,CAAd,GAAuC,CAAvC,GAA2C,CAA9D;AACAyF,QAAAA,IAAI,GAAG9C,YAAY,CAACwG,GAAG,CAAC1D,IAAL,EAAW,CAAX,EAAcwgB,UAAd,CAAnB;AACAjmB,QAAAA,MAAM,GAAG2C,YAAY,CAACwG,GAAG,CAACnJ,MAAL,EAAa,CAAb,EAAgBkmB,YAAhB,CAArB;AACA,eAAO;AACL1mB,UAAAA,MAAM,EAAE,CAAC;AAACQ,YAAAA,MAAM,EAAEA,MAAT;AAAiByF,YAAAA,IAAI,EAAEA;AAAvB,WAAD,CADH;AAELyR,UAAAA,OAAO,EAAE;AAFJ,SAAP;AAID,OATD,MASO,IAAIvZ,IAAI,IAAI,MAAZ,EAAoB;AACzB,YAAI,CAACuY,cAAc,CAAC/M,GAAG,CAAC1D,IAAL,EAAW0D,GAAG,CAACnJ,MAAf,CAAnB,EAA2C;AACzCA,UAAAA,MAAM,CAACE,EAAP,GAAY,CAAZ;AAEA,cAAIiE,QAAQ,GAAG3G,EAAE,CAAC2G,QAAH,EAAf;;AACA,cAAIsB,IAAI,CAACxF,IAAL,GAAYkE,QAAhB,EAA0B;AACxBsB,YAAAA,IAAI,CAACxF,IAAL,GAAYkE,QAAZ;AACD;;AACDsB,UAAAA,IAAI,CAACvF,EAAL,GAAUJ,UAAU,CAACtC,EAAD,EAAKiI,IAAI,CAACxF,IAAV,CAApB;AACD,SARD,MAQO;AACLwF,UAAAA,IAAI,CAACvF,EAAL,GAAU,CAAV;AACAF,UAAAA,MAAM,CAACE,EAAP,GAAYJ,UAAU,CAACtC,EAAD,EAAKwC,MAAM,CAACC,IAAZ,CAAtB;AACD;;AACD,eAAO;AACLT,UAAAA,MAAM,EAAE,CAAC;AAACQ,YAAAA,MAAM,EAAEA,MAAT;AAAiByF,YAAAA,IAAI,EAAEA;AAAvB,WAAD,CADH;AAELyR,UAAAA,OAAO,EAAE;AAFJ,SAAP;AAID,OAjBM,MAiBA,IAAIvZ,IAAI,IAAI,OAAZ,EAAqB;AAC1B,YAAI2V,GAAG,GAAGQ,IAAI,CAACC,GAAL,CAAS/T,MAAM,CAACC,IAAhB,EAAsBwF,IAAI,CAACxF,IAA3B,CAAV;AAAA,YACIoT,IAAI,GAAGS,IAAI,CAACC,GAAL,CAAS/T,MAAM,CAACE,EAAhB,EAAoBuF,IAAI,CAACvF,EAAzB,CADX;AAAA,YAEImI,MAAM,GAAGyL,IAAI,CAAC8L,GAAL,CAAS5f,MAAM,CAACC,IAAhB,EAAsBwF,IAAI,CAACxF,IAA3B,CAFb;AAAA,YAGIkmB,KAAK,GAAGrS,IAAI,CAAC8L,GAAL,CAAS5f,MAAM,CAACE,EAAhB,EAAoBuF,IAAI,CAACvF,EAAzB,IAA+B,CAH3C;AAIA,YAAIof,MAAM,GAAGjX,MAAM,GAAGiL,GAAT,GAAe,CAA5B;AACA,YAAI4D,OAAO,GAAGzR,IAAI,CAACxF,IAAL,IAAaqT,GAAb,GAAmB,CAAnB,GAAuBgM,MAAM,GAAG,CAA9C;AACA,YAAI9f,MAAM,GAAG,EAAb;;AACA,aAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG2f,MAApB,EAA4B3f,CAAC,EAA7B,EAAiC;AAC/BH,UAAAA,MAAM,CAACW,IAAP,CAAY;AACVH,YAAAA,MAAM,EAAE3C,GAAG,CAACiW,GAAG,GAAG3T,CAAP,EAAU0T,IAAV,CADD;AAEV5N,YAAAA,IAAI,EAAEpI,GAAG,CAACiW,GAAG,GAAG3T,CAAP,EAAUwmB,KAAV;AAFC,WAAZ;AAID;;AACD,eAAO;AACL3mB,UAAAA,MAAM,EAAEA,MADH;AAEL0X,UAAAA,OAAO,EAAEA;AAFJ,SAAP;AAID;AACF;;AACD,aAASkP,OAAT,CAAiB5oB,EAAjB,EAAqB;AACnB,UAAIua,GAAG,GAAGva,EAAE,CAACoF,SAAH,CAAa,MAAb,CAAV;;AACA,UAAIpF,EAAE,CAACmgB,YAAH,GAAkB5gB,MAAlB,IAA4B,CAAhC,EAAmC;AACjC;AACA;AACAgb,QAAAA,GAAG,GAAGrB,SAAS,CAACqB,GAAD,EAAMva,EAAE,CAACoF,SAAH,CAAa,QAAb,CAAN,CAAf;AACD;;AACD,aAAOmV,GAAP;AACD;AAED;AACJ;AACA;AACA;AACA;;;AACI,aAASlL,cAAT,CAAwBrP,EAAxB,EAA4B6oB,QAA5B,EAAsC;AACpC,UAAIjoB,GAAG,GAAGZ,EAAE,CAACW,KAAH,CAASC,GAAnB;;AACA,UAAIioB,QAAQ,KAAK,KAAjB,EAAwB;AACtB7oB,QAAAA,EAAE,CAACkF,SAAH,CAAa4S,mBAAmB,CAAC9X,EAAD,EAAKY,GAAG,CAAC+K,GAAJ,CAAQ1D,IAAb,CAAhC;AACD;;AACD2a,MAAAA,mBAAmB,CAAC5iB,EAAD,EAAKY,GAAL,CAAnB;AACAA,MAAAA,GAAG,CAAC2K,UAAJ,GAAiB,KAAjB;AACA3K,MAAAA,GAAG,CAACtC,UAAJ,GAAiB,KAAjB;AACAsC,MAAAA,GAAG,CAAC4K,WAAJ,GAAkB,KAAlB;AACA,UAAI,CAAC5K,GAAG,CAACqE,UAAT,EAAqBvI,UAAU,CAACwD,MAAX,CAAkBF,EAAlB,EAAsB,iBAAtB,EAAyC;AAACG,QAAAA,IAAI,EAAE;AAAP,OAAzC;AACrB2oB,MAAAA,eAAe,CAACloB,GAAD,CAAf;AACD,KAt+FkB,CAw+FnB;AACA;AACA;AACA;;;AACA,aAAS2Y,UAAT,CAAoBvZ,EAApB,EAAwB+Y,QAAxB,EAAkCC,MAAlC,EAA0C;AACxC,UAAI+P,SAAS,GAAG/oB,EAAE,CAAC0f,QAAH,CAAY3G,QAAZ,EAAsBC,MAAtB,CAAhB,CADwC,CAExC;;AACA,UAAI,SAAS7V,IAAT,CAAc4lB,SAAd,CAAJ,EAA8B;AAC5B,YAAIC,KAAK,GAAGD,SAAS,CAACtkB,KAAV,CAAgB,IAAhB,CAAZ,CAD4B,CAE5B;;AACAukB,QAAAA,KAAK,CAACxY,GAAN,GAH4B,CAK5B;AACA;AACA;;AACA,YAAI/N,IAAJ,CAR4B,CAS5B;AACA;;AACA,aAAK,IAAIA,IAAI,GAAGumB,KAAK,CAACxY,GAAN,EAAhB,EAA6BwY,KAAK,CAACzpB,MAAN,GAAe,CAAf,IAAoBkD,IAApB,IAA4BwE,kBAAkB,CAACxE,IAAD,CAA3E,EAAmFA,IAAI,GAAGumB,KAAK,CAACxY,GAAN,EAA1F,EAAuG;AACrGwI,UAAAA,MAAM,CAACvW,IAAP;AACAuW,UAAAA,MAAM,CAACtW,EAAP,GAAY,CAAZ;AACD,SAd2B,CAe5B;;;AACA,YAAID,IAAJ,EAAU;AACRuW,UAAAA,MAAM,CAACvW,IAAP;AACAuW,UAAAA,MAAM,CAACtW,EAAP,GAAYJ,UAAU,CAACtC,EAAD,EAAKgZ,MAAM,CAACvW,IAAZ,CAAtB;AACD,SAHD,MAGO;AACLuW,UAAAA,MAAM,CAACtW,EAAP,GAAY,CAAZ;AACD;AACF;AACF,KAtgGkB,CAwgGnB;;;AACA,aAAS4W,qBAAT,CAA+BgB,GAA/B,EAAoCvB,QAApC,EAA8CC,MAA9C,EAAsD;AACpDD,MAAAA,QAAQ,CAACrW,EAAT,GAAc,CAAd;AACAsW,MAAAA,MAAM,CAACtW,EAAP,GAAY,CAAZ;AACAsW,MAAAA,MAAM,CAACvW,IAAP;AACD;;AAED,aAASwX,+BAAT,CAAyC9H,IAAzC,EAA+C;AAC7C,UAAI,CAACA,IAAL,EAAW;AACT,eAAO,CAAP;AACD;;AACD,UAAI8W,UAAU,GAAG9W,IAAI,CAAC+W,MAAL,CAAY,IAAZ,CAAjB;AACA,aAAOD,UAAU,IAAI,CAAC,CAAf,GAAmB9W,IAAI,CAAC5S,MAAxB,GAAiC0pB,UAAxC;AACD;;AAED,aAAS3R,qBAAT,CAA+BtX,EAA/B,EAAmCxC,SAAnC,EAA8C2rB,QAA9C,EAAwD5rB,OAAxD,EAAiE6rB,QAAjE,EAA2E;AACzE,UAAI7O,GAAG,GAAGqO,OAAO,CAAC5oB,EAAD,CAAjB;AACA,UAAIyC,IAAI,GAAGzC,EAAE,CAACuC,OAAH,CAAWgY,GAAG,CAAC9X,IAAf,CAAX;AACA,UAAI0hB,GAAG,GAAG5J,GAAG,CAAC7X,EAAd,CAHyE,CAKzE;AACA;;AACA,UAAIS,IAAI,GAAGimB,QAAQ,GAAG5jB,YAAY,CAAC,CAAD,CAAf,GAAqBE,eAAe,CAAE,CAAF,CAAvD;;AACA,aAAO,CAACvC,IAAI,CAACV,IAAI,CAAC8B,MAAL,CAAY4f,GAAZ,CAAD,CAAZ,EAAgC;AAC9BA,QAAAA,GAAG;;AACH,YAAIA,GAAG,IAAI1hB,IAAI,CAAClD,MAAhB,EAAwB;AAAE,iBAAO,IAAP;AAAc;AACzC;;AAED,UAAIhC,OAAJ,EAAa;AACX4F,QAAAA,IAAI,GAAGuC,eAAe,CAAC,CAAD,CAAtB;AACD,OAFD,MAEO;AACLvC,QAAAA,IAAI,GAAGqC,YAAY,CAAC,CAAD,CAAnB;;AACA,YAAI,CAACrC,IAAI,CAACV,IAAI,CAAC8B,MAAL,CAAY4f,GAAZ,CAAD,CAAT,EAA6B;AAC3BhhB,UAAAA,IAAI,GAAGqC,YAAY,CAAC,CAAD,CAAnB;AACD;AACF;;AAED,UAAIgS,GAAG,GAAG2M,GAAV;AAAA,UAAeve,KAAK,GAAGue,GAAvB;;AACA,aAAOhhB,IAAI,CAACV,IAAI,CAAC8B,MAAL,CAAYiT,GAAZ,CAAD,CAAJ,IAA0BA,GAAG,GAAG/U,IAAI,CAAClD,MAA5C,EAAoD;AAAEiY,QAAAA,GAAG;AAAK;;AAC9D,aAAOrU,IAAI,CAACV,IAAI,CAAC8B,MAAL,CAAYqB,KAAZ,CAAD,CAAJ,IAA4BA,KAAK,IAAI,CAA5C,EAA+C;AAAEA,QAAAA,KAAK;AAAK;;AAC3DA,MAAAA,KAAK;;AAEL,UAAIpI,SAAJ,EAAe;AACb;AACA;AACA,YAAIF,OAAO,GAAGka,GAAd;;AACA,eAAO,KAAKrU,IAAL,CAAUV,IAAI,CAAC8B,MAAL,CAAYiT,GAAZ,CAAV,KAA+BA,GAAG,GAAG/U,IAAI,CAAClD,MAAjD,EAAyD;AAAEiY,UAAAA,GAAG;AAAK;;AACnE,YAAIla,OAAO,IAAIka,GAAf,EAAoB;AAClB,cAAI6R,SAAS,GAAGzjB,KAAhB;;AACA,iBAAO,KAAKzC,IAAL,CAAUV,IAAI,CAAC8B,MAAL,CAAYqB,KAAK,GAAG,CAApB,CAAV,KAAqCA,KAAK,GAAG,CAApD,EAAuD;AAAEA,YAAAA,KAAK;AAAK;;AACnE,cAAI,CAACA,KAAL,EAAY;AAAEA,YAAAA,KAAK,GAAGyjB,SAAR;AAAoB;AACnC;AACF;;AACD,aAAO;AAAEzjB,QAAAA,KAAK,EAAE/F,GAAG,CAAC0a,GAAG,CAAC9X,IAAL,EAAWmD,KAAX,CAAZ;AAA+B4R,QAAAA,GAAG,EAAE3X,GAAG,CAAC0a,GAAG,CAAC9X,IAAL,EAAW+U,GAAX;AAAvC,OAAP;AACD;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI,aAASuH,oBAAT,CAA8B/e,EAA9B,EAAkCiI,IAAlC,EAAwCzK,SAAxC,EAAmD;AACjD,UAAI+c,GAAG,GAAGtS,IAAV;;AACA,UAAI,CAACvL,UAAU,CAAC4sB,eAAZ,IAA+B,CAAC5sB,UAAU,CAAC6sB,gBAA/C,EAAiE;AAC/D,eAAO;AAAE3jB,UAAAA,KAAK,EAAE2U,GAAT;AAAc/C,UAAAA,GAAG,EAAE+C;AAAnB,SAAP;AACD;;AAED,UAAIiP,IAAI,GAAG9sB,UAAU,CAAC4sB,eAAX,CAA2BtpB,EAA3B,EAA+BiI,IAA/B,KAAwCvL,UAAU,CAAC6sB,gBAAX,CAA4BvpB,EAA5B,EAAgCiI,IAAhC,CAAnD;;AACA,UAAI,CAACuhB,IAAD,IAAS,CAACA,IAAI,CAACC,IAAf,IAAuB,CAACD,IAAI,CAACvT,KAAjC,EAAwC;AACtC,eAAO;AAAErQ,UAAAA,KAAK,EAAE2U,GAAT;AAAc/C,UAAAA,GAAG,EAAE+C;AAAnB,SAAP;AACD;;AAED,UAAI/c,SAAJ,EAAe;AACb,eAAO;AAAEoI,UAAAA,KAAK,EAAE4jB,IAAI,CAACC,IAAL,CAAU5O,IAAnB;AAAyBrD,UAAAA,GAAG,EAAEgS,IAAI,CAACvT,KAAL,CAAW6E;AAAzC,SAAP;AACD;;AACD,aAAO;AAAElV,QAAAA,KAAK,EAAE4jB,IAAI,CAACC,IAAL,CAAU3O,EAAnB;AAAuBtD,QAAAA,GAAG,EAAEgS,IAAI,CAACvT,KAAL,CAAW4E;AAAvC,OAAP;AACD;;AAED,aAAStC,kBAAT,CAA4BvY,EAA5B,EAAgCsI,MAAhC,EAAwCC,MAAxC,EAAgD;AAC9C,UAAI,CAACS,WAAW,CAACV,MAAD,EAASC,MAAT,CAAhB,EAAkC;AAChC8B,QAAAA,cAAc,CAAC2B,QAAf,CAAwB3D,GAAxB,CAA4BrI,EAA5B,EAAgCsI,MAAhC,EAAwCC,MAAxC;AACD;AACF;;AAED,aAASqV,yBAAT,CAAmC1R,SAAnC,EAA8CsT,IAA9C,EAAoD;AAChDnV,MAAAA,cAAc,CAAC4B,mBAAf,CAAmCC,SAAnC,GAA+CA,SAA/C;AACA7B,MAAAA,cAAc,CAAC4B,mBAAf,CAAmC5O,OAAnC,GAA6CmiB,IAAI,CAACniB,OAAlD;AACAgN,MAAAA,cAAc,CAAC4B,mBAAf,CAAmCE,iBAAnC,GAAuDqT,IAAI,CAACrT,iBAA5D;AACH;;AAED,QAAIud,YAAY,GAAG;AACf,WAAK,SADU;AACC,WAAK,SADN;AACiB,WAAK,SADtB;AACiC,WAAK,SADtC;AAEf,WAAK,SAFU;AAEC,WAAK,SAFN;AAGf,WAAK,SAHU;AAGC,WAAK,SAHN;AAIf,WAAK,QAJU;AAIA,WAAK,QAJL;AAKf,WAAK;AALU,KAAnB;AAOA,QAAIC,eAAe,GAAG;AACpBC,MAAAA,OAAO,EAAE;AACPC,QAAAA,UAAU,EAAE,UAASlpB,KAAT,EAAgB;AAC1B,cAAIA,KAAK,CAACmpB,MAAN,KAAiBnpB,KAAK,CAACopB,IAA3B,EAAiC;AAC/BppB,YAAAA,KAAK,CAACqpB,KAAN;AACA,gBAAIrpB,KAAK,CAACqpB,KAAN,IAAe,CAAnB,EAAqB,OAAO,IAAP;AACtB,WAHD,MAGO,IAAIrpB,KAAK,CAACmpB,MAAN,KAAiBnpB,KAAK,CAACspB,WAA3B,EAAwC;AAC7CtpB,YAAAA,KAAK,CAACqpB,KAAN;AACD;;AACD,iBAAO,KAAP;AACD;AATM,OADW;AAYpBE,MAAAA,OAAO,EAAE;AACPC,QAAAA,IAAI,EAAE,UAASxpB,KAAT,EAAgB;AACpBA,UAAAA,KAAK,CAACypB,cAAN,GAAuB,IAAvB;AACAzpB,UAAAA,KAAK,CAACopB,IAAN,GAAa,CAACppB,KAAK,CAACtD,OAAN,GAAgB,GAAhB,GAAsB,GAAvB,MAAgCsD,KAAK,CAACopB,IAAtC,GAA6C,GAA7C,GAAmD,GAAhE;AACD,SAJM;AAKPF,QAAAA,UAAU,EAAE,UAASlpB,KAAT,EAAgB;AAC1B,iBAAOA,KAAK,CAACgP,KAAN,KAAgB,CAAhB,IAAqBhP,KAAK,CAACmpB,MAAN,KAAiBnpB,KAAK,CAACopB,IAAnD;AACD;AAPM,OAZW;AAqBpBM,MAAAA,OAAO,EAAE;AACPR,QAAAA,UAAU,EAAE,UAASlpB,KAAT,EAAgB;AAC1B,cAAI2pB,KAAK,GAAG3pB,KAAK,CAACikB,MAAN,KAAiB,GAAjB,IAAwBjkB,KAAK,CAACmpB,MAAN,KAAiB,GAArD;AACAnpB,UAAAA,KAAK,CAACikB,MAAN,GAAejkB,KAAK,CAACmpB,MAArB;AACA,iBAAOQ,KAAP;AACD;AALM,OArBW;AA4BpB;AACA;AACA;AACAC,MAAAA,MAAM,EAAE;AACNJ,QAAAA,IAAI,EAAE,UAASxpB,KAAT,EAAgB;AACpBA,UAAAA,KAAK,CAACopB,IAAN,GAAcppB,KAAK,CAACopB,IAAN,KAAe,GAAf,GAAqB,GAArB,GAA2B,GAAzC;AACAppB,UAAAA,KAAK,CAACspB,WAAN,GAAoBtpB,KAAK,CAACopB,IAAN,KAAe,GAAf,GAAqB,GAArB,GAA2B,GAA/C;AACD,SAJK;AAKNF,QAAAA,UAAU,EAAE,UAASlpB,KAAT,EAAgB;AAC1B,cAAIA,KAAK,CAACmpB,MAAN,KAAiBnpB,KAAK,CAACopB,IAA3B,EAAgC,OAAO,IAAP;AAChC,iBAAO,KAAP;AACD;AARK,OA/BY;AAyCpBS,MAAAA,UAAU,EAAE;AACVL,QAAAA,IAAI,EAAE,UAASxpB,KAAT,EAAgB;AACpBA,UAAAA,KAAK,CAACgP,KAAN,GAAc,CAAd;AACD,SAHS;AAIVka,QAAAA,UAAU,EAAE,UAASlpB,KAAT,EAAgB;AAC1B,cAAIA,KAAK,CAACmpB,MAAN,KAAiB,GAArB,EAA0B;AACxB,gBAAIW,KAAK,GAAG9pB,KAAK,CAACsd,QAAN,CAAezO,KAAf,CAAqB,SAArB,EAAgC,CAAhC,CAAZ;;AACA,gBAAIib,KAAK,KAAK,OAAd,EAAuB;AACrB,kBAAI9pB,KAAK,CAACtD,OAAN,IAAiBsD,KAAK,CAACqpB,KAAN,KAAgB,CAArC,EAAwC;AACtC,uBAAO,IAAP;AACD;;AACDrpB,cAAAA,KAAK,CAACqpB,KAAN;AACD,aALD,MAKO,IAAIS,KAAK,KAAK,IAAd,EAAoB;AACzB,kBAAI,CAAC9pB,KAAK,CAACtD,OAAP,IAAkBsD,KAAK,CAACqpB,KAAN,KAAgB,CAAtC,EAAyC;AACvC,uBAAO,IAAP;AACD;;AACDrpB,cAAAA,KAAK,CAACqpB,KAAN;AACD;;AACD,gBAAIS,KAAK,KAAK,MAAV,IAAoB9pB,KAAK,CAACqpB,KAAN,KAAgB,CAAxC,EAA0C,OAAO,IAAP;AAC3C;;AACD,iBAAO,KAAP;AACD;AArBS;AAzCQ,KAAtB;;AAiEA,aAASlM,UAAT,CAAoB9d,EAApB,EAAwB+R,MAAxB,EAAgC1U,OAAhC,EAAyC0sB,IAAzC,EAA+C;AAC7C,UAAIxP,GAAG,GAAG1C,UAAU,CAAC7X,EAAE,CAACoF,SAAH,EAAD,CAApB;AACA,UAAI8G,SAAS,GAAG7O,OAAO,GAAG,CAAH,GAAO,CAAC,CAA/B;AACA,UAAIojB,OAAO,GAAGpjB,OAAO,GAAG2C,EAAE,CAAC0qB,SAAH,EAAH,GAAoB,CAAC,CAA1C;AACA,UAAIC,KAAK,GAAGpQ,GAAG,CAAC7X,EAAhB;AACA,UAAID,IAAI,GAAG8X,GAAG,CAAC9X,IAAf;AACA,UAAIwb,QAAQ,GAAGje,EAAE,CAACuC,OAAH,CAAWE,IAAX,CAAf;AACA,UAAI9B,KAAK,GAAG;AACVsd,QAAAA,QAAQ,EAAEA,QADA;AAEV6L,QAAAA,MAAM,EAAE7L,QAAQ,CAAC1Z,MAAT,CAAgBomB,KAAhB,CAFE;AAGV/F,QAAAA,MAAM,EAAE,IAHE;AAIVjV,QAAAA,KAAK,EAAEgb,KAJG;AAKVZ,QAAAA,IAAI,EAAEA,IALI;AAMVE,QAAAA,WAAW,EAAE,CAAC5sB,OAAO,GAAI;AAAE,eAAK,GAAP;AAAY,eAAK;AAAjB,SAAJ,GAA6B;AAAE,eAAK,GAAP;AAAY,eAAK;AAAjB,SAArC,EAA6D0sB,IAA7D,CANH;AAOV1sB,QAAAA,OAAO,EAAEA,OAPC;AAQV2sB,QAAAA,KAAK,EAAE,CARG;AASVI,QAAAA,cAAc,EAAE;AATN,OAAZ;AAWA,UAAIjqB,IAAI,GAAGupB,YAAY,CAACK,IAAD,CAAvB;AACA,UAAI,CAAC5pB,IAAL,EAAU,OAAOoa,GAAP;AACV,UAAI4P,IAAI,GAAGR,eAAe,CAACxpB,IAAD,CAAf,CAAsBgqB,IAAjC;AACA,UAAIN,UAAU,GAAGF,eAAe,CAACxpB,IAAD,CAAf,CAAsB0pB,UAAvC;;AACA,UAAIM,IAAJ,EAAU;AAAEA,QAAAA,IAAI,CAACxpB,KAAD,CAAJ;AAAc;;AAC1B,aAAO8B,IAAI,KAAKge,OAAT,IAAoB1O,MAA3B,EAAmC;AACjCpR,QAAAA,KAAK,CAACgP,KAAN,IAAezD,SAAf;AACAvL,QAAAA,KAAK,CAACmpB,MAAN,GAAenpB,KAAK,CAACsd,QAAN,CAAe1Z,MAAf,CAAsB5D,KAAK,CAACgP,KAA5B,CAAf;;AACA,YAAI,CAAChP,KAAK,CAACmpB,MAAX,EAAmB;AACjBrnB,UAAAA,IAAI,IAAIyJ,SAAR;AACAvL,UAAAA,KAAK,CAACsd,QAAN,GAAiBje,EAAE,CAACuC,OAAH,CAAWE,IAAX,KAAoB,EAArC;;AACA,cAAIyJ,SAAS,GAAG,CAAhB,EAAmB;AACjBvL,YAAAA,KAAK,CAACgP,KAAN,GAAc,CAAd;AACD,WAFD,MAEO;AACL,gBAAIib,OAAO,GAAGjqB,KAAK,CAACsd,QAAN,CAAe1e,MAA7B;AACAoB,YAAAA,KAAK,CAACgP,KAAN,GAAeib,OAAO,GAAG,CAAX,GAAiBA,OAAO,GAAC,CAAzB,GAA8B,CAA5C;AACD;;AACDjqB,UAAAA,KAAK,CAACmpB,MAAN,GAAenpB,KAAK,CAACsd,QAAN,CAAe1Z,MAAf,CAAsB5D,KAAK,CAACgP,KAA5B,CAAf;AACD;;AACD,YAAIka,UAAU,CAAClpB,KAAD,CAAd,EAAuB;AACrB4Z,UAAAA,GAAG,CAAC9X,IAAJ,GAAWA,IAAX;AACA8X,UAAAA,GAAG,CAAC7X,EAAJ,GAAS/B,KAAK,CAACgP,KAAf;AACAoC,UAAAA,MAAM;AACP;AACF;;AACD,UAAIpR,KAAK,CAACmpB,MAAN,IAAgBnpB,KAAK,CAACypB,cAA1B,EAA0C;AACxC,eAAOvqB,GAAG,CAAC4C,IAAD,EAAO9B,KAAK,CAACgP,KAAb,CAAV;AACD;;AACD,aAAO4K,GAAP;AACD;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI,aAASsQ,QAAT,CAAkB7qB,EAAlB,EAAsBua,GAAtB,EAA2Bld,OAA3B,EAAoCE,OAApC,EAA6CutB,eAA7C,EAA8D;AAC5D,UAAIrM,OAAO,GAAGlE,GAAG,CAAC9X,IAAlB;AACA,UAAIwY,GAAG,GAAGV,GAAG,CAAC7X,EAAd;AACA,UAAID,IAAI,GAAGzC,EAAE,CAACuC,OAAH,CAAWkc,OAAX,CAAX;AACA,UAAInL,GAAG,GAAGjW,OAAO,GAAG,CAAH,GAAO,CAAC,CAAzB;AACA,UAAI0tB,SAAS,GAAGxtB,OAAO,GAAGmI,eAAH,GAAoBF,YAA3C;;AAEA,UAAIslB,eAAe,IAAIroB,IAAI,IAAI,EAA/B,EAAmC;AACjCgc,QAAAA,OAAO,IAAInL,GAAX;AACA7Q,QAAAA,IAAI,GAAGzC,EAAE,CAACuC,OAAH,CAAWkc,OAAX,CAAP;;AACA,YAAI,CAAChY,MAAM,CAACzG,EAAD,EAAKye,OAAL,CAAX,EAA0B;AACxB,iBAAO,IAAP;AACD;;AACDxD,QAAAA,GAAG,GAAI5d,OAAD,GAAY,CAAZ,GAAgBoF,IAAI,CAAClD,MAA3B;AACD;;AAED,aAAO,IAAP,EAAa;AACX,YAAIurB,eAAe,IAAIroB,IAAI,IAAI,EAA/B,EAAmC;AACjC,iBAAO;AAAEoY,YAAAA,IAAI,EAAE,CAAR;AAAWC,YAAAA,EAAE,EAAE,CAAf;AAAkBrY,YAAAA,IAAI,EAAEgc;AAAxB,WAAP;AACD;;AACD,YAAIuM,IAAI,GAAI1X,GAAG,GAAG,CAAP,GAAY7Q,IAAI,CAAClD,MAAjB,GAA0B,CAAC,CAAtC;AACA,YAAI8pB,SAAS,GAAG2B,IAAhB;AAAA,YAAsB1tB,OAAO,GAAG0tB,IAAhC,CALW,CAMX;;AACA,eAAO/P,GAAG,IAAI+P,IAAd,EAAoB;AAClB,cAAIC,SAAS,GAAG,KAAhB;;AACA,eAAK,IAAI9oB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG4oB,SAAS,CAACxrB,MAAd,IAAwB,CAAC0rB,SAAzC,EAAoD,EAAE9oB,CAAtD,EAAyD;AACvD,gBAAI4oB,SAAS,CAAC5oB,CAAD,CAAT,CAAaM,IAAI,CAAC8B,MAAL,CAAY0W,GAAZ,CAAb,CAAJ,EAAoC;AAClCoO,cAAAA,SAAS,GAAGpO,GAAZ,CADkC,CAElC;;AACA,qBAAOA,GAAG,IAAI+P,IAAP,IAAeD,SAAS,CAAC5oB,CAAD,CAAT,CAAaM,IAAI,CAAC8B,MAAL,CAAY0W,GAAZ,CAAb,CAAtB,EAAsD;AACpDA,gBAAAA,GAAG,IAAI3H,GAAP;AACD;;AACDhW,cAAAA,OAAO,GAAG2d,GAAV;AACAgQ,cAAAA,SAAS,GAAG5B,SAAS,IAAI/rB,OAAzB;;AACA,kBAAI+rB,SAAS,IAAI9O,GAAG,CAAC7X,EAAjB,IAAuB+b,OAAO,IAAIlE,GAAG,CAAC9X,IAAtC,IACAnF,OAAO,IAAI+rB,SAAS,GAAG/V,GAD3B,EACgC;AAC9B;AACA;AACD,eAJD,MAIO;AACL,uBAAO;AACLuH,kBAAAA,IAAI,EAAEvE,IAAI,CAACC,GAAL,CAAS8S,SAAT,EAAoB/rB,OAAO,GAAG,CAA9B,CADD;AAELwd,kBAAAA,EAAE,EAAExE,IAAI,CAAC8L,GAAL,CAASiH,SAAT,EAAoB/rB,OAApB,CAFC;AAGLmF,kBAAAA,IAAI,EAAEgc;AAHD,iBAAP;AAID;AACF;AACF;;AACD,cAAI,CAACwM,SAAL,EAAgB;AACdhQ,YAAAA,GAAG,IAAI3H,GAAP;AACD;AACF,SAjCU,CAkCX;;;AACAmL,QAAAA,OAAO,IAAInL,GAAX;;AACA,YAAI,CAAC7M,MAAM,CAACzG,EAAD,EAAKye,OAAL,CAAX,EAA0B;AACxB,iBAAO,IAAP;AACD;;AACDhc,QAAAA,IAAI,GAAGzC,EAAE,CAACuC,OAAH,CAAWkc,OAAX,CAAP;AACAxD,QAAAA,GAAG,GAAI3H,GAAG,GAAG,CAAP,GAAY,CAAZ,GAAgB7Q,IAAI,CAAClD,MAA3B;AACD;AACF;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI,aAASke,UAAT,CAAoBzd,EAApB,EAAwBua,GAAxB,EAA6BxI,MAA7B,EAAqC1U,OAArC,EAA8CC,OAA9C,EAAuDC,OAAvD,EAAgE;AAC9D,UAAIwb,QAAQ,GAAGlB,UAAU,CAAC0C,GAAD,CAAzB;AACA,UAAI2Q,KAAK,GAAG,EAAZ;;AACA,UAAI7tB,OAAO,IAAI,CAACC,OAAZ,IAAuB,CAACD,OAAD,IAAYC,OAAvC,EAAgD;AAC9CyU,QAAAA,MAAM;AACP,OAL6D,CAM9D;;;AACA,UAAI+Y,eAAe,GAAG,EAAEztB,OAAO,IAAIC,OAAb,CAAtB;;AACA,WAAK,IAAI6E,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG4P,MAApB,EAA4B5P,CAAC,EAA7B,EAAiC;AAC/B,YAAIkV,IAAI,GAAGwT,QAAQ,CAAC7qB,EAAD,EAAKua,GAAL,EAAUld,OAAV,EAAmBE,OAAnB,EAA4ButB,eAA5B,CAAnB;;AACA,YAAI,CAACzT,IAAL,EAAW;AACT,cAAI8T,KAAK,GAAG7oB,UAAU,CAACtC,EAAD,EAAKA,EAAE,CAAC2G,QAAH,EAAL,CAAtB;AACAukB,UAAAA,KAAK,CAACvoB,IAAN,CAAWtF,OAAO,GACZ;AAACoF,YAAAA,IAAI,EAAEzC,EAAE,CAAC2G,QAAH,EAAP;AAAsBkU,YAAAA,IAAI,EAAEsQ,KAA5B;AAAmCrQ,YAAAA,EAAE,EAAEqQ;AAAvC,WADY,GAEZ;AAAC1oB,YAAAA,IAAI,EAAE,CAAP;AAAUoY,YAAAA,IAAI,EAAE,CAAhB;AAAmBC,YAAAA,EAAE,EAAE;AAAvB,WAFN;AAGA;AACD;;AACDoQ,QAAAA,KAAK,CAACvoB,IAAN,CAAW0U,IAAX;AACAkD,QAAAA,GAAG,GAAG1a,GAAG,CAACwX,IAAI,CAAC5U,IAAN,EAAYpF,OAAO,GAAIga,IAAI,CAACyD,EAAL,GAAU,CAAd,GAAmBzD,IAAI,CAACwD,IAA3C,CAAT;AACD;;AACD,UAAIuQ,YAAY,GAAGF,KAAK,CAAC3rB,MAAN,IAAgBwS,MAAnC;AACA,UAAIsZ,SAAS,GAAGH,KAAK,CAAC,CAAD,CAArB;AACA,UAAII,QAAQ,GAAGJ,KAAK,CAAC1a,GAAN,EAAf;;AACA,UAAInT,OAAO,IAAI,CAACC,OAAhB,EAAyB;AACvB;AACA,YAAI,CAAC8tB,YAAD,KAAkBC,SAAS,CAACxQ,IAAV,IAAkB9B,QAAQ,CAACrW,EAA3B,IAAiC2oB,SAAS,CAAC5oB,IAAV,IAAkBsW,QAAQ,CAACtW,IAA9E,CAAJ,EAAyF;AACvF;AACA6oB,UAAAA,QAAQ,GAAGJ,KAAK,CAAC1a,GAAN,EAAX;AACD;;AACD,eAAO3Q,GAAG,CAACyrB,QAAQ,CAAC7oB,IAAV,EAAgB6oB,QAAQ,CAACzQ,IAAzB,CAAV;AACD,OAPD,MAOO,IAAIxd,OAAO,IAAIC,OAAf,EAAwB;AAC7B,eAAOuC,GAAG,CAACyrB,QAAQ,CAAC7oB,IAAV,EAAgB6oB,QAAQ,CAACxQ,EAAT,GAAc,CAA9B,CAAV;AACD,OAFM,MAEA,IAAI,CAACzd,OAAD,IAAYC,OAAhB,EAAyB;AAC9B;AACA,YAAI,CAAC8tB,YAAD,KAAkBC,SAAS,CAACvQ,EAAV,IAAgB/B,QAAQ,CAACrW,EAAzB,IAA+B2oB,SAAS,CAAC5oB,IAAV,IAAkBsW,QAAQ,CAACtW,IAA5E,CAAJ,EAAuF;AACrF;AACA6oB,UAAAA,QAAQ,GAAGJ,KAAK,CAAC1a,GAAN,EAAX;AACD;;AACD,eAAO3Q,GAAG,CAACyrB,QAAQ,CAAC7oB,IAAV,EAAgB6oB,QAAQ,CAACxQ,EAAzB,CAAV;AACD,OAPM,MAOA;AACL;AACA,eAAOjb,GAAG,CAACyrB,QAAQ,CAAC7oB,IAAV,EAAgB6oB,QAAQ,CAACzQ,IAAzB,CAAV;AACD;AACF;;AAED,aAASmB,SAAT,CAAmBhc,EAAnB,EAAuBiI,IAAvB,EAA6B/K,UAA7B,EAAyC0D,GAAzC,EAA8C2qB,QAA9C,EAAwD;AACtD,UAAIhR,GAAG,GAAGtS,IAAV;AACA,UAAIujB,MAAM,GAAE3rB,GAAG,CAAC0a,GAAG,CAAC9X,IAAJ,GAAWvF,UAAU,CAAC6U,MAAtB,GAA+B,CAAhC,EAAmCyG,QAAnC,CAAf;AACA,UAAIhB,GAAG,GAACxX,EAAE,CAACwnB,OAAH,CAAWgE,MAAX,CAAR;AACAhU,MAAAA,GAAG,CAAC9U,EAAJ;;AACA,UAAI,CAAC6oB,QAAL,EAAe;AACb3qB,QAAAA,GAAG,CAACsK,QAAJ,GAAesN,QAAf;AACA5X,QAAAA,GAAG,CAACuK,SAAJ,GAAgBnL,EAAE,CAACuc,UAAH,CAAc/E,GAAd,EAAkB,KAAlB,EAAyB3B,IAAzC;AACD;;AACD,aAAO2V,MAAP;AACD;;AAED,aAAS7N,eAAT,CAAyB3d,EAAzB,EAA6B+R,MAA7B,EAAqC1U,OAArC,EAA8C2W,SAA9C,EAAyD;AACvD,UAAIuG,GAAG,GAAGva,EAAE,CAACoF,SAAH,EAAV;AACA,UAAIQ,KAAK,GAAG2U,GAAG,CAAC7X,EAAhB;AACA,UAAIyhB,GAAJ;;AACA,WAAK,IAAIhiB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG4P,MAApB,EAA4B5P,CAAC,EAA7B,EAAkC;AAChC,YAAIM,IAAI,GAAGzC,EAAE,CAACuC,OAAH,CAAWgY,GAAG,CAAC9X,IAAf,CAAX;AACA0hB,QAAAA,GAAG,GAAGsH,aAAa,CAAC7lB,KAAD,EAAQnD,IAAR,EAAcuR,SAAd,EAAyB3W,OAAzB,EAAkC,IAAlC,CAAnB;;AACA,YAAI8mB,GAAG,IAAI,CAAC,CAAZ,EAAe;AACb,iBAAO,IAAP;AACD;;AACDve,QAAAA,KAAK,GAAGue,GAAR;AACD;;AACD,aAAOtkB,GAAG,CAACG,EAAE,CAACoF,SAAH,GAAe3C,IAAhB,EAAsB0hB,GAAtB,CAAV;AACD;;AAED,aAASpI,YAAT,CAAsB/b,EAAtB,EAA0B+R,MAA1B,EAAkC;AAChC;AACA;AACA,UAAItP,IAAI,GAAGzC,EAAE,CAACoF,SAAH,GAAe3C,IAA1B;AACA,aAAOqV,mBAAmB,CAAC9X,EAAD,EAAKH,GAAG,CAAC4C,IAAD,EAAOsP,MAAM,GAAG,CAAhB,CAAR,CAA1B;AACD;;AAED,aAAS0G,UAAT,CAAoBzY,EAApB,EAAwBY,GAAxB,EAA6BukB,QAA7B,EAAuClK,GAAvC,EAA4C;AAC1C,UAAI,CAAC9T,OAAO,CAACge,QAAD,EAAWhf,UAAX,CAAZ,EAAoC;AAClC;AACD;;AACD,UAAIvF,GAAG,CAACkC,KAAJ,CAAUqiB,QAAV,CAAJ,EAAyB;AACvBvkB,QAAAA,GAAG,CAACkC,KAAJ,CAAUqiB,QAAV,EAAoBpiB,KAApB;AACD;;AACDnC,MAAAA,GAAG,CAACkC,KAAJ,CAAUqiB,QAAV,IAAsBnlB,EAAE,CAAC6I,WAAH,CAAeoS,GAAf,CAAtB;AACD;;AAED,aAASwQ,aAAT,CAAuB7lB,KAAvB,EAA8BnD,IAA9B,EAAoCuR,SAApC,EAA+C3W,OAA/C,EAAwDquB,WAAxD,EAAqE;AACnE;AACA;AACA;AACA;AACA;AACA,UAAIvH,GAAJ;;AACA,UAAI9mB,OAAJ,EAAa;AACX8mB,QAAAA,GAAG,GAAG1hB,IAAI,CAACsE,OAAL,CAAaiN,SAAb,EAAwBpO,KAAK,GAAG,CAAhC,CAAN;;AACA,YAAIue,GAAG,IAAI,CAAC,CAAR,IAAa,CAACuH,WAAlB,EAA+B;AAC7BvH,UAAAA,GAAG,IAAI,CAAP;AACD;AACF,OALD,MAKO;AACLA,QAAAA,GAAG,GAAG1hB,IAAI,CAACkpB,WAAL,CAAiB3X,SAAjB,EAA4BpO,KAAK,GAAG,CAApC,CAAN;;AACA,YAAIue,GAAG,IAAI,CAAC,CAAR,IAAa,CAACuH,WAAlB,EAA+B;AAC7BvH,UAAAA,GAAG,IAAI,CAAP;AACD;AACF;;AACD,aAAOA,GAAP;AACD;;AAED,aAASnH,aAAT,CAAuBhd,EAAvB,EAA2BiI,IAA3B,EAAiC8J,MAAjC,EAAyCuB,GAAzC,EAA8C9V,SAA9C,EAAyD;AACvD,UAAIiF,IAAI,GAAGwF,IAAI,CAACxF,IAAhB;AACA,UAAI8T,GAAG,GAAGvW,EAAE,CAAC0G,SAAH,EAAV;AACA,UAAI0b,GAAG,GAAGpiB,EAAE,CAAC2G,QAAH,EAAV;AACA,UAAIf,KAAJ;AAAA,UAAW4R,GAAX;AAAA,UAAgBrV,CAAC,GAAGM,IAApB;;AACA,eAASmpB,OAAT,CAAiBzpB,CAAjB,EAAoB;AAAE,eAAO,CAACnC,EAAE,CAACuC,OAAH,CAAWJ,CAAX,CAAR;AAAwB;;AAC9C,eAAS0pB,UAAT,CAAoB1pB,CAApB,EAAuBmR,GAAvB,EAA4BwY,GAA5B,EAAiC;AAC/B,YAAIA,GAAJ,EAAS;AAAE,iBAAOF,OAAO,CAACzpB,CAAD,CAAP,IAAcypB,OAAO,CAACzpB,CAAC,GAAGmR,GAAL,CAA5B;AAAwC;;AACnD,eAAO,CAACsY,OAAO,CAACzpB,CAAD,CAAR,IAAeypB,OAAO,CAACzpB,CAAC,GAAGmR,GAAL,CAA7B;AACD;;AACD,UAAIA,GAAJ,EAAS;AACP,eAAOiD,GAAG,IAAIpU,CAAP,IAAYA,CAAC,IAAIigB,GAAjB,IAAwBrQ,MAAM,GAAG,CAAxC,EAA2C;AACzC,cAAI8Z,UAAU,CAAC1pB,CAAD,EAAImR,GAAJ,CAAd,EAAwB;AAAEvB,YAAAA,MAAM;AAAK;;AACrC5P,UAAAA,CAAC,IAAImR,GAAL;AACD;;AACD,eAAO,IAAIzT,GAAJ,CAAQsC,CAAR,EAAW,CAAX,CAAP;AACD;;AAED,UAAIvB,GAAG,GAAGZ,EAAE,CAACW,KAAH,CAASC,GAAnB;;AACA,UAAIA,GAAG,CAACtC,UAAJ,IAAkButB,UAAU,CAACppB,IAAD,EAAO,CAAP,EAAU,IAAV,CAAhC,EAAiD;AAC/C,YAAID,MAAM,GAAG5B,GAAG,CAAC+K,GAAJ,CAAQnJ,MAArB;;AACA,YAAIqpB,UAAU,CAACrpB,MAAM,CAACC,IAAR,EAAc,CAAC,CAAf,EAAkB,IAAlB,CAAd,EAAuC;AACrC,cAAI,CAACjF,SAAD,IAAcgF,MAAM,CAACC,IAAP,IAAeA,IAAjC,EAAuC;AACrCA,YAAAA,IAAI,IAAI,CAAR;AACD;AACF;AACF;;AACD,UAAIspB,UAAU,GAAGH,OAAO,CAACnpB,IAAD,CAAxB;;AACA,WAAKN,CAAC,GAAGM,IAAT,EAAeN,CAAC,IAAIigB,GAAL,IAAYrQ,MAA3B,EAAmC5P,CAAC,EAApC,EAAwC;AACtC,YAAI0pB,UAAU,CAAC1pB,CAAD,EAAI,CAAJ,EAAO,IAAP,CAAd,EAA4B;AAC1B,cAAI,CAAC3E,SAAD,IAAcouB,OAAO,CAACzpB,CAAD,CAAP,IAAc4pB,UAAhC,EAA4C;AAC1Cha,YAAAA,MAAM;AACP;AACF;AACF;;AACDyF,MAAAA,GAAG,GAAG,IAAI3X,GAAJ,CAAQsC,CAAR,EAAW,CAAX,CAAN,CAnCuD,CAoCvD;;AACA,UAAIA,CAAC,GAAGigB,GAAJ,IAAW,CAAC2J,UAAhB,EAA4B;AAAEA,QAAAA,UAAU,GAAG,IAAb;AAAoB,OAAlD,MACK;AAAEvuB,QAAAA,SAAS,GAAG,KAAZ;AAAoB;;AAC3B,WAAK2E,CAAC,GAAGM,IAAT,EAAeN,CAAC,GAAGoU,GAAnB,EAAwBpU,CAAC,EAAzB,EAA6B;AAC3B,YAAI,CAAC3E,SAAD,IAAcouB,OAAO,CAACzpB,CAAD,CAAP,IAAc4pB,UAA5B,IAA0C5pB,CAAC,IAAIM,IAAnD,EAAyD;AACvD,cAAIopB,UAAU,CAAC1pB,CAAD,EAAI,CAAC,CAAL,EAAQ,IAAR,CAAd,EAA6B;AAAE;AAAQ;AACxC;AACF;;AACDyD,MAAAA,KAAK,GAAG,IAAI/F,GAAJ,CAAQsC,CAAR,EAAW,CAAX,CAAR;AACA,aAAO;AAAEyD,QAAAA,KAAK,EAAEA,KAAT;AAAgB4R,QAAAA,GAAG,EAAEA;AAArB,OAAP;AACD;;AAED,aAAS0F,YAAT,CAAsBld,EAAtB,EAA0Bua,GAA1B,EAA+BxI,MAA/B,EAAuCuB,GAAvC,EAA4C;AAE1C;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACM,eAAS0Y,QAAT,CAAkBhsB,EAAlB,EAAsBmkB,GAAtB,EAA2B;AACzB,YAAIA,GAAG,CAAClJ,GAAJ,GAAUkJ,GAAG,CAAC7Q,GAAd,GAAoB,CAApB,IAAyB6Q,GAAG,CAAClJ,GAAJ,GAAUkJ,GAAG,CAAC7Q,GAAd,IAAqB6Q,GAAG,CAAC1hB,IAAJ,CAASlD,MAA3D,EAAmE;AACjE4kB,UAAAA,GAAG,CAAC8H,EAAJ,IAAU9H,GAAG,CAAC7Q,GAAd;;AACA,cAAI,CAAC7M,MAAM,CAACzG,EAAD,EAAKmkB,GAAG,CAAC8H,EAAT,CAAX,EAAyB;AACvB9H,YAAAA,GAAG,CAAC1hB,IAAJ,GAAW,IAAX;AACA0hB,YAAAA,GAAG,CAAC8H,EAAJ,GAAS,IAAT;AACA9H,YAAAA,GAAG,CAAClJ,GAAJ,GAAU,IAAV;AACA;AACD;;AACDkJ,UAAAA,GAAG,CAAC1hB,IAAJ,GAAWzC,EAAE,CAACuC,OAAH,CAAW4hB,GAAG,CAAC8H,EAAf,CAAX;AACA9H,UAAAA,GAAG,CAAClJ,GAAJ,GAAWkJ,GAAG,CAAC7Q,GAAJ,GAAU,CAAX,GAAgB,CAAhB,GAAoB6Q,GAAG,CAAC1hB,IAAJ,CAASlD,MAAT,GAAkB,CAAhD;AACD,SAVD,MAWK;AACH4kB,UAAAA,GAAG,CAAClJ,GAAJ,IAAWkJ,GAAG,CAAC7Q,GAAf;AACD;AACF;AAED;AACN;AACA;AACA;;;AACM,eAASjW,OAAT,CAAiB2C,EAAjB,EAAqBisB,EAArB,EAAyBhR,GAAzB,EAA8B3H,GAA9B,EAAmC;AACjC,YAAI7Q,IAAI,GAAGzC,EAAE,CAACuC,OAAH,CAAW0pB,EAAX,CAAX;AACA,YAAIjB,IAAI,GAAIvoB,IAAI,KAAK,EAArB;AAEA,YAAIypB,IAAI,GAAG;AACTzpB,UAAAA,IAAI,EAAEA,IADG;AAETwpB,UAAAA,EAAE,EAAEA,EAFK;AAGThR,UAAAA,GAAG,EAAEA,GAHI;AAIT3H,UAAAA,GAAG,EAAEA;AAJI,SAAX;AAOA,YAAI6Y,UAAU,GAAG;AACfF,UAAAA,EAAE,EAAEC,IAAI,CAACD,EADM;AAEfhR,UAAAA,GAAG,EAAEiR,IAAI,CAACjR;AAFK,SAAjB;AAKA,YAAImR,gBAAgB,GAAIF,IAAI,CAACzpB,IAAL,KAAc,EAAtC,CAhBiC,CAkBjC;;AACAupB,QAAAA,QAAQ,CAAChsB,EAAD,EAAKksB,IAAL,CAAR;;AAEA,eAAOA,IAAI,CAACzpB,IAAL,KAAc,IAArB,EAA2B;AACzB0pB,UAAAA,UAAU,CAACF,EAAX,GAAgBC,IAAI,CAACD,EAArB;AACAE,UAAAA,UAAU,CAAClR,GAAX,GAAiBiR,IAAI,CAACjR,GAAtB;;AAEA,cAAIiR,IAAI,CAACzpB,IAAL,KAAc,EAAd,IAAoB,CAAC2pB,gBAAzB,EAA2C;AACzC,mBAAO;AAAEH,cAAAA,EAAE,EAAEC,IAAI,CAACD,EAAX;AAAehR,cAAAA,GAAG,EAAEiR,IAAI,CAACjR;AAAzB,aAAP;AACD,WAFD,MAGK,IAAI+P,IAAI,IAAIkB,IAAI,CAACzpB,IAAL,KAAc,EAAtB,IAA4B,CAACwE,kBAAkB,CAACilB,IAAI,CAACzpB,IAAL,CAAUypB,IAAI,CAACjR,GAAf,CAAD,CAAnD,EAA0E;AAC7E,mBAAO;AAAEgR,cAAAA,EAAE,EAAEC,IAAI,CAACD,EAAX;AAAehR,cAAAA,GAAG,EAAEiR,IAAI,CAACjR;AAAzB,aAAP;AACD,WAFI,MAGA,IAAI/T,qBAAqB,CAACglB,IAAI,CAACzpB,IAAL,CAAUypB,IAAI,CAACjR,GAAf,CAAD,CAArB,IACJ,CAAC+P,IADG,KAEHkB,IAAI,CAACjR,GAAL,KAAaiR,IAAI,CAACzpB,IAAL,CAAUlD,MAAV,GAAmB,CAAhC,IACC0H,kBAAkB,CAACilB,IAAI,CAACzpB,IAAL,CAAUypB,IAAI,CAACjR,GAAL,GAAW,CAArB,CAAD,CAHhB,CAAJ,EAGgD;AACnD+P,YAAAA,IAAI,GAAG,IAAP;AACD;;AAEDgB,UAAAA,QAAQ,CAAChsB,EAAD,EAAKksB,IAAL,CAAR;AACD;AAED;AACR;AACA;AACA;;;AACQ,YAAIzpB,IAAI,GAAGzC,EAAE,CAACuC,OAAH,CAAW4pB,UAAU,CAACF,EAAtB,CAAX;AACAE,QAAAA,UAAU,CAAClR,GAAX,GAAiB,CAAjB;;AACA,aAAI,IAAI9Y,CAAC,GAAGM,IAAI,CAAClD,MAAL,GAAc,CAA1B,EAA6B4C,CAAC,IAAI,CAAlC,EAAqC,EAAEA,CAAvC,EAA0C;AACxC,cAAI,CAAC8E,kBAAkB,CAACxE,IAAI,CAACN,CAAD,CAAL,CAAvB,EAAkC;AAChCgqB,YAAAA,UAAU,CAAClR,GAAX,GAAiB9Y,CAAjB;AACA;AACD;AACF;;AAED,eAAOgqB,UAAP;AAED;AAED;AACN;AACA;AACA;;;AACM,eAASE,OAAT,CAAiBrsB,EAAjB,EAAqBisB,EAArB,EAAyBhR,GAAzB,EAA8B3H,GAA9B,EAAmC;AACjC,YAAI7Q,IAAI,GAAGzC,EAAE,CAACuC,OAAH,CAAW0pB,EAAX,CAAX;AAEA,YAAIC,IAAI,GAAG;AACTzpB,UAAAA,IAAI,EAAEA,IADG;AAETwpB,UAAAA,EAAE,EAAEA,EAFK;AAGThR,UAAAA,GAAG,EAAEA,GAHI;AAIT3H,UAAAA,GAAG,EAAEA;AAJI,SAAX;AAOA,YAAI6Y,UAAU,GAAG;AACfF,UAAAA,EAAE,EAAEC,IAAI,CAACD,EADM;AAEfhR,UAAAA,GAAG,EAAE;AAFU,SAAjB;AAKA,YAAImR,gBAAgB,GAAIF,IAAI,CAACzpB,IAAL,KAAc,EAAtC,CAfiC,CAiBjC;;AACAupB,QAAAA,QAAQ,CAAChsB,EAAD,EAAKksB,IAAL,CAAR;;AAEA,eAAOA,IAAI,CAACzpB,IAAL,KAAc,IAArB,EAA2B;AAEzB,cAAIypB,IAAI,CAACzpB,IAAL,KAAc,EAAd,IAAoB,CAAC2pB,gBAAzB,EAA2C;AACzC,gBAAID,UAAU,CAAClR,GAAX,KAAmB,IAAvB,EAA6B;AAC3B,qBAAOkR,UAAP;AACD,aAFD,MAGK;AACH,qBAAO;AAAEF,gBAAAA,EAAE,EAAEC,IAAI,CAACD,EAAX;AAAehR,gBAAAA,GAAG,EAAEiR,IAAI,CAACjR;AAAzB,eAAP;AACD;AACF,WAPD,MAQK,IAAI/T,qBAAqB,CAACglB,IAAI,CAACzpB,IAAL,CAAUypB,IAAI,CAACjR,GAAf,CAAD,CAArB,IACFkR,UAAU,CAAClR,GAAX,KAAmB,IADjB,IAEF,EAAEiR,IAAI,CAACD,EAAL,KAAYE,UAAU,CAACF,EAAvB,IAA6BC,IAAI,CAACjR,GAAL,GAAW,CAAX,KAAiBkR,UAAU,CAAClR,GAA3D,CAFF,EAEmE;AACtE,mBAAOkR,UAAP;AACD,WAJI,MAKA,IAAID,IAAI,CAACzpB,IAAL,KAAc,EAAd,IAAoB,CAACwE,kBAAkB,CAACilB,IAAI,CAACzpB,IAAL,CAAUypB,IAAI,CAACjR,GAAf,CAAD,CAA3C,EAAkE;AACrEmR,YAAAA,gBAAgB,GAAG,KAAnB;AACAD,YAAAA,UAAU,GAAG;AAAEF,cAAAA,EAAE,EAAEC,IAAI,CAACD,EAAX;AAAehR,cAAAA,GAAG,EAAEiR,IAAI,CAACjR;AAAzB,aAAb;AACD;;AAED+Q,UAAAA,QAAQ,CAAChsB,EAAD,EAAKksB,IAAL,CAAR;AACD;AAED;AACR;AACA;AACA;;;AACQ,YAAIzpB,IAAI,GAAGzC,EAAE,CAACuC,OAAH,CAAW4pB,UAAU,CAACF,EAAtB,CAAX;AACAE,QAAAA,UAAU,CAAClR,GAAX,GAAiB,CAAjB;;AACA,aAAI,IAAI9Y,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGM,IAAI,CAAClD,MAAxB,EAAgC,EAAE4C,CAAlC,EAAqC;AACnC,cAAI,CAAC8E,kBAAkB,CAACxE,IAAI,CAACN,CAAD,CAAL,CAAvB,EAAkC;AAChCgqB,YAAAA,UAAU,CAAClR,GAAX,GAAiB9Y,CAAjB;AACA;AACD;AACF;;AACD,eAAOgqB,UAAP;AACD;;AAED,UAAIG,UAAU,GAAG;AACfL,QAAAA,EAAE,EAAE1R,GAAG,CAAC9X,IADO;AAEfwY,QAAAA,GAAG,EAAEV,GAAG,CAAC7X;AAFM,OAAjB;;AAKA,aAAOqP,MAAM,GAAG,CAAhB,EAAmB;AACjB,YAAIuB,GAAG,GAAG,CAAV,EAAa;AACXgZ,UAAAA,UAAU,GAAGD,OAAO,CAACrsB,EAAD,EAAKssB,UAAU,CAACL,EAAhB,EAAoBK,UAAU,CAACrR,GAA/B,EAAoC3H,GAApC,CAApB;AACD,SAFD,MAGK;AACHgZ,UAAAA,UAAU,GAAGjvB,OAAO,CAAC2C,EAAD,EAAKssB,UAAU,CAACL,EAAhB,EAAoBK,UAAU,CAACrR,GAA/B,EAAoC3H,GAApC,CAApB;AACD;;AACDvB,QAAAA,MAAM;AACP;;AAED,aAAOlS,GAAG,CAACysB,UAAU,CAACL,EAAZ,EAAgBK,UAAU,CAACrR,GAA3B,CAAV;AACD,KAlpHkB,CAopHnB;AACA;;;AACA,aAAS4D,qBAAT,CAA+B7e,EAA/B,EAAmCiI,IAAnC,EAAyC8hB,IAAzC,EAA+CvsB,SAA/C,EAA0D;AACxD,UAAI+c,GAAG,GAAGtS,IAAV;AAAA,UAAgBrC,KAAhB;AAAA,UAAuB4R,GAAvB;AAEA,UAAI+U,aAAa,GAAI;AACnB,aAAK,MADc;AACN,aAAK,MADC;AAEnB,aAAK,OAFc;AAEL,aAAK,OAFA;AAGnB,aAAK,MAHc;AAGN,aAAK,MAHC;AAInB,aAAK,MAJc;AAIN,aAAK;AAJC,OAAD,CAISxC,IAJT,CAApB;AAKA,UAAIyC,OAAO,GAAI;AACb,aAAK,GADQ;AACH,aAAK,GADF;AAEb,aAAK,GAFQ;AAEH,aAAK,GAFF;AAGb,aAAK,GAHQ;AAGH,aAAK,GAHF;AAIb,aAAK,GAJQ;AAIH,aAAK;AAJF,OAAD,CAISzC,IAJT,CAAd;AAKA,UAAI0C,OAAO,GAAGzsB,EAAE,CAACuC,OAAH,CAAWgY,GAAG,CAAC9X,IAAf,EAAqB8B,MAArB,CAA4BgW,GAAG,CAAC7X,EAAhC,CAAd,CAbwD,CAcxD;AACA;;AACA,UAAIwG,MAAM,GAAGujB,OAAO,KAAKD,OAAZ,GAAsB,CAAtB,GAA0B,CAAvC;AAEA5mB,MAAAA,KAAK,GAAG5F,EAAE,CAAC0sB,cAAH,CAAkB7sB,GAAG,CAAC0a,GAAG,CAAC9X,IAAL,EAAW8X,GAAG,CAAC7X,EAAJ,GAASwG,MAApB,CAArB,EAAkD,CAAC,CAAnD,EAAsD5F,SAAtD,EAAiE;AAAC,wBAAgBipB;AAAjB,OAAjE,CAAR;AACA/U,MAAAA,GAAG,GAAGxX,EAAE,CAAC0sB,cAAH,CAAkB7sB,GAAG,CAAC0a,GAAG,CAAC9X,IAAL,EAAW8X,GAAG,CAAC7X,EAAJ,GAASwG,MAApB,CAArB,EAAkD,CAAlD,EAAqD5F,SAArD,EAAgE;AAAC,wBAAgBipB;AAAjB,OAAhE,CAAN;;AAEA,UAAI,CAAC3mB,KAAD,IAAU,CAAC4R,GAAf,EAAoB;AAClB,eAAO;AAAE5R,UAAAA,KAAK,EAAE2U,GAAT;AAAc/C,UAAAA,GAAG,EAAE+C;AAAnB,SAAP;AACD;;AAED3U,MAAAA,KAAK,GAAGA,KAAK,CAACqV,GAAd;AACAzD,MAAAA,GAAG,GAAGA,GAAG,CAACyD,GAAV;;AAEA,UAAKrV,KAAK,CAACnD,IAAN,IAAc+U,GAAG,CAAC/U,IAAlB,IAA0BmD,KAAK,CAAClD,EAAN,GAAW8U,GAAG,CAAC9U,EAA1C,IACIkD,KAAK,CAACnD,IAAN,GAAa+U,GAAG,CAAC/U,IADzB,EACgC;AAC9B,YAAI4W,GAAG,GAAGzT,KAAV;AACAA,QAAAA,KAAK,GAAG4R,GAAR;AACAA,QAAAA,GAAG,GAAG6B,GAAN;AACD;;AAED,UAAI7b,SAAJ,EAAe;AACbga,QAAAA,GAAG,CAAC9U,EAAJ,IAAU,CAAV;AACD,OAFD,MAEO;AACLkD,QAAAA,KAAK,CAAClD,EAAN,IAAY,CAAZ;AACD;;AAED,aAAO;AAAEkD,QAAAA,KAAK,EAAEA,KAAT;AAAgB4R,QAAAA,GAAG,EAAEA;AAArB,OAAP;AACD,KAhsHkB,CAksHnB;AACA;AACA;;;AACA,aAASsH,mBAAT,CAA6B9e,EAA7B,EAAiCiI,IAAjC,EAAuC8hB,IAAvC,EAA6CvsB,SAA7C,EAAwD;AACtD,UAAI+c,GAAG,GAAG1C,UAAU,CAAC5P,IAAD,CAApB;AACA,UAAIxF,IAAI,GAAGzC,EAAE,CAACuC,OAAH,CAAWgY,GAAG,CAAC9X,IAAf,CAAX;AACA,UAAIkqB,KAAK,GAAGlqB,IAAI,CAACgC,KAAL,CAAW,EAAX,CAAZ;AACA,UAAImB,KAAJ,EAAW4R,GAAX,EAAgBrV,CAAhB,EAAmByqB,GAAnB;AACA,UAAIC,UAAU,GAAGF,KAAK,CAAC5lB,OAAN,CAAcgjB,IAAd,CAAjB,CALsD,CAOtD;AACA;AACA;;AACA,UAAIxP,GAAG,CAAC7X,EAAJ,GAASmqB,UAAb,EAAyB;AACvBtS,QAAAA,GAAG,CAAC7X,EAAJ,GAASmqB,UAAT,CADuB,CAEvB;AACA;AACD,OAJD,CAKA;AALA,WAMK,IAAIA,UAAU,GAAGtS,GAAG,CAAC7X,EAAjB,IAAuBiqB,KAAK,CAACpS,GAAG,CAAC7X,EAAL,CAAL,IAAiBqnB,IAA5C,EAAkD;AACrDvS,QAAAA,GAAG,GAAG+C,GAAG,CAAC7X,EAAV,CADqD,CACvC;;AACd,UAAE6X,GAAG,CAAC7X,EAAN,CAFqD,CAE3C;AACX,OAnBqD,CAqBtD;;;AACA,UAAIiqB,KAAK,CAACpS,GAAG,CAAC7X,EAAL,CAAL,IAAiBqnB,IAAjB,IAAyB,CAACvS,GAA9B,EAAmC;AACjC5R,QAAAA,KAAK,GAAG2U,GAAG,CAAC7X,EAAJ,GAAS,CAAjB,CADiC,CACb;AACrB,OAFD,MAEO;AACL;AACA,aAAKP,CAAC,GAAGoY,GAAG,CAAC7X,EAAb,EAAiBP,CAAC,GAAG,CAAC,CAAL,IAAU,CAACyD,KAA5B,EAAmCzD,CAAC,EAApC,EAAwC;AACtC,cAAIwqB,KAAK,CAACxqB,CAAD,CAAL,IAAY4nB,IAAhB,EAAsB;AACpBnkB,YAAAA,KAAK,GAAGzD,CAAC,GAAG,CAAZ;AACD;AACF;AACF,OA/BqD,CAiCtD;;;AACA,UAAIyD,KAAK,IAAI,CAAC4R,GAAd,EAAmB;AACjB,aAAKrV,CAAC,GAAGyD,KAAJ,EAAWgnB,GAAG,GAAGD,KAAK,CAACptB,MAA5B,EAAoC4C,CAAC,GAAGyqB,GAAJ,IAAW,CAACpV,GAAhD,EAAqDrV,CAAC,EAAtD,EAA0D;AACxD,cAAIwqB,KAAK,CAACxqB,CAAD,CAAL,IAAY4nB,IAAhB,EAAsB;AACpBvS,YAAAA,GAAG,GAAGrV,CAAN;AACD;AACF;AACF,OAxCqD,CA0CtD;;;AACA,UAAI,CAACyD,KAAD,IAAU,CAAC4R,GAAf,EAAoB;AAClB,eAAO;AAAE5R,UAAAA,KAAK,EAAE2U,GAAT;AAAc/C,UAAAA,GAAG,EAAE+C;AAAnB,SAAP;AACD,OA7CqD,CA+CtD;;;AACA,UAAI/c,SAAJ,EAAe;AACb,UAAEoI,KAAF;AAAS,UAAE4R,GAAF;AACV;;AAED,aAAO;AACL5R,QAAAA,KAAK,EAAE/F,GAAG,CAAC0a,GAAG,CAAC9X,IAAL,EAAWmD,KAAX,CADL;AAEL4R,QAAAA,GAAG,EAAE3X,GAAG,CAAC0a,GAAG,CAAC9X,IAAL,EAAW+U,GAAX;AAFH,OAAP;AAID,KA7vHkB,CA+vHnB;;;AACAxU,IAAAA,YAAY,CAAC,MAAD,EAAS,IAAT,EAAe,SAAf,CAAZ;;AACA,aAAS8pB,WAAT,GAAuB,CAAE;;AACzBA,IAAAA,WAAW,CAAC5iB,SAAZ,GAAwB;AACtBiL,MAAAA,QAAQ,EAAE,YAAW;AACnB,eAAO9K,cAAc,CAACqI,KAAtB;AACD,OAHqB;AAItBqa,MAAAA,QAAQ,EAAE,UAASra,KAAT,EAAgB;AACxBrI,QAAAA,cAAc,CAACqI,KAAf,GAAuBA,KAAvB;AACD,OANqB;AAOtBsa,MAAAA,UAAU,EAAE,YAAW;AACrB,eAAO,KAAKC,aAAZ;AACD,OATqB;AAUtBC,MAAAA,UAAU,EAAE,UAASC,OAAT,EAAkB;AAC5B,aAAKF,aAAL,GAAqBE,OAArB;AACD,OAZqB;AAatB3S,MAAAA,UAAU,EAAE,YAAW;AACrB,eAAOnQ,cAAc,CAACmQ,UAAtB;AACD,OAfqB;AAgBtBxF,MAAAA,WAAW,EAAE,UAASoY,QAAT,EAAmB;AAC9B/iB,QAAAA,cAAc,CAACmQ,UAAf,GAA4B4S,QAA5B;AACD,OAlBqB;AAmBtBC,MAAAA,oBAAoB,EAAE,YAAW;AAC/B,eAAO,KAAKC,QAAZ;AACD,OArBqB;AAsBtBC,MAAAA,oBAAoB,EAAE,UAASD,QAAT,EAAmB;AACvC,aAAKA,QAAL,GAAgBA,QAAhB;AACD;AAxBqB,KAAxB;;AA0BA,aAASvY,cAAT,CAAwB/U,EAAxB,EAA4B;AAC1B,UAAIY,GAAG,GAAGZ,EAAE,CAACW,KAAH,CAASC,GAAnB;AACA,aAAOA,GAAG,CAAC4sB,YAAJ,KAAqB5sB,GAAG,CAAC4sB,YAAJ,GAAmB,IAAIV,WAAJ,EAAxC,CAAP;AACD;;AACD,aAASW,YAAT,CAAsBC,SAAtB,EAAiC;AAC/B,aAAOC,gBAAgB,CAACD,SAAD,EAAY,GAAZ,CAAvB;AACD;;AAED,aAASE,oBAAT,CAA8BF,SAA9B,EAAyC;AACvC,aAAOG,uBAAuB,CAACH,SAAD,EAAY,GAAZ,CAA9B;AACD;;AAED,aAASC,gBAAT,CAA0BD,SAA1B,EAAqCI,SAArC,EAAgD;AAC9C,UAAIC,OAAO,GAAGF,uBAAuB,CAACH,SAAD,EAAYI,SAAZ,CAAvB,IAAiD,EAA/D;AACA,UAAI,CAACC,OAAO,CAACxuB,MAAb,EAAqB,OAAO,EAAP;AACrB,UAAIyuB,MAAM,GAAG,EAAb,CAH8C,CAI9C;;AACA,UAAID,OAAO,CAAC,CAAD,CAAP,KAAe,CAAnB,EAAsB;;AACtB,WAAK,IAAI5rB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG4rB,OAAO,CAACxuB,MAA5B,EAAoC4C,CAAC,EAArC,EAAyC;AACvC,YAAI,OAAO4rB,OAAO,CAAC5rB,CAAD,CAAd,IAAqB,QAAzB,EACE6rB,MAAM,CAACrrB,IAAP,CAAY+qB,SAAS,CAAChe,SAAV,CAAoBqe,OAAO,CAAC5rB,CAAD,CAAP,GAAa,CAAjC,EAAoC4rB,OAAO,CAAC5rB,CAAC,GAAC,CAAH,CAA3C,CAAZ;AACH;;AACD,aAAO6rB,MAAP;AACD;;AAED,aAASH,uBAAT,CAAiCrK,GAAjC,EAAsCsK,SAAtC,EAAiD;AAC/C,UAAI,CAACA,SAAL,EACEA,SAAS,GAAG,GAAZ;AAEF,UAAIG,cAAc,GAAG,KAArB;AACA,UAAIF,OAAO,GAAG,EAAd;;AACA,WAAK,IAAI5rB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqhB,GAAG,CAACjkB,MAAxB,EAAgC4C,CAAC,EAAjC,EAAqC;AACnC,YAAIqH,CAAC,GAAGga,GAAG,CAACjf,MAAJ,CAAWpC,CAAX,CAAR;;AACA,YAAI,CAAC8rB,cAAD,IAAmBzkB,CAAC,IAAIskB,SAA5B,EAAuC;AACrCC,UAAAA,OAAO,CAACprB,IAAR,CAAaR,CAAb;AACD;;AACD8rB,QAAAA,cAAc,GAAG,CAACA,cAAD,IAAoBzkB,CAAC,IAAI,IAA1C;AACD;;AACD,aAAOukB,OAAP;AACD,KAn0HkB,CAq0HnB;;;AACA,aAASG,cAAT,CAAwB1K,GAAxB,EAA6B;AAC3B;AACA,UAAI2K,QAAQ,GAAG,MAAf,CAF2B,CAG3B;;AACA,UAAIC,QAAQ,GAAG,GAAf;AACA,UAAIH,cAAc,GAAG,KAArB;AACA,UAAII,GAAG,GAAG,EAAV;;AACA,WAAK,IAAIlsB,CAAC,GAAG,CAAC,CAAd,EAAiBA,CAAC,GAAGqhB,GAAG,CAACjkB,MAAzB,EAAiC4C,CAAC,EAAlC,EAAsC;AACpC,YAAIqH,CAAC,GAAGga,GAAG,CAACjf,MAAJ,CAAWpC,CAAX,KAAiB,EAAzB;AACA,YAAI0P,CAAC,GAAG2R,GAAG,CAACjf,MAAJ,CAAWpC,CAAC,GAAC,CAAb,KAAmB,EAA3B;AACA,YAAImsB,gBAAgB,GAAIzc,CAAC,IAAIsc,QAAQ,CAACpnB,OAAT,CAAiB8K,CAAjB,KAAuB,CAAC,CAArD;;AACA,YAAIoc,cAAJ,EAAoB;AAClB,cAAIzkB,CAAC,KAAK,IAAN,IAAc,CAAC8kB,gBAAnB,EAAqC;AACnCD,YAAAA,GAAG,CAAC1rB,IAAJ,CAAS6G,CAAT;AACD;;AACDykB,UAAAA,cAAc,GAAG,KAAjB;AACD,SALD,MAKO;AACL,cAAIzkB,CAAC,KAAK,IAAV,EAAgB;AACdykB,YAAAA,cAAc,GAAG,IAAjB,CADc,CAEd;;AACA,gBAAIpc,CAAC,IAAIuc,QAAQ,CAACrnB,OAAT,CAAiB8K,CAAjB,KAAuB,CAAC,CAAjC,EAAoC;AAClCyc,cAAAA,gBAAgB,GAAG,IAAnB;AACD,aALa,CAMd;;;AACA,gBAAI,CAACA,gBAAD,IAAqBzc,CAAC,KAAK,IAA/B,EAAqC;AACnCwc,cAAAA,GAAG,CAAC1rB,IAAJ,CAAS6G,CAAT;AACD;AACF,WAVD,MAUO;AACL6kB,YAAAA,GAAG,CAAC1rB,IAAJ,CAAS6G,CAAT;;AACA,gBAAI8kB,gBAAgB,IAAIzc,CAAC,KAAK,IAA9B,EAAoC;AAClCwc,cAAAA,GAAG,CAAC1rB,IAAJ,CAAS,IAAT;AACD;AACF;AACF;AACF;;AACD,aAAO0rB,GAAG,CAACtpB,IAAJ,CAAS,EAAT,CAAP;AACD,KA12HkB,CA42HnB;AACA;AACA;;;AACA,QAAIwpB,aAAa,GAAG;AAAC,aAAO,IAAR;AAAc,aAAO,IAArB;AAA2B,aAAO;AAAlC,KAApB;;AACA,aAASC,qBAAT,CAA+BhL,GAA/B,EAAoC;AAClC,UAAIyK,cAAc,GAAG,KAArB;AACA,UAAII,GAAG,GAAG,EAAV;;AACA,WAAK,IAAIlsB,CAAC,GAAG,CAAC,CAAd,EAAiBA,CAAC,GAAGqhB,GAAG,CAACjkB,MAAzB,EAAiC4C,CAAC,EAAlC,EAAsC;AACpC,YAAIqH,CAAC,GAAGga,GAAG,CAACjf,MAAJ,CAAWpC,CAAX,KAAiB,EAAzB;AACA,YAAI0P,CAAC,GAAG2R,GAAG,CAACjf,MAAJ,CAAWpC,CAAC,GAAC,CAAb,KAAmB,EAA3B;;AACA,YAAIosB,aAAa,CAAC/kB,CAAC,GAAGqI,CAAL,CAAjB,EAA0B;AACxBwc,UAAAA,GAAG,CAAC1rB,IAAJ,CAAS4rB,aAAa,CAAC/kB,CAAC,GAACqI,CAAH,CAAtB;AACA1P,UAAAA,CAAC;AACF,SAHD,MAGO,IAAI8rB,cAAJ,EAAoB;AACzB;AACA;AACAI,UAAAA,GAAG,CAAC1rB,IAAJ,CAAS6G,CAAT;AACAykB,UAAAA,cAAc,GAAG,KAAjB;AACD,SALM,MAKA;AACL,cAAIzkB,CAAC,KAAK,IAAV,EAAgB;AACdykB,YAAAA,cAAc,GAAG,IAAjB;;AACA,gBAAKjnB,QAAQ,CAAC6K,CAAD,CAAR,IAAeA,CAAC,KAAK,GAA1B,EAAgC;AAC9Bwc,cAAAA,GAAG,CAAC1rB,IAAJ,CAAS,GAAT;AACD,aAFD,MAEO,IAAIkP,CAAC,KAAK,GAAN,IAAaA,CAAC,KAAK,IAAvB,EAA6B;AAClCwc,cAAAA,GAAG,CAAC1rB,IAAJ,CAAS,IAAT;AACD;AACF,WAPD,MAOO;AACL,gBAAI6G,CAAC,KAAK,GAAV,EAAe;AACb6kB,cAAAA,GAAG,CAAC1rB,IAAJ,CAAS,GAAT;AACD;;AACD0rB,YAAAA,GAAG,CAAC1rB,IAAJ,CAAS6G,CAAT;;AACA,gBAAIqI,CAAC,KAAK,GAAV,EAAe;AACbwc,cAAAA,GAAG,CAAC1rB,IAAJ,CAAS,IAAT;AACD;AACF;AACF;AACF;;AACD,aAAO0rB,GAAG,CAACtpB,IAAJ,CAAS,EAAT,CAAP;AACD,KAl5HkB,CAo5HnB;;;AACA,QAAI0pB,SAAS,GAAG;AAAC,aAAO,GAAR;AAAa,cAAQ,IAArB;AAA2B,aAAO,IAAlC;AAAwC,aAAO,IAA/C;AAAqD,aAAO,IAA5D;AAAkE,aAAM;AAAxE,KAAhB;;AACA,aAASC,oBAAT,CAA8BlL,GAA9B,EAAmC;AACjC,UAAImL,MAAM,GAAG,IAAIjyB,UAAU,CAACkyB,YAAf,CAA4BpL,GAA5B,CAAb;AACA,UAAIqL,MAAM,GAAG,EAAb;;AACA,aAAO,CAACF,MAAM,CAACG,GAAP,EAAR,EAAsB;AACpB;AACA,eAAOH,MAAM,CAACI,IAAP,MAAiBJ,MAAM,CAACI,IAAP,MAAiB,IAAzC,EAA+C;AAC7CF,UAAAA,MAAM,CAAClsB,IAAP,CAAYgsB,MAAM,CAAC7tB,IAAP,EAAZ;AACD;;AACD,YAAIud,OAAO,GAAG,KAAd;;AACA,aAAK,IAAI2Q,OAAT,IAAoBP,SAApB,EAA+B;AAC7B,cAAIE,MAAM,CAACnf,KAAP,CAAawf,OAAb,EAAsB,IAAtB,CAAJ,EAAiC;AAC/B3Q,YAAAA,OAAO,GAAG,IAAV;AACAwQ,YAAAA,MAAM,CAAClsB,IAAP,CAAY8rB,SAAS,CAACO,OAAD,CAArB;AACA;AACD;AACF;;AACD,YAAI,CAAC3Q,OAAL,EAAc;AACZ;AACAwQ,UAAAA,MAAM,CAAClsB,IAAP,CAAYgsB,MAAM,CAAC7tB,IAAP,EAAZ;AACD;AACF;;AACD,aAAO+tB,MAAM,CAAC9pB,IAAP,CAAY,EAAZ,CAAP;AACD;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI,aAASkqB,UAAT,CAAoBvc,KAApB,EAA2B6C,UAA3B,EAAuCC,SAAvC,EAAkD;AAChD;AACA,UAAI0Z,kBAAkB,GAAG7kB,cAAc,CAACI,kBAAf,CAAkCC,WAAlC,CAA8C,GAA9C,CAAzB;AACAwkB,MAAAA,kBAAkB,CAAC5c,OAAnB,CAA2BI,KAA3B,EAHgD,CAIhD;;AACA,UAAIA,KAAK,YAAYnM,MAArB,EAA6B;AAAE,eAAOmM,KAAP;AAAe,OALE,CAMhD;AACA;AACA;;;AACA,UAAIqb,OAAO,GAAGH,oBAAoB,CAAClb,KAAD,CAAlC;AACA,UAAIyc,SAAJ;AACA,UAAIC,eAAJ;;AACA,UAAI,CAACrB,OAAO,CAACxuB,MAAb,EAAqB;AACnB;AACA4vB,QAAAA,SAAS,GAAGzc,KAAZ;AACD,OAHD,MAGO;AACL;AACAyc,QAAAA,SAAS,GAAGzc,KAAK,CAAChD,SAAN,CAAgB,CAAhB,EAAmBqe,OAAO,CAAC,CAAD,CAA1B,CAAZ;AACA,YAAIsB,SAAS,GAAG3c,KAAK,CAAChD,SAAN,CAAgBqe,OAAO,CAAC,CAAD,CAAvB,CAAhB;AACAqB,QAAAA,eAAe,GAAIC,SAAS,CAACtoB,OAAV,CAAkB,GAAlB,KAA0B,CAAC,CAA9C;AACD;;AACD,UAAI,CAACooB,SAAL,EAAgB;AACd,eAAO,IAAP;AACD;;AACD,UAAI,CAACjuB,SAAS,CAAC,MAAD,CAAd,EAAwB;AACtBiuB,QAAAA,SAAS,GAAGjB,cAAc,CAACiB,SAAD,CAA1B;AACD;;AACD,UAAI3Z,SAAJ,EAAe;AACbD,QAAAA,UAAU,GAAI,WAAD,CAAcpS,IAAd,CAAmBgsB,SAAnB,CAAb;AACD;;AACD,UAAIG,MAAM,GAAG,IAAI/oB,MAAJ,CAAW4oB,SAAX,EACR5Z,UAAU,IAAI6Z,eAAf,GAAkC,IAAlC,GAAyC,GADhC,CAAb;AAEA,aAAOE,MAAP;AACD;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI,aAASC,GAAT,CAAa1d,CAAb,EAAgB;AACd,UAAI,OAAOA,CAAP,KAAa,QAAjB,EAA2BA,CAAC,GAAG1Q,QAAQ,CAACquB,aAAT,CAAuB3d,CAAvB,CAAJ;;AAC3B,WAAK,IAAI4d,CAAJ,EAAOttB,CAAC,GAAG,CAAhB,EAAmBA,CAAC,GAAG4kB,SAAS,CAACxnB,MAAjC,EAAyC4C,CAAC,EAA1C,EAA8C;AAC5C,YAAI,EAAEstB,CAAC,GAAG1I,SAAS,CAAC5kB,CAAD,CAAf,CAAJ,EAAyB;AACzB,YAAI,OAAOstB,CAAP,KAAa,QAAjB,EAA2BA,CAAC,GAAGtuB,QAAQ,CAACyJ,cAAT,CAAwB6kB,CAAxB,CAAJ;AAC3B,YAAIA,CAAC,CAACC,QAAN,EAAgB7d,CAAC,CAAC8d,WAAF,CAAcF,CAAd,EAAhB,KACK,KAAK,IAAIpsB,GAAT,IAAgBosB,CAAhB,EAAmB;AACtB,cAAI,CAACG,MAAM,CAAC1lB,SAAP,CAAiBkc,cAAjB,CAAgCa,IAAhC,CAAqCwI,CAArC,EAAwCpsB,GAAxC,CAAL,EAAmD;AACnD,cAAIA,GAAG,CAAC,CAAD,CAAH,KAAW,GAAf,EAAoBwO,CAAC,CAACxQ,KAAF,CAAQgC,GAAG,CAACiL,KAAJ,CAAU,CAAV,CAAR,IAAwBmhB,CAAC,CAACpsB,GAAD,CAAzB,CAApB,KACKwO,CAAC,CAACge,YAAF,CAAexsB,GAAf,EAAoBosB,CAAC,CAACpsB,GAAD,CAArB;AACN;AACF;;AACD,aAAOwO,CAAP;AACD;;AAED,aAAS6D,WAAT,CAAqB1V,EAArB,EAAyB8vB,QAAzB,EAAmC;AACjC,UAAIC,GAAG,GAAGR,GAAG,CAAC,KAAD,EAAQ;AAACS,QAAAA,MAAM,EAAE;AAAT,OAAR,EAAyBF,QAAzB,CAAb;;AACA,UAAI9vB,EAAE,CAACiwB,gBAAP,EAAyB;AACvBjwB,QAAAA,EAAE,CAACiwB,gBAAH,CAAoBF,GAApB,EAAyB;AAACllB,UAAAA,MAAM,EAAE,IAAT;AAAeqlB,UAAAA,QAAQ,EAAE;AAAzB,SAAzB;AACD,OAFD,MAEO;AACLC,QAAAA,KAAK,CAACJ,GAAG,CAACK,SAAL,CAAL;AACD;AACF;;AAED,aAASC,UAAT,CAAoB3hB,MAApB,EAA4BwI,IAA5B,EAAkC;AAChC,aAAOqY,GAAG,CAACpuB,QAAQ,CAACmvB,sBAAT,EAAD,EACDf,GAAG,CAAC,MAAD,EAAS;AAACgB,QAAAA,WAAW,EAAE,WAAd;AAA2BC,QAAAA,WAAW,EAAE;AAAxC,OAAT,EACD9hB,MADC,EAED6gB,GAAG,CAAC,OAAD,EAAU;AAAC1yB,QAAAA,IAAI,EAAE,MAAP;AAAe4zB,QAAAA,WAAW,EAAE,KAA5B;AACCC,QAAAA,cAAc,EAAE,KADjB;AACwBC,QAAAA,UAAU,EAAE;AADpC,OAAV,CAFF,CADF,EAKDzZ,IAAI,IAAIqY,GAAG,CAAC,MAAD,EAAS;AAACS,QAAAA,MAAM,EAAE;AAAT,OAAT,EAA2B9Y,IAA3B,CALV,CAAV;AAMD;;AAED,aAASF,UAAT,CAAoBhX,EAApB,EAAwBqH,OAAxB,EAAiC;AAC/B,UAAIupB,SAAS,GAAG,CAACvpB,OAAO,CAACqH,MAAR,IAAkB,EAAnB,IAAyB,GAAzB,IAAgCrH,OAAO,CAAC6P,IAAR,IAAgB,EAAhD,CAAhB;AACA,UAAI4Y,QAAQ,GAAGO,UAAU,CAAChpB,OAAO,CAACqH,MAAT,EAAiBrH,OAAO,CAAC6P,IAAzB,CAAzB;;AACA,UAAIlX,EAAE,CAAC2K,UAAP,EAAmB;AACjB3K,QAAAA,EAAE,CAAC2K,UAAH,CAAcmlB,QAAd,EAAwBzoB,OAAO,CAAC4P,OAAhC,EAAyC;AACvCG,UAAAA,SAAS,EAAE/P,OAAO,CAAC+P,SADoB;AACTD,UAAAA,OAAO,EAAE9P,OAAO,CAAC8P,OADR;AAEvCtM,UAAAA,MAAM,EAAE,IAF+B;AAEzB8M,UAAAA,iBAAiB,EAAE,KAFM;AAECjQ,UAAAA,KAAK,EAAEL,OAAO,CAACK;AAFhB,SAAzC;AAID,OALD,MAMK;AACHL,QAAAA,OAAO,CAAC4P,OAAR,CAAgB4Z,MAAM,CAACD,SAAD,EAAY,EAAZ,CAAtB;AACD;AACF;;AAED,aAASE,UAAT,CAAoBC,EAApB,EAAwBC,EAAxB,EAA4B;AAC1B,UAAID,EAAE,YAAYxqB,MAAd,IAAwByqB,EAAE,YAAYzqB,MAA1C,EAAkD;AAC9C,YAAI0qB,KAAK,GAAG,CAAC,QAAD,EAAW,WAAX,EAAwB,YAAxB,EAAsC,QAAtC,CAAZ;;AACA,aAAK,IAAI9uB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG8uB,KAAK,CAAC1xB,MAA1B,EAAkC4C,CAAC,EAAnC,EAAuC;AACnC,cAAIgkB,IAAI,GAAG8K,KAAK,CAAC9uB,CAAD,CAAhB;;AACA,cAAI4uB,EAAE,CAAC5K,IAAD,CAAF,KAAa6K,EAAE,CAAC7K,IAAD,CAAnB,EAA2B;AACvB,mBAAO,KAAP;AACH;AACJ;;AACD,eAAO,IAAP;AACH;;AACD,aAAO,KAAP;AACD,KAhiIkB,CAiiInB;;;AACA,aAAS1Q,iBAAT,CAA2BzV,EAA3B,EAA+BkxB,QAA/B,EAAyC3b,UAAzC,EAAqDC,SAArD,EAAgE;AAC9D,UAAI,CAAC0b,QAAL,EAAe;AACb;AACD;;AACD,UAAIvwB,KAAK,GAAGoU,cAAc,CAAC/U,EAAD,CAA1B;AACA,UAAI0S,KAAK,GAAGuc,UAAU,CAACiC,QAAD,EAAW,CAAC,CAAC3b,UAAb,EAAyB,CAAC,CAACC,SAA3B,CAAtB;;AACA,UAAI,CAAC9C,KAAL,EAAY;AACV;AACD;;AACD+H,MAAAA,sBAAsB,CAACza,EAAD,EAAK0S,KAAL,CAAtB;;AACA,UAAIoe,UAAU,CAACpe,KAAD,EAAQ/R,KAAK,CAACwU,QAAN,EAAR,CAAd,EAAyC;AACvC,eAAOzC,KAAP;AACD;;AACD/R,MAAAA,KAAK,CAACosB,QAAN,CAAera,KAAf;AACA,aAAOA,KAAP;AACD;;AACD,aAASua,aAAT,CAAuBva,KAAvB,EAA8B;AAC5B,UAAIA,KAAK,CAACye,MAAN,CAAa5sB,MAAb,CAAoB,CAApB,KAA0B,GAA9B,EAAmC;AACjC,YAAI6sB,QAAQ,GAAG,IAAf;AACD;;AACD,aAAO;AACL3G,QAAAA,KAAK,EAAE,UAASkE,MAAT,EAAiB;AACtB,cAAIyC,QAAQ,IAAI,CAACzC,MAAM,CAAC0C,GAAP,EAAjB,EAA+B;AAC7B1C,YAAAA,MAAM,CAAC2C,SAAP;AACA;AACD;;AACD,cAAI9hB,KAAK,GAAGmf,MAAM,CAACnf,KAAP,CAAakD,KAAb,EAAoB,KAApB,CAAZ;;AACA,cAAIlD,KAAJ,EAAW;AACT,gBAAIA,KAAK,CAAC,CAAD,CAAL,CAASjQ,MAAT,IAAmB,CAAvB,EAA0B;AACxB;AACAovB,cAAAA,MAAM,CAAC7tB,IAAP;AACA,qBAAO,WAAP;AACD;;AACD,gBAAI,CAAC6tB,MAAM,CAAC0C,GAAP,EAAL,EAAmB;AACjB;AACA1C,cAAAA,MAAM,CAAC4C,MAAP,CAAc,CAAd;;AACA,kBAAI,CAAC7e,KAAK,CAACjD,IAAN,CAAWkf,MAAM,CAAC7tB,IAAP,KAAgB0O,KAAK,CAAC,CAAD,CAAhC,CAAL,EAA2C;AACzCmf,gBAAAA,MAAM,CAAC7tB,IAAP;AACA,uBAAO,IAAP;AACD;AACF;;AACD6tB,YAAAA,MAAM,CAACnf,KAAP,CAAakD,KAAb;AACA,mBAAO,WAAP;AACD;;AACD,iBAAO,CAACic,MAAM,CAACG,GAAP,EAAR,EAAsB;AACpBH,YAAAA,MAAM,CAAC7tB,IAAP;AACA,gBAAI6tB,MAAM,CAACnf,KAAP,CAAakD,KAAb,EAAoB,KAApB,CAAJ,EAAgC;AACjC;AACF,SA5BI;AA6BLA,QAAAA,KAAK,EAAEA;AA7BF,OAAP;AA+BD;;AACD,QAAI8e,gBAAgB,GAAG,CAAvB;;AACA,aAAS/W,sBAAT,CAAgCza,EAAhC,EAAoC0S,KAApC,EAA2C;AACzCvC,MAAAA,YAAY,CAACqhB,gBAAD,CAAZ;AACAA,MAAAA,gBAAgB,GAAGphB,UAAU,CAAC,YAAW;AACvC,YAAIqhB,WAAW,GAAG1c,cAAc,CAAC/U,EAAD,CAAhC;AACA,YAAImtB,OAAO,GAAGsE,WAAW,CAACzE,UAAZ,EAAd;;AACA,YAAI,CAACG,OAAD,IAAYza,KAAK,IAAIya,OAAO,CAACza,KAAjC,EAAwC;AACtC,cAAIya,OAAJ,EAAa;AACXntB,YAAAA,EAAE,CAAC0xB,aAAH,CAAiBvE,OAAjB;AACD;;AACDA,UAAAA,OAAO,GAAGF,aAAa,CAACva,KAAD,CAAvB;AACA1S,UAAAA,EAAE,CAAC2xB,UAAH,CAAcxE,OAAd;;AACA,cAAIntB,EAAE,CAAC4xB,sBAAP,EAA+B;AAC7B,gBAAIH,WAAW,CAACpE,oBAAZ,EAAJ,EAAwC;AACtCoE,cAAAA,WAAW,CAACpE,oBAAZ,GAAmCtqB,KAAnC;AACD;;AACD0uB,YAAAA,WAAW,CAAClE,oBAAZ,CAAiCvtB,EAAE,CAAC4xB,sBAAH,CAA0Blf,KAA1B,CAAjC;AACD;;AACD+e,UAAAA,WAAW,CAACvE,UAAZ,CAAuBC,OAAvB;AACD;AACF,OAjB4B,EAiB1B,EAjB0B,CAA7B;AAkBD;;AACD,aAASzW,QAAT,CAAkB1W,EAAlB,EAAsB0B,IAAtB,EAA4BgR,KAA5B,EAAmCX,MAAnC,EAA2C;AACzC,UAAIA,MAAM,KAAKzO,SAAf,EAA0B;AAAEyO,QAAAA,MAAM,GAAG,CAAT;AAAa;;AACzC,aAAO/R,EAAE,CAAC8Q,SAAH,CAAa,YAAW;AAC7B,YAAImK,GAAG,GAAGjb,EAAE,CAACoF,SAAH,EAAV;AACA,YAAIuD,MAAM,GAAG3I,EAAE,CAAC8U,eAAH,CAAmBpC,KAAnB,EAA0BuI,GAA1B,CAAb;;AACA,aAAK,IAAI9Y,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG4P,MAApB,EAA4B5P,CAAC,EAA7B,EAAiC;AAC/B,cAAImoB,KAAK,GAAG3hB,MAAM,CAACI,IAAP,CAAYrH,IAAZ,CAAZ;;AACA,cAAIS,CAAC,IAAI,CAAL,IAAUmoB,KAAV,IAAmBthB,WAAW,CAACL,MAAM,CAACkS,IAAP,EAAD,EAAgBI,GAAhB,CAAlC,EAAwD;AACtD,gBAAI4W,UAAU,GAAGnwB,IAAI,GAAGiH,MAAM,CAACkS,IAAP,EAAH,GAAmBlS,MAAM,CAACmS,EAAP,EAAxC;AACAwP,YAAAA,KAAK,GAAG3hB,MAAM,CAACI,IAAP,CAAYrH,IAAZ,CAAR;;AACA,gBAAI4oB,KAAK,IAAI,CAACA,KAAK,CAAC,CAAD,CAAf,IAAsBthB,WAAW,CAACL,MAAM,CAACkS,IAAP,EAAD,EAAgBgX,UAAhB,CAArC,EAAkE;AAChE,kBAAI7xB,EAAE,CAACuC,OAAH,CAAWsvB,UAAU,CAACpvB,IAAtB,EAA4BlD,MAA5B,IAAsCsyB,UAAU,CAACnvB,EAArD,EACE4nB,KAAK,GAAG3hB,MAAM,CAACI,IAAP,CAAYrH,IAAZ,CAAR;AACH;AACF;;AACD,cAAI,CAAC4oB,KAAL,EAAY;AACV;AACA;AACA3hB,YAAAA,MAAM,GAAG3I,EAAE,CAAC8U,eAAH,CAAmBpC,KAAnB,EACJhR,IAAD,GAAS7B,GAAG,CAACG,EAAE,CAAC2G,QAAH,EAAD,CAAZ,GAA8B9G,GAAG,CAACG,EAAE,CAAC0G,SAAH,EAAD,EAAiB,CAAjB,CAD5B,CAAT;;AAEA,gBAAI,CAACiC,MAAM,CAACI,IAAP,CAAYrH,IAAZ,CAAL,EAAwB;AACtB;AACD;AACF;AACF;;AACD,eAAOiH,MAAM,CAACkS,IAAP,EAAP;AACD,OAxBM,CAAP;AAyBD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACI,aAASD,0BAAT,CAAoC5a,EAApC,EAAwC0B,IAAxC,EAA8CgR,KAA9C,EAAqDX,MAArD,EAA6DnR,GAA7D,EAAkE;AAChE,UAAImR,MAAM,KAAKzO,SAAf,EAA0B;AAAEyO,QAAAA,MAAM,GAAG,CAAT;AAAa;;AACzC,aAAO/R,EAAE,CAAC8Q,SAAH,CAAa,YAAW;AAC7B,YAAImK,GAAG,GAAGjb,EAAE,CAACoF,SAAH,EAAV;AACA,YAAIuD,MAAM,GAAG3I,EAAE,CAAC8U,eAAH,CAAmBpC,KAAnB,EAA0BuI,GAA1B,CAAb,CAF6B,CAI7B;;AACA,YAAIqP,KAAK,GAAG3hB,MAAM,CAACI,IAAP,CAAY,CAACrH,IAAb,CAAZ,CAL6B,CAO7B;;AACA,YAAI,CAACd,GAAG,CAAC2K,UAAL,IAAmB+e,KAAnB,IAA4BthB,WAAW,CAACL,MAAM,CAACkS,IAAP,EAAD,EAAgBI,GAAhB,CAA3C,EAAiE;AAC/DtS,UAAAA,MAAM,CAACI,IAAP,CAAY,CAACrH,IAAb;AACD;;AAED,aAAK,IAAIS,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG4P,MAApB,EAA4B5P,CAAC,EAA7B,EAAiC;AAC/BmoB,UAAAA,KAAK,GAAG3hB,MAAM,CAACI,IAAP,CAAYrH,IAAZ,CAAR;;AACA,cAAI,CAAC4oB,KAAL,EAAY;AACV;AACA;AACA3hB,YAAAA,MAAM,GAAG3I,EAAE,CAAC8U,eAAH,CAAmBpC,KAAnB,EACJhR,IAAD,GAAS7B,GAAG,CAACG,EAAE,CAAC2G,QAAH,EAAD,CAAZ,GAA8B9G,GAAG,CAACG,EAAE,CAAC0G,SAAH,EAAD,EAAiB,CAAjB,CAD5B,CAAT;;AAEA,gBAAI,CAACiC,MAAM,CAACI,IAAP,CAAYrH,IAAZ,CAAL,EAAwB;AACtB;AACD;AACF;AACF;;AACD,eAAO,CAACiH,MAAM,CAACkS,IAAP,EAAD,EAAgBlS,MAAM,CAACmS,EAAP,EAAhB,CAAP;AACD,OAzBM,CAAP;AA0BD;;AACD,aAASnE,oBAAT,CAA8B3W,EAA9B,EAAkC;AAChC,UAAIW,KAAK,GAAGoU,cAAc,CAAC/U,EAAD,CAA1B;AACAA,MAAAA,EAAE,CAAC0xB,aAAH,CAAiB3c,cAAc,CAAC/U,EAAD,CAAd,CAAmBgtB,UAAnB,EAAjB;AACArsB,MAAAA,KAAK,CAACusB,UAAN,CAAiB,IAAjB;;AACA,UAAIvsB,KAAK,CAAC0sB,oBAAN,EAAJ,EAAkC;AAChC1sB,QAAAA,KAAK,CAAC0sB,oBAAN,GAA6BtqB,KAA7B;AACApC,QAAAA,KAAK,CAAC4sB,oBAAN,CAA2B,IAA3B;AACD;AACF;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI,aAASuE,SAAT,CAAmB7W,GAAnB,EAAwBrV,KAAxB,EAA+B4R,GAA/B,EAAoC;AAClC,UAAI,OAAOyD,GAAP,IAAc,QAAlB,EAA4B;AAC1B;AACAA,QAAAA,GAAG,GAAGA,GAAG,CAACxY,IAAV;AACD;;AACD,UAAImD,KAAK,YAAYwC,KAArB,EAA4B;AAC1B,eAAOjB,OAAO,CAAC8T,GAAD,EAAMrV,KAAN,CAAd;AACD,OAFD,MAEO;AACL,YAAI,OAAO4R,GAAP,IAAc,QAAlB,EAA4B;AAC1B,iBAAQyD,GAAG,IAAIrV,KAAP,IAAgBqV,GAAG,IAAIzD,GAA/B;AACD,SAFD,MAEO;AACL,iBAAOyD,GAAG,IAAIrV,KAAd;AACD;AACF;AACF;;AACD,aAASoU,mBAAT,CAA6Bha,EAA7B,EAAiC;AAC/B,UAAI+xB,UAAU,GAAG/xB,EAAE,CAACqV,aAAH,EAAjB;AACA,UAAI2c,mBAAmB,GAAG,CAA1B;AACA,UAAIC,sBAAsB,GAAG,EAA7B;AACA,UAAIpX,IAAI,GAAG7a,EAAE,CAAC4c,UAAH,CAAc;AAAC/G,QAAAA,IAAI,EAAC,CAAN;AAASC,QAAAA,GAAG,EAAEkc,mBAAmB,GAAGD,UAAU,CAACjc;AAA/C,OAAd,EAAmE,OAAnE,CAAX;AACA,UAAIoc,OAAO,GAAGH,UAAU,CAAC3U,YAAX,GAA0B6U,sBAA1B,GAAmDF,UAAU,CAACjc,GAA5E;AACA,UAAIgF,EAAE,GAAG9a,EAAE,CAAC4c,UAAH,CAAc;AAAC/G,QAAAA,IAAI,EAAC,CAAN;AAASC,QAAAA,GAAG,EAAEoc;AAAd,OAAd,EAAsC,OAAtC,CAAT;AACA,aAAO;AAACpc,QAAAA,GAAG,EAAE+E,IAAI,CAACpY,IAAX;AAAiBoI,QAAAA,MAAM,EAAEiQ,EAAE,CAACrY;AAA5B,OAAP;AACD;;AAED,aAASyY,UAAT,CAAoBlb,EAApB,EAAwBY,GAAxB,EAA6BukB,QAA7B,EAAuC;AACrC,UAAIA,QAAQ,IAAI,IAAZ,IAAoBA,QAAQ,IAAI,GAApC,EAAyC;AACvC,eAAO9a,cAAc,CAAC2B,QAAf,CAAwBjD,IAAxB,CAA6B/I,EAA7B,EAAiC,CAAC,CAAlC,KAAwCH,GAAG,CAAC,CAAD,EAAI,CAAJ,CAAlD;AACD,OAFD,MAEO,IAAIslB,QAAQ,IAAI,GAAhB,EAAqB;AAC1B,eAAO9C,cAAc,CAACriB,EAAD,CAArB;AACD;;AAED,UAAImJ,IAAI,GAAGvI,GAAG,CAACkC,KAAJ,CAAUqiB,QAAV,CAAX;AACA,aAAOhc,IAAI,IAAIA,IAAI,CAACJ,IAAL,EAAf;AACD;;AAED,aAASsZ,cAAT,CAAwBriB,EAAxB,EAA4B;AAC1B,UAAImyB,IAAI,GAAGnyB,EAAE,CAACoyB,GAAH,CAAOC,OAAP,CAAeF,IAA1B;;AACA,WAAK,IAAIhwB,CAAC,GAAGgwB,IAAI,CAAC5yB,MAAlB,EAA0B4C,CAAC,EAA3B,GAAgC;AAC9B,YAAIgwB,IAAI,CAAChwB,CAAD,CAAJ,CAAQsH,OAAZ,EAAqB;AACnB,iBAAOoO,UAAU,CAACsa,IAAI,CAAChwB,CAAD,CAAJ,CAAQsH,OAAR,CAAgB,CAAhB,EAAmBqR,EAApB,CAAjB;AACD;AACF;AACF;;AAED,QAAIwX,mBAAmB,GAAG,YAAW;AACnC,WAAKC,gBAAL;AACD,KAFD;;AAGAD,IAAAA,mBAAmB,CAACpoB,SAApB,GAAgC;AAC9B+G,MAAAA,cAAc,EAAE,UAASjR,EAAT,EAAaqR,KAAb,EAAoBmhB,UAApB,EAAgC;AAC9C,YAAIC,IAAI,GAAG,IAAX;AACAzyB,QAAAA,EAAE,CAAC8Q,SAAH,CAAa,YAAY;AACvB9Q,UAAAA,EAAE,CAAC+Q,KAAH,CAASC,OAAT,GAAmB,IAAnB;;AACAyhB,UAAAA,IAAI,CAACC,eAAL,CAAqB1yB,EAArB,EAAyBqR,KAAzB,EAAgCmhB,UAAhC;AACD,SAHD;AAID,OAP6B;AAQ9BE,MAAAA,eAAe,EAAE,UAAS1yB,EAAT,EAAaqR,KAAb,EAAoBmhB,UAApB,EAAgC;AAC/C,YAAI5xB,GAAG,GAAGZ,EAAE,CAACW,KAAH,CAASC,GAAnB;AACA,YAAI+xB,sBAAsB,GAAGtoB,cAAc,CAACI,kBAAf,CAAkCC,WAAlC,CAA8C,GAA9C,CAA7B;AACA,YAAIkoB,eAAe,GAAGD,sBAAsB,CAAChgB,QAAvB,EAAtB;;AACA,YAAI/R,GAAG,CAAC2K,UAAR,EAAoB;AAClB8D,UAAAA,cAAc,CAACrP,EAAD,CAAd;AACD;;AACD,YAAI6yB,WAAW,GAAG,IAAIn2B,UAAU,CAACkyB,YAAf,CAA4Bvd,KAA5B,CAAlB,CAP+C,CAQ/C;;AACAshB,QAAAA,sBAAsB,CAACrgB,OAAvB,CAA+BjB,KAA/B;AACA,YAAIyhB,MAAM,GAAGN,UAAU,IAAI,EAA3B;AACAM,QAAAA,MAAM,CAACzhB,KAAP,GAAeA,KAAf;;AACA,YAAI;AACF,eAAK0hB,WAAL,CAAiB/yB,EAAjB,EAAqB6yB,WAArB,EAAkCC,MAAlC;AACD,SAFD,CAEE,OAAM5hB,CAAN,EAAS;AACTwE,UAAAA,WAAW,CAAC1V,EAAD,EAAKkR,CAAC,CAACyB,QAAF,EAAL,CAAX;AACA,gBAAMzB,CAAN;AACD;;AACD,YAAIlC,OAAJ;AACA,YAAIgkB,WAAJ;;AACA,YAAI,CAACF,MAAM,CAACE,WAAZ,EAAyB;AACvB;AACA,cAAIF,MAAM,CAACrwB,IAAP,KAAgBa,SAApB,EAA+B;AAC7B0vB,YAAAA,WAAW,GAAG,MAAd;AACD;AACF,SALD,MAKO;AACLhkB,UAAAA,OAAO,GAAG,KAAKikB,aAAL,CAAmBH,MAAM,CAACE,WAA1B,CAAV;;AACA,cAAIhkB,OAAJ,EAAa;AACXgkB,YAAAA,WAAW,GAAGhkB,OAAO,CAACvP,IAAtB;;AACA,gBAAIuP,OAAO,CAACpP,yBAAZ,EAAuC;AACrC+yB,cAAAA,sBAAsB,CAACrgB,OAAvB,CAA+BsgB,eAA/B;AACD;;AACD,iBAAKM,iBAAL,CAAuBL,WAAvB,EAAoCC,MAApC,EAA4C9jB,OAA5C;;AACA,gBAAIA,OAAO,CAACnS,IAAR,IAAgB,SAApB,EAA+B;AAC7B;AACA,mBAAK,IAAIsF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG6M,OAAO,CAAClS,MAAR,CAAeyC,MAAnC,EAA2C4C,CAAC,EAA5C,EAAgD;AAC9CzF,gBAAAA,UAAU,CAACoD,GAAX,CAAegP,SAAf,CAAyB9O,EAAzB,EAA6BgP,OAAO,CAAClS,MAAR,CAAeqF,CAAf,CAA7B,EAAgD,SAAhD;AACD;;AACD;AACD,aAND,MAMO,IAAI6M,OAAO,CAACnS,IAAR,IAAgB,QAApB,EAA8B;AACnC;AACA,mBAAKoU,cAAL,CAAoBjR,EAApB,EAAwBgP,OAAO,CAACmkB,OAAhC;AACA;AACD;AACF;AACF;;AACD,YAAI,CAACH,WAAL,EAAkB;AAChBtd,UAAAA,WAAW,CAAC1V,EAAD,EAAK,6BAA6BqR,KAA7B,GAAqC,GAA1C,CAAX;AACA;AACD;;AACD,YAAI;AACFzC,UAAAA,UAAU,CAACokB,WAAD,CAAV,CAAwBhzB,EAAxB,EAA4B8yB,MAA5B,EADE,CAEF;AACA;AACA;;AACA,cAAI,CAAC,CAAC9jB,OAAD,IAAY,CAACA,OAAO,CAACrP,aAAtB,KAAwCmzB,MAAM,CAACtrB,QAAnD,EAA6D;AAC3DsrB,YAAAA,MAAM,CAACtrB,QAAP;AACD;AACF,SARD,CAQE,OAAM0J,CAAN,EAAS;AACTwE,UAAAA,WAAW,CAAC1V,EAAD,EAAKkR,CAAC,CAACyB,QAAF,EAAL,CAAX;AACA,gBAAMzB,CAAN;AACD;AACF,OAtE6B;AAuE9B6hB,MAAAA,WAAW,EAAE,UAAS/yB,EAAT,EAAa6yB,WAAb,EAA0B3wB,MAA1B,EAAkC;AAC7C2wB,QAAAA,WAAW,CAACO,QAAZ,CAAqB,GAArB,EAD6C,CAE7C;;AACA,YAAIP,WAAW,CAACQ,GAAZ,CAAgB,GAAhB,CAAJ,EAA0B;AACxBnxB,UAAAA,MAAM,CAACO,IAAP,GAAczC,EAAE,CAAC0G,SAAH,EAAd;AACAxE,UAAAA,MAAM,CAACoxB,OAAP,GAAiBtzB,EAAE,CAAC2G,QAAH,EAAjB;AACD,SAHD,MAGO;AACLzE,UAAAA,MAAM,CAACO,IAAP,GAAc,KAAK8wB,cAAL,CAAoBvzB,EAApB,EAAwB6yB,WAAxB,CAAd;;AACA,cAAI3wB,MAAM,CAACO,IAAP,KAAgBa,SAAhB,IAA6BuvB,WAAW,CAACQ,GAAZ,CAAgB,GAAhB,CAAjC,EAAuD;AACrDnxB,YAAAA,MAAM,CAACoxB,OAAP,GAAiB,KAAKC,cAAL,CAAoBvzB,EAApB,EAAwB6yB,WAAxB,CAAjB;AACD;AACF,SAX4C,CAa7C;;;AACA,YAAItM,YAAY,GAAGsM,WAAW,CAACrjB,KAAZ,CAAkB,0BAAlB,CAAnB;;AACA,YAAI+W,YAAJ,EAAkB;AAChBrkB,UAAAA,MAAM,CAAC8wB,WAAP,GAAqBzM,YAAY,CAAC,CAAD,CAAjC;AACD,SAFD,MAEO;AACLrkB,UAAAA,MAAM,CAAC8wB,WAAP,GAAqBH,WAAW,CAACrjB,KAAZ,CAAkB,IAAlB,EAAwB,CAAxB,CAArB;AACD;;AAED,eAAOtN,MAAP;AACD,OA7F6B;AA8F9BqxB,MAAAA,cAAc,EAAE,UAASvzB,EAAT,EAAa6yB,WAAb,EAA0B;AACxC,YAAIW,WAAW,GAAGX,WAAW,CAACrjB,KAAZ,CAAkB,QAAlB,CAAlB;;AACA,YAAIgkB,WAAJ,EAAiB;AACf;AACA;AACA,iBAAOxhB,QAAQ,CAACwhB,WAAW,CAAC,CAAD,CAAZ,EAAiB,EAAjB,CAAR,GAA+B,CAAtC;AACD;;AACD,gBAAQX,WAAW,CAAC/xB,IAAZ,EAAR;AACE,eAAK,GAAL;AACE,mBAAO,KAAK2yB,oBAAL,CAA0BZ,WAA1B,EAAuC7yB,EAAE,CAACoF,SAAH,GAAe3C,IAAtD,CAAP;;AACF,eAAK,GAAL;AACE,mBAAO,KAAKgxB,oBAAL,CAA0BZ,WAA1B,EAAuC7yB,EAAE,CAAC2G,QAAH,EAAvC,CAAP;;AACF,eAAK,IAAL;AACE,gBAAIwe,QAAQ,GAAG0N,WAAW,CAAC/xB,IAAZ,EAAf;AACA,gBAAIgI,OAAO,GAAGoS,UAAU,CAAClb,EAAD,EAAKA,EAAE,CAACW,KAAH,CAASC,GAAd,EAAmBukB,QAAnB,CAAxB;AACA,gBAAI,CAACrc,OAAL,EAAc,MAAM,IAAIrB,KAAJ,CAAU,cAAV,CAAN;AACd,mBAAO,KAAKgsB,oBAAL,CAA0BZ,WAA1B,EAAuC/pB,OAAO,CAACrG,IAA/C,CAAP;;AACF,eAAK,GAAL;AACA,eAAK,GAAL;AACEowB,YAAAA,WAAW,CAACtB,MAAZ,CAAmB,CAAnB,EADF,CAEE;;AACA,mBAAO,KAAKkC,oBAAL,CAA0BZ,WAA1B,EAAuC7yB,EAAE,CAACoF,SAAH,GAAe3C,IAAtD,CAAP;;AACF;AACEowB,YAAAA,WAAW,CAACtB,MAAZ,CAAmB,CAAnB;AACA,mBAAOjuB,SAAP;AAjBJ;AAmBD,OAxH6B;AAyH9BmwB,MAAAA,oBAAoB,EAAE,UAASZ,WAAT,EAAsBpwB,IAAtB,EAA4B;AAChD,YAAIixB,WAAW,GAAGb,WAAW,CAACrjB,KAAZ,CAAkB,eAAlB,CAAlB;;AACA,YAAIkkB,WAAJ,EAAiB;AACf,cAAIxqB,MAAM,GAAG8I,QAAQ,CAAC0hB,WAAW,CAAC,CAAD,CAAZ,EAAiB,EAAjB,CAArB;;AACA,cAAIA,WAAW,CAAC,CAAD,CAAX,IAAkB,GAAtB,EAA2B;AACzBjxB,YAAAA,IAAI,IAAIyG,MAAR;AACD,WAFD,MAEO;AACLzG,YAAAA,IAAI,IAAIyG,MAAR;AACD;AACF;;AACD,eAAOzG,IAAP;AACD,OApI6B;AAqI9BywB,MAAAA,iBAAiB,EAAE,UAASL,WAAT,EAAsBC,MAAtB,EAA8B9jB,OAA9B,EAAuC;AACxD,YAAI6jB,WAAW,CAAC/D,GAAZ,EAAJ,EAAuB;AACrB;AACD;;AACDgE,QAAAA,MAAM,CAACpF,SAAP,GAAmBmF,WAAW,CAACrjB,KAAZ,CAAkB,IAAlB,EAAwB,CAAxB,CAAnB,CAJwD,CAKxD;;AACA,YAAImkB,KAAK,GAAG3kB,OAAO,CAAC4kB,YAAR,IAAwB,KAApC;AACA,YAAIpU,IAAI,GAAG6H,IAAI,CAACyL,MAAM,CAACpF,SAAR,CAAJ,CAAuBjpB,KAAvB,CAA6BkvB,KAA7B,CAAX;;AACA,YAAInU,IAAI,CAACjgB,MAAL,IAAeigB,IAAI,CAAC,CAAD,CAAvB,EAA4B;AAC1BsT,UAAAA,MAAM,CAACtT,IAAP,GAAcA,IAAd;AACD;AACF,OAhJ6B;AAiJ9ByT,MAAAA,aAAa,EAAE,UAASD,WAAT,EAAsB;AACnC;AACA;AACA;AACA;AACA,aAAK,IAAI7wB,CAAC,GAAG6wB,WAAW,CAACzzB,MAAzB,EAAiC4C,CAAC,GAAG,CAArC,EAAwCA,CAAC,EAAzC,EAA6C;AAC3C,cAAIuM,MAAM,GAAGskB,WAAW,CAACtjB,SAAZ,CAAsB,CAAtB,EAAyBvN,CAAzB,CAAb;;AACA,cAAI,KAAK0M,WAAL,CAAiBH,MAAjB,CAAJ,EAA8B;AAC5B,gBAAIM,OAAO,GAAG,KAAKH,WAAL,CAAiBH,MAAjB,CAAd;;AACA,gBAAIM,OAAO,CAACvP,IAAR,CAAasH,OAAb,CAAqBisB,WAArB,MAAsC,CAA1C,EAA6C;AAC3C,qBAAOhkB,OAAP;AACD;AACF;AACF;;AACD,eAAO,IAAP;AACD,OAhK6B;AAiK9BujB,MAAAA,gBAAgB,EAAE,YAAW;AAC3B,aAAK1jB,WAAL,GAAmB,EAAnB;;AACA,aAAK,IAAI1M,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG3C,mBAAmB,CAACD,MAAxC,EAAgD4C,CAAC,EAAjD,EAAqD;AACnD,cAAI6M,OAAO,GAAGxP,mBAAmB,CAAC2C,CAAD,CAAjC;AACA,cAAIkB,GAAG,GAAG2L,OAAO,CAACtP,SAAR,IAAqBsP,OAAO,CAACvP,IAAvC;AACA,eAAKoP,WAAL,CAAiBxL,GAAjB,IAAwB2L,OAAxB;AACD;AACF,OAxK6B;AAyK9B9B,MAAAA,GAAG,EAAE,UAASC,GAAT,EAAcC,GAAd,EAAmBC,GAAnB,EAAwB;AAC3B,YAAIF,GAAG,IAAI,GAAP,IAAcA,GAAG,CAAC5I,MAAJ,CAAW,CAAX,KAAiB,GAAnC,EAAwC;AACtC,cAAI8I,GAAJ,EAAS;AAAE,kBAAM5F,KAAK,CAAC,oCAAD,CAAX;AAAoD;;AAC/D,cAAIurB,WAAW,GAAG7lB,GAAG,CAACuC,SAAJ,CAAc,CAAd,CAAlB;;AACA,cAAItC,GAAG,IAAI,GAAP,IAAcA,GAAG,CAAC7I,MAAJ,CAAW,CAAX,KAAiB,GAAnC,EAAwC;AACtC;AACA,iBAAKsK,WAAL,CAAiBmkB,WAAjB,IAAgC;AAC9BvzB,cAAAA,IAAI,EAAEuzB,WADwB;AAE9Bn2B,cAAAA,IAAI,EAAE,QAFwB;AAG9Bs2B,cAAAA,OAAO,EAAE/lB,GAAG,CAACsC,SAAJ,CAAc,CAAd,CAHqB;AAI9BmkB,cAAAA,IAAI,EAAE;AAJwB,aAAhC;AAMD,WARD,MAQO;AACL;AACA,iBAAKhlB,WAAL,CAAiBmkB,WAAjB,IAAgC;AAC9BvzB,cAAAA,IAAI,EAAEuzB,WADwB;AAE9Bn2B,cAAAA,IAAI,EAAE,SAFwB;AAG9BC,cAAAA,MAAM,EAAEsQ,GAHsB;AAI9BymB,cAAAA,IAAI,EAAE;AAJwB,aAAhC;AAMD;AACF,SApBD,MAoBO;AACL,cAAIzmB,GAAG,IAAI,GAAP,IAAcA,GAAG,CAAC7I,MAAJ,CAAW,CAAX,KAAiB,GAAnC,EAAwC;AACtC;AACA,gBAAIsJ,OAAO,GAAG;AACZjR,cAAAA,IAAI,EAAEuQ,GADM;AAEZtQ,cAAAA,IAAI,EAAE,SAFM;AAGZ6a,cAAAA,MAAM,EAAE;AAAErG,gBAAAA,KAAK,EAAEjE,GAAG,CAACsC,SAAJ,CAAc,CAAd;AAAT;AAHI,aAAd;;AAKA,gBAAIrC,GAAJ,EAAS;AAAEQ,cAAAA,OAAO,CAAC9Q,OAAR,GAAkBsQ,GAAlB;AAAwB;;AACnC1Q,YAAAA,aAAa,CAACm3B,OAAd,CAAsBjmB,OAAtB;AACD,WATD,MASO;AACL;AACA,gBAAIA,OAAO,GAAG;AACZjR,cAAAA,IAAI,EAAEuQ,GADM;AAEZtQ,cAAAA,IAAI,EAAE,UAFM;AAGZC,cAAAA,MAAM,EAAEsQ;AAHI,aAAd;;AAKA,gBAAIC,GAAJ,EAAS;AAAEQ,cAAAA,OAAO,CAAC9Q,OAAR,GAAkBsQ,GAAlB;AAAwB;;AACnC1Q,YAAAA,aAAa,CAACm3B,OAAd,CAAsBjmB,OAAtB;AACD;AACF;AACF,OAnN6B;AAoN9BN,MAAAA,KAAK,EAAE,UAASJ,GAAT,EAAcE,GAAd,EAAmB;AACxB,YAAIF,GAAG,IAAI,GAAP,IAAcA,GAAG,CAAC5I,MAAJ,CAAW,CAAX,KAAiB,GAAnC,EAAwC;AACtC;AACA,cAAI8I,GAAJ,EAAS;AAAE,kBAAM5F,KAAK,CAAC,oCAAD,CAAX;AAAoD;;AAC/D,cAAIurB,WAAW,GAAG7lB,GAAG,CAACuC,SAAJ,CAAc,CAAd,CAAlB;;AACA,cAAI,KAAKb,WAAL,CAAiBmkB,WAAjB,KAAiC,KAAKnkB,WAAL,CAAiBmkB,WAAjB,EAA8Ba,IAAnE,EAAyE;AACvE,mBAAO,KAAKhlB,WAAL,CAAiBmkB,WAAjB,CAAP;AACA;AACD;AACF,SARD,MAQO;AACL;AACA,cAAIp2B,IAAI,GAAGuQ,GAAX;;AACA,eAAK,IAAIhL,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGxF,aAAa,CAAC4C,MAAlC,EAA0C4C,CAAC,EAA3C,EAA+C;AAC7C,gBAAIvF,IAAI,IAAID,aAAa,CAACwF,CAAD,CAAb,CAAiBvF,IAAzB,IACGD,aAAa,CAACwF,CAAD,CAAb,CAAiBpF,OAAjB,KAA6BsQ,GADpC,EACyC;AACvC1Q,cAAAA,aAAa,CAAC8W,MAAd,CAAqBtR,CAArB,EAAwB,CAAxB;AACA;AACD;AACF;AACF;;AACD,cAAMsF,KAAK,CAAC,kBAAD,CAAX;AACD;AAzO6B,KAAhC;AA4OA,QAAImH,UAAU,GAAG;AACfmlB,MAAAA,WAAW,EAAE,UAAS/zB,EAAT,EAAa8yB,MAAb,EAAqB;AAChC,YAAI,CAACA,MAAM,CAACtT,IAAR,IAAgBsT,MAAM,CAACtT,IAAP,CAAYjgB,MAAZ,GAAqB,CAAzC,EAA4C;AAC1CmW,UAAAA,WAAW,CAAC1V,EAAD,EAAKA,EAAE,CAACkB,SAAH,CAAa,OAAb,CAAL,CAAX;AACA;AACD;;AACDlB,QAAAA,EAAE,CAACC,SAAH,CAAa,OAAb,EAAsB6yB,MAAM,CAACtT,IAAP,CAAY,CAAZ,CAAtB;AACD,OAPc;AAQftS,MAAAA,GAAG,EAAE,UAASlN,EAAT,EAAa8yB,MAAb,EAAqBzlB,GAArB,EAA0B;AAC7B,YAAI2mB,OAAO,GAAGlB,MAAM,CAACtT,IAArB;;AACA,YAAI,CAACwU,OAAD,IAAYA,OAAO,CAACz0B,MAAR,GAAiB,CAAjC,EAAoC;AAClC,cAAIS,EAAJ,EAAQ;AACN0V,YAAAA,WAAW,CAAC1V,EAAD,EAAK,sBAAsB8yB,MAAM,CAACzhB,KAAlC,CAAX;AACD;;AACD;AACD;;AACD/D,QAAAA,mBAAmB,CAACJ,GAApB,CAAwB8mB,OAAO,CAAC,CAAD,CAA/B,EAAoCA,OAAO,CAAC,CAAD,CAA3C,EAAgD3mB,GAAhD;AACD,OAjBc;AAkBf4mB,MAAAA,IAAI,EAAE,UAASj0B,EAAT,EAAa8yB,MAAb,EAAqB;AAAE,aAAK5lB,GAAL,CAASlN,EAAT,EAAa8yB,MAAb,EAAqB,QAArB;AAAiC,OAlB/C;AAmBfoB,MAAAA,IAAI,EAAE,UAASl0B,EAAT,EAAa8yB,MAAb,EAAqB;AAAE,aAAK5lB,GAAL,CAASlN,EAAT,EAAa8yB,MAAb,EAAqB,QAArB;AAAiC,OAnB/C;AAoBfqB,MAAAA,IAAI,EAAE,UAASn0B,EAAT,EAAa8yB,MAAb,EAAqB;AAAE,aAAK5lB,GAAL,CAASlN,EAAT,EAAa8yB,MAAb,EAAqB,QAArB;AAAiC,OApB/C;AAqBfvlB,MAAAA,KAAK,EAAE,UAASvN,EAAT,EAAa8yB,MAAb,EAAqBzlB,GAArB,EAA0B;AAC/B,YAAI2mB,OAAO,GAAGlB,MAAM,CAACtT,IAArB;;AACA,YAAI,CAACwU,OAAD,IAAYA,OAAO,CAACz0B,MAAR,GAAiB,CAAjC,EAAoC;AAClC,cAAIS,EAAJ,EAAQ;AACN0V,YAAAA,WAAW,CAAC1V,EAAD,EAAK,sBAAsB8yB,MAAM,CAACzhB,KAAlC,CAAX;AACD;;AACD;AACD;;AACD/D,QAAAA,mBAAmB,CAACC,KAApB,CAA0BymB,OAAO,CAAC,CAAD,CAAjC,EAAsC3mB,GAAtC;AACD,OA9Bc;AA+BfpE,MAAAA,IAAI,EAAE,UAASjJ,EAAT,EAAa8yB,MAAb,EAAqB;AACzB/iB,QAAAA,iBAAiB,CAACkB,cAAlB,CAAiCjR,EAAjC,EAAqCA,EAAE,CAACW,KAAH,CAASC,GAA9C,EAAmD;AAC/C/D,UAAAA,IAAI,EAAE,QADyC;AAE/CI,UAAAA,MAAM,EAAE,4BAFuC;AAG/CC,UAAAA,UAAU,EAAE;AAAEG,YAAAA,OAAO,EAAE,KAAX;AAAkBI,YAAAA,cAAc,EAAE,IAAlC;AACVN,YAAAA,QAAQ,EAAE;AADA,WAHmC;AAK/C+W,UAAAA,cAAc,EAAE4e,MAAM,CAACrwB,IAAP,GAAY;AALmB,SAAnD;AAMD,OAtCc;AAuCf2xB,MAAAA,GAAG,EAAE,UAASp0B,EAAT,EAAa8yB,MAAb,EAAqB;AACxB,YAAIuB,OAAO,GAAGvB,MAAM,CAACtT,IAArB,CADwB,CAExB;AACA;;AACA,YAAI8U,MAAM,GAAGxB,MAAM,CAACwB,MAAP,IAAiB,EAA9B;;AACA,YAAI,CAACD,OAAD,IAAYA,OAAO,CAAC90B,MAAR,GAAiB,CAAjC,EAAoC;AAClC,cAAIS,EAAJ,EAAQ;AACN0V,YAAAA,WAAW,CAAC1V,EAAD,EAAK,sBAAsB8yB,MAAM,CAACzhB,KAAlC,CAAX;AACD;;AACD;AACD;;AACD,YAAIkjB,IAAI,GAAGF,OAAO,CAAC,CAAD,CAAP,CAAW5vB,KAAX,CAAiB,GAAjB,CAAX;AACA,YAAI+H,UAAU,GAAG+nB,IAAI,CAAC,CAAD,CAArB;AACA,YAAI7sB,KAAK,GAAG6sB,IAAI,CAAC,CAAD,CAAhB;AACA,YAAIC,QAAQ,GAAG,KAAf;;AAEA,YAAIhoB,UAAU,CAACjI,MAAX,CAAkBiI,UAAU,CAACjN,MAAX,GAAoB,CAAtC,KAA4C,GAAhD,EAAqD;AACnD;AACA,cAAImI,KAAJ,EAAW;AAAE,kBAAMD,KAAK,CAAC,0BAA0BqrB,MAAM,CAACpF,SAAlC,CAAX;AAA0D;;AACvElhB,UAAAA,UAAU,GAAGA,UAAU,CAACkD,SAAX,CAAqB,CAArB,EAAwBlD,UAAU,CAACjN,MAAX,GAAoB,CAA5C,CAAb;AACAi1B,UAAAA,QAAQ,GAAG,IAAX;AACD;;AACD,YAAI9sB,KAAK,KAAKpE,SAAV,IAAuBkJ,UAAU,CAACkD,SAAX,CAAqB,CAArB,EAAwB,CAAxB,KAA8B,IAAzD,EAA+D;AAC7D;AACA;AACAlD,UAAAA,UAAU,GAAGA,UAAU,CAACkD,SAAX,CAAqB,CAArB,CAAb;AACAhI,UAAAA,KAAK,GAAG,KAAR;AACD;;AAED,YAAI+sB,eAAe,GAAGptB,OAAO,CAACmF,UAAD,CAAP,IAAuBnF,OAAO,CAACmF,UAAD,CAAP,CAAoB3P,IAApB,IAA4B,SAAzE;;AACA,YAAI43B,eAAe,IAAI/sB,KAAK,IAAIpE,SAAhC,EAA2C;AACzC;AACAoE,UAAAA,KAAK,GAAG,IAAR;AACD,SAjCuB,CAkCxB;;;AACA,YAAI,CAAC+sB,eAAD,IAAoB/sB,KAAK,KAAKpE,SAA9B,IAA2CkxB,QAA/C,EAAyD;AACvD,cAAIE,QAAQ,GAAGxzB,SAAS,CAACsL,UAAD,EAAaxM,EAAb,EAAiBs0B,MAAjB,CAAxB;;AACA,cAAII,QAAQ,YAAYjtB,KAAxB,EAA+B;AAC7BiO,YAAAA,WAAW,CAAC1V,EAAD,EAAK00B,QAAQ,CAACC,OAAd,CAAX;AACD,WAFD,MAEO,IAAID,QAAQ,KAAK,IAAb,IAAqBA,QAAQ,KAAK,KAAtC,EAA6C;AAClDhf,YAAAA,WAAW,CAAC1V,EAAD,EAAK,OAAO00B,QAAQ,GAAG,EAAH,GAAQ,IAAvB,IAA+BloB,UAApC,CAAX;AACD,WAFM,MAEA;AACLkJ,YAAAA,WAAW,CAAC1V,EAAD,EAAK,OAAOwM,UAAP,GAAoB,GAApB,GAA0BkoB,QAA/B,CAAX;AACD;AACF,SATD,MASO;AACL,cAAIE,eAAe,GAAG30B,SAAS,CAACuM,UAAD,EAAa9E,KAAb,EAAoB1H,EAApB,EAAwBs0B,MAAxB,CAA/B;;AACA,cAAIM,eAAe,YAAYntB,KAA/B,EAAsC;AACpCiO,YAAAA,WAAW,CAAC1V,EAAD,EAAK40B,eAAe,CAACD,OAArB,CAAX;AACD;AACF;AACF,OAzFc;AA0FfE,MAAAA,QAAQ,EAAE,UAAU70B,EAAV,EAAc8yB,MAAd,EAAsB;AAC9B;AACAA,QAAAA,MAAM,CAACwB,MAAP,GAAgB;AAACzsB,UAAAA,KAAK,EAAE;AAAR,SAAhB;AACA,aAAKusB,GAAL,CAASp0B,EAAT,EAAa8yB,MAAb;AACD,OA9Fc;AA+FfgC,MAAAA,SAAS,EAAE,UAAU90B,EAAV,EAAc8yB,MAAd,EAAsB;AAC/B;AACAA,QAAAA,MAAM,CAACwB,MAAP,GAAgB;AAACzsB,UAAAA,KAAK,EAAE;AAAR,SAAhB;AACA,aAAKusB,GAAL,CAASp0B,EAAT,EAAa8yB,MAAb;AACD,OAnGc;AAoGflgB,MAAAA,SAAS,EAAE,UAAS5S,EAAT,EAAa8yB,MAAb,EAAqB;AAC9B,YAAIiC,OAAO,GAAGjC,MAAM,CAACtT,IAArB;AACA,YAAI5M,SAAS,GAAGvI,cAAc,CAACI,kBAAf,CAAkCmI,SAAlD;AACA,YAAIoiB,OAAO,GAAG,mCAAd;;AACA,YAAI,CAACD,OAAL,EAAc;AACZ,eAAK,IAAIxqB,YAAT,IAAyBqI,SAAzB,EAAoC;AAClC,gBAAIT,IAAI,GAAGS,SAAS,CAACrI,YAAD,CAAT,CAAwBoI,QAAxB,EAAX;;AACA,gBAAIR,IAAI,CAAC5S,MAAT,EAAiB;AACfy1B,cAAAA,OAAO,IAAI,MAAMzqB,YAAN,GAAqB,MAArB,GAA8B4H,IAA9B,GAAqC,IAAhD;AACD;AACF;AACF,SAPD,MAOO;AACL,cAAI5H,YAAJ;AACAwqB,UAAAA,OAAO,GAAGA,OAAO,CAAChwB,IAAR,CAAa,EAAb,CAAV;;AACA,eAAK,IAAI5C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG4yB,OAAO,CAACx1B,MAA5B,EAAoC4C,CAAC,EAArC,EAAyC;AACvCoI,YAAAA,YAAY,GAAGwqB,OAAO,CAACxwB,MAAR,CAAepC,CAAf,CAAf;;AACA,gBAAI,CAACkI,cAAc,CAACI,kBAAf,CAAkCqI,eAAlC,CAAkDvI,YAAlD,CAAL,EAAsE;AACpE;AACD;;AACD,gBAAIC,QAAQ,GAAGoI,SAAS,CAACrI,YAAD,CAAT,IAA2B,IAAI2H,QAAJ,EAA1C;AACA8iB,YAAAA,OAAO,IAAI,MAAMzqB,YAAN,GAAqB,MAArB,GAA8BC,QAAQ,CAACmI,QAAT,EAA9B,GAAoD,IAA/D;AACD;AACF;;AACD+C,QAAAA,WAAW,CAAC1V,EAAD,EAAKg1B,OAAL,CAAX;AACD,OA5Hc;AA6HfC,MAAAA,IAAI,EAAE,UAASj1B,EAAT,EAAa8yB,MAAb,EAAqB;AACzB,YAAIzG,OAAJ,EAAa9W,UAAb,EAAyB2f,MAAzB,EAAiCrP,MAAjC,EAAyCsP,OAAzC;;AACA,iBAASC,SAAT,GAAqB;AACnB,cAAItC,MAAM,CAACpF,SAAX,EAAsB;AACpB,gBAAIlO,IAAI,GAAG,IAAI9iB,UAAU,CAACkyB,YAAf,CAA4BkE,MAAM,CAACpF,SAAnC,CAAX;;AACA,gBAAIlO,IAAI,CAAC6T,GAAL,CAAS,GAAT,CAAJ,EAAmB;AAAEhH,cAAAA,OAAO,GAAG,IAAV;AAAiB;;AACtC,gBAAI7M,IAAI,CAACsP,GAAL,EAAJ,EAAgB;AAAE;AAAS;;AAC3B,gBAAI,CAACtP,IAAI,CAAC6V,QAAL,EAAL,EAAsB;AAAE,qBAAO,mBAAP;AAA6B;;AACrD,gBAAIC,IAAI,GAAG9V,IAAI,CAAChQ,KAAL,CAAW,6BAAX,CAAX;;AACA,gBAAI,CAAC8lB,IAAD,IAAS,CAAC9V,IAAI,CAACsP,GAAL,EAAd,EAA0B;AAAE,qBAAO,mBAAP;AAA6B;;AACzD,gBAAIwG,IAAI,CAAC,CAAD,CAAR,EAAa;AACX/f,cAAAA,UAAU,GAAG+f,IAAI,CAAC,CAAD,CAAJ,CAAQvuB,OAAR,CAAgB,GAAhB,KAAwB,CAAC,CAAtC;AACAmuB,cAAAA,MAAM,GAAGI,IAAI,CAAC,CAAD,CAAJ,CAAQvuB,OAAR,CAAgB,GAAhB,KAAwB,CAAC,CAAlC;AACA,kBAAIwuB,OAAO,GAAGD,IAAI,CAAC,CAAD,CAAJ,CAAQvuB,OAAR,CAAgB,GAAhB,KAAwB,CAAC,CAAzB,IAA8BuuB,IAAI,CAAC,CAAD,CAAJ,CAAQvuB,OAAR,CAAgB,GAAhB,KAAwB,CAAC,CAAzB,IAA8B,CAA1E;AACA,kBAAIyuB,GAAG,GAAGF,IAAI,CAAC,CAAD,CAAJ,CAAQvuB,OAAR,CAAgB,GAAhB,KAAwB,CAAC,CAAzB,IAA8B,CAAxC;AACA,kBAAI0uB,KAAK,GAAGH,IAAI,CAAC,CAAD,CAAJ,CAAQvuB,OAAR,CAAgB,GAAhB,KAAwB,CAAC,CAAzB,IAA8B,CAA1C;;AACA,kBAAIwuB,OAAO,GAAGC,GAAV,GAAgBC,KAAhB,GAAwB,CAA5B,EAA+B;AAAE,uBAAO,mBAAP;AAA6B;;AAC9D5P,cAAAA,MAAM,GAAG0P,OAAO,IAAI,SAAX,IAAwBC,GAAG,IAAI,KAA/B,IAAwCC,KAAK,IAAI,OAA1D;AACD;;AACD,gBAAIH,IAAI,CAAC,CAAD,CAAR,EAAa;AACXH,cAAAA,OAAO,GAAG,IAAI5uB,MAAJ,CAAW+uB,IAAI,CAAC,CAAD,CAAJ,CAAQxnB,MAAR,CAAe,CAAf,EAAkBwnB,IAAI,CAAC,CAAD,CAAJ,CAAQ/1B,MAAR,GAAiB,CAAnC,CAAX,EAAkDgW,UAAU,GAAG,GAAH,GAAS,EAArE,CAAV;AACD;AACF;AACF;;AACD,YAAImgB,GAAG,GAAGN,SAAS,EAAnB;;AACA,YAAIM,GAAJ,EAAS;AACPhgB,UAAAA,WAAW,CAAC1V,EAAD,EAAK01B,GAAG,GAAG,IAAN,GAAa5C,MAAM,CAACpF,SAAzB,CAAX;AACA;AACD;;AACD,YAAIiI,SAAS,GAAG7C,MAAM,CAACrwB,IAAP,IAAezC,EAAE,CAAC0G,SAAH,EAA/B;AACA,YAAI4sB,OAAO,GAAGR,MAAM,CAACQ,OAAP,IAAkBR,MAAM,CAACrwB,IAAzB,IAAiCzC,EAAE,CAAC2G,QAAH,EAA/C;;AACA,YAAIgvB,SAAS,IAAIrC,OAAjB,EAA0B;AAAE;AAAS;;AACrC,YAAIva,QAAQ,GAAGlZ,GAAG,CAAC81B,SAAD,EAAY,CAAZ,CAAlB;AACA,YAAI3c,MAAM,GAAGnZ,GAAG,CAACyzB,OAAD,EAAUhxB,UAAU,CAACtC,EAAD,EAAKszB,OAAL,CAApB,CAAhB;AACA,YAAInhB,IAAI,GAAGnS,EAAE,CAAC0f,QAAH,CAAY3G,QAAZ,EAAsBC,MAAtB,EAA8BvU,KAA9B,CAAoC,IAApC,CAAX;AACA,YAAIc,WAAW,GAAG4vB,OAAO,GAAGA,OAAH,GACrBtP,MAAM,IAAI,SAAX,GAAwB,aAAxB,GACCA,MAAM,IAAI,KAAX,GAAoB,yBAApB,GACCA,MAAM,IAAI,OAAX,GAAsB,UAAtB,GAAmC,IAHtC;AAIA,YAAI+P,KAAK,GAAI/P,MAAM,IAAI,SAAX,GAAwB,EAAxB,GAA8BA,MAAM,IAAI,KAAX,GAAoB,EAApB,GAA0BA,MAAM,IAAI,OAAX,GAAsB,CAAtB,GAA0B,IAA5F;AACA,YAAIgQ,OAAO,GAAG,EAAd;AAAA,YAAkBC,QAAQ,GAAG,EAA7B;;AACA,YAAIjQ,MAAM,IAAIsP,OAAd,EAAuB;AACrB,eAAK,IAAIhzB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGgQ,IAAI,CAAC5S,MAAzB,EAAiC4C,CAAC,EAAlC,EAAsC;AACpC,gBAAI4zB,SAAS,GAAGZ,OAAO,GAAGhjB,IAAI,CAAChQ,CAAD,CAAJ,CAAQqN,KAAR,CAAc2lB,OAAd,CAAH,GAA4B,IAAnD;;AACA,gBAAIY,SAAS,IAAIA,SAAS,CAAC,CAAD,CAAT,IAAgB,EAAjC,EAAqC;AACnCF,cAAAA,OAAO,CAAClzB,IAAR,CAAaozB,SAAb;AACD,aAFD,MAEO,IAAI,CAACZ,OAAD,IAAY5vB,WAAW,CAACkK,IAAZ,CAAiB0C,IAAI,CAAChQ,CAAD,CAArB,CAAhB,EAA2C;AAChD0zB,cAAAA,OAAO,CAAClzB,IAAR,CAAawP,IAAI,CAAChQ,CAAD,CAAjB;AACD,aAFM,MAEA;AACL2zB,cAAAA,QAAQ,CAACnzB,IAAT,CAAcwP,IAAI,CAAChQ,CAAD,CAAlB;AACD;AACF;AACF,SAXD,MAWO;AACL2zB,UAAAA,QAAQ,GAAG3jB,IAAX;AACD;;AACD,iBAAS6jB,SAAT,CAAmBvG,CAAnB,EAAsBwG,CAAtB,EAAyB;AACvB,cAAI5J,OAAJ,EAAa;AAAE,gBAAIhT,GAAJ;AAASA,YAAAA,GAAG,GAAGoW,CAAN;AAASA,YAAAA,CAAC,GAAGwG,CAAJ;AAAOA,YAAAA,CAAC,GAAG5c,GAAJ;AAAU;;AAClD,cAAI9D,UAAJ,EAAgB;AAAEka,YAAAA,CAAC,GAAGA,CAAC,CAAC3qB,WAAF,EAAJ;AAAqBmxB,YAAAA,CAAC,GAAGA,CAAC,CAACnxB,WAAF,EAAJ;AAAsB;;AAC7D,cAAIoxB,IAAI,GAAGrQ,MAAM,IAAItgB,WAAW,CAACkK,IAAZ,CAAiBggB,CAAjB,CAArB;AACA,cAAI0G,IAAI,GAAGtQ,MAAM,IAAItgB,WAAW,CAACkK,IAAZ,CAAiBwmB,CAAjB,CAArB;;AACA,cAAI,CAACC,IAAL,EAAW;AAAE,mBAAOzG,CAAC,GAAGwG,CAAJ,GAAQ,CAAC,CAAT,GAAa,CAApB;AAAwB;;AACrCC,UAAAA,IAAI,GAAGlkB,QAAQ,CAAC,CAACkkB,IAAI,CAAC,CAAD,CAAJ,GAAUA,IAAI,CAAC,CAAD,CAAf,EAAoBpxB,WAApB,EAAD,EAAoC8wB,KAApC,CAAf;AACAO,UAAAA,IAAI,GAAGnkB,QAAQ,CAAC,CAACmkB,IAAI,CAAC,CAAD,CAAJ,GAAUA,IAAI,CAAC,CAAD,CAAf,EAAoBrxB,WAApB,EAAD,EAAoC8wB,KAApC,CAAf;AACA,iBAAOM,IAAI,GAAGC,IAAd;AACD;;AACD,iBAASC,gBAAT,CAA0B3G,CAA1B,EAA6BwG,CAA7B,EAAgC;AAC9B,cAAI5J,OAAJ,EAAa;AAAE,gBAAIhT,GAAJ;AAASA,YAAAA,GAAG,GAAGoW,CAAN;AAASA,YAAAA,CAAC,GAAGwG,CAAJ;AAAOA,YAAAA,CAAC,GAAG5c,GAAJ;AAAU;;AAClD,cAAI9D,UAAJ,EAAgB;AAAEka,YAAAA,CAAC,CAAC,CAAD,CAAD,GAAOA,CAAC,CAAC,CAAD,CAAD,CAAK3qB,WAAL,EAAP;AAA2BmxB,YAAAA,CAAC,CAAC,CAAD,CAAD,GAAOA,CAAC,CAAC,CAAD,CAAD,CAAKnxB,WAAL,EAAP;AAA4B;;AACzE,iBAAQ2qB,CAAC,CAAC,CAAD,CAAD,GAAOwG,CAAC,CAAC,CAAD,CAAT,GAAgB,CAAC,CAAjB,GAAqB,CAA5B;AACD;;AACDJ,QAAAA,OAAO,CAACZ,IAAR,CAAaE,OAAO,GAAGiB,gBAAH,GAAsBJ,SAA1C;;AACA,YAAIb,OAAJ,EAAa;AACX,eAAK,IAAIhzB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG0zB,OAAO,CAACt2B,MAA5B,EAAoC4C,CAAC,EAArC,EAAyC;AACvC0zB,YAAAA,OAAO,CAAC1zB,CAAD,CAAP,GAAa0zB,OAAO,CAAC1zB,CAAD,CAAP,CAAWkP,KAAxB;AACD;AACF,SAJD,MAIO,IAAI,CAACwU,MAAL,EAAa;AAAEiQ,UAAAA,QAAQ,CAACb,IAAT,CAAce,SAAd;AAA2B;;AACjD7jB,QAAAA,IAAI,GAAI,CAACka,OAAF,GAAayJ,QAAQ,CAAC1vB,MAAT,CAAgByvB,OAAhB,CAAb,GAAwCA,OAAO,CAACzvB,MAAR,CAAe0vB,QAAf,CAA/C;;AACA,YAAIZ,MAAJ,EAAY;AAAE;AACZ,cAAImB,OAAO,GAAGlkB,IAAd;AACA,cAAIxL,QAAJ;AACAwL,UAAAA,IAAI,GAAG,EAAP;;AACA,eAAK,IAAIhQ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGk0B,OAAO,CAAC92B,MAA5B,EAAoC4C,CAAC,EAArC,EAAyC;AACvC,gBAAIk0B,OAAO,CAACl0B,CAAD,CAAP,IAAcwE,QAAlB,EAA4B;AAC1BwL,cAAAA,IAAI,CAACxP,IAAL,CAAU0zB,OAAO,CAACl0B,CAAD,CAAjB;AACD;;AACDwE,YAAAA,QAAQ,GAAG0vB,OAAO,CAACl0B,CAAD,CAAlB;AACD;AACF;;AACDnC,QAAAA,EAAE,CAACuQ,YAAH,CAAgB4B,IAAI,CAACpN,IAAL,CAAU,IAAV,CAAhB,EAAiCgU,QAAjC,EAA2CC,MAA3C;AACD,OAtNc;AAuNfsd,MAAAA,OAAO,EAAE,UAASt2B,EAAT,EAAa8yB,MAAb,EAAqB;AAC5B;AACA,aAAKyD,MAAL,CAAYv2B,EAAZ,EAAgB8yB,MAAhB;AACD,OA1Nc;AA2NfyD,MAAAA,MAAM,EAAE,UAASv2B,EAAT,EAAa8yB,MAAb,EAAqB;AAC3B;AACA;AACA;AACA,YAAIpF,SAAS,GAAGoF,MAAM,CAACpF,SAAvB;;AACA,YAAI,CAACA,SAAL,EAAgB;AACdhY,UAAAA,WAAW,CAAC1V,EAAD,EAAK,wCAAL,CAAX;AACA;AACD;;AACD,YAAIw2B,QAAQ,GAAG1D,MAAM,CAACE,WAAP,CAAmB,CAAnB,MAA0B,GAAzC,CAT2B,CAU3B;;AACA,YAAI2C,SAAS,GAAI7C,MAAM,CAACrwB,IAAP,KAAgBa,SAAjB,GAA8BwvB,MAAM,CAACrwB,IAArC,GAA4CzC,EAAE,CAAC0G,SAAH,EAA5D;AACA,YAAI4sB,OAAO,GAAGR,MAAM,CAACQ,OAAP,IAAkBR,MAAM,CAACrwB,IAAzB,IAAiCzC,EAAE,CAAC2G,QAAH,EAA/C,CAZ2B,CAa3B;;AACA,YAAIqnB,MAAM,GAAGP,YAAY,CAACC,SAAD,CAAzB;AACA,YAAIyB,SAAS,GAAGzB,SAAhB;AAAA,YAA2BjqB,GAA3B;;AACA,YAAIuqB,MAAM,CAACzuB,MAAX,EAAmB;AACjB4vB,UAAAA,SAAS,GAAGnB,MAAM,CAAC,CAAD,CAAlB;AACAvqB,UAAAA,GAAG,GAAGuqB,MAAM,CAAC1f,KAAP,CAAa,CAAb,EAAgB0f,MAAM,CAACzuB,MAAvB,EAA+BwF,IAA/B,CAAoC,GAApC,CAAN;AACD;;AACD,YAAIoqB,SAAJ,EAAe;AACb;AACA;AACA,cAAI;AACH1Z,YAAAA,iBAAiB,CAACzV,EAAD,EAAKmvB,SAAL,EAAgB;AAAK;AAArB,cACf;AAAK;AADU,aAAjB;AAEA,WAHD,CAGE,OAAOje,CAAP,EAAU;AACXwE,YAAAA,WAAW,CAAC1V,EAAD,EAAK,oBAAoBmvB,SAAzB,CAAX;AACA;AACA;AACF,SA9B0B,CA+B3B;AACA;;;AACA,YAAIzc,KAAK,GAAGqC,cAAc,CAAC/U,EAAD,CAAd,CAAmBmV,QAAnB,EAAZ;AACA,YAAIshB,YAAY,GAAG,EAAnB;;AACA,aAAK,IAAIt0B,CAAC,GAAGwzB,SAAb,EAAwBxzB,CAAC,IAAImxB,OAA7B,EAAsCnxB,CAAC,EAAvC,EAA2C;AACzC,cAAIM,IAAI,GAAGzC,EAAE,CAAC02B,aAAH,CAAiBv0B,CAAjB,CAAX;AACA,cAAIkc,OAAO,GAAG3L,KAAK,CAACvP,IAAN,CAAWV,IAAI,CAAC0P,IAAhB,CAAd;;AACA,cAAIkM,OAAO,KAAKmY,QAAhB,EAA0B;AACxBC,YAAAA,YAAY,CAAC9zB,IAAb,CAAkBc,GAAG,GAAGhB,IAAH,GAAUA,IAAI,CAAC0P,IAApC;AACD;AACF,SAzC0B,CA0C3B;;;AACA,YAAI,CAAC1O,GAAL,EAAU;AACRiS,UAAAA,WAAW,CAAC1V,EAAD,EAAKy2B,YAAY,CAAC1xB,IAAb,CAAkB,IAAlB,CAAL,CAAX;AACA;AACD;;AACD,YAAI4K,KAAK,GAAG,CAAZ;;AACA,YAAIgnB,WAAW,GAAG,YAAW;AAC3B,cAAIhnB,KAAK,GAAG8mB,YAAY,CAACl3B,MAAzB,EAAiC;AAC/B,gBAAIkD,IAAI,GAAGg0B,YAAY,CAAC9mB,KAAK,EAAN,CAAvB;AACA,gBAAI8O,OAAO,GAAGze,EAAE,CAAC42B,aAAH,CAAiBn0B,IAAjB,CAAd;;AACA,gBAAIgc,OAAO,IAAI,IAAf,EAAqB;AACnBkY,cAAAA,WAAW;AACX;AACD;;AACD,gBAAI3nB,OAAO,GAAIyP,OAAO,GAAG,CAAX,GAAgBhb,GAA9B;AACA6J,YAAAA,mBAAmB,CAAC2D,cAApB,CAAmCjR,EAAnC,EAAuCgP,OAAvC,EAAgD;AAC9CxH,cAAAA,QAAQ,EAAEmvB;AADoC,aAAhD;AAGD;AACF,SAbD;;AAcAA,QAAAA,WAAW;AACZ,OA1Rc;AA2RfE,MAAAA,UAAU,EAAE,UAAS72B,EAAT,EAAa8yB,MAAb,EAAqB;AAC/B,YAAI,CAAC9yB,EAAE,CAAC8U,eAAR,EAAyB;AACvB,gBAAM,IAAIrN,KAAJ,CAAU,+DACZ,2CADE,CAAN;AAED;;AACD,YAAIimB,SAAS,GAAGoF,MAAM,CAACpF,SAAvB;AACA,YAAIM,MAAM,GAAGN,SAAS,GAAGC,gBAAgB,CAACD,SAAD,EAAYA,SAAS,CAAC,CAAD,CAArB,CAAnB,GAA+C,EAArE;AACA,YAAIyB,SAAJ;AAAA,YAAe2H,WAAW,GAAG,EAA7B;AAAA,YAAiCC,QAAjC;AAAA,YAA2C1H,SAA3C;AAAA,YAAsD2H,KAAtD;AACA,YAAIC,OAAO,GAAG,KAAd,CAR+B,CAQV;;AACrB,YAAIV,MAAM,GAAG,KAAb,CAT+B,CASX;;AACpB,YAAIvI,MAAM,CAACzuB,MAAX,EAAmB;AACjB4vB,UAAAA,SAAS,GAAGnB,MAAM,CAAC,CAAD,CAAlB;;AACA,cAAI9sB,SAAS,CAAC,MAAD,CAAT,IAAqBiuB,SAAS,KAAK,EAAvC,EAA2C;AACvCA,YAAAA,SAAS,GAAG,IAAI5oB,MAAJ,CAAW4oB,SAAX,EAAsBgC,MAAlC,CADuC,CACG;AAC7C;;AACD2F,UAAAA,WAAW,GAAG9I,MAAM,CAAC,CAAD,CAApB;;AACA,cAAI8I,WAAW,KAAKxzB,SAApB,EAA+B;AAC7B,gBAAIpC,SAAS,CAAC,MAAD,CAAb,EAAuB;AACrB41B,cAAAA,WAAW,GAAGpI,oBAAoB,CAACoI,WAAW,CAACl4B,OAAZ,CAAoB,WAApB,EAAgC,OAAhC,CAAD,CAAlC;AACD,aAFD,MAEO;AACLk4B,cAAAA,WAAW,GAAGtI,qBAAqB,CAACsI,WAAD,CAAnC;AACD;;AACDzsB,YAAAA,cAAc,CAAC0B,yBAAf,GAA2C+qB,WAA3C;AACD;;AACDC,UAAAA,QAAQ,GAAG/I,MAAM,CAAC,CAAD,CAAN,GAAYA,MAAM,CAAC,CAAD,CAAN,CAAUvpB,KAAV,CAAgB,GAAhB,CAAZ,GAAmC,EAA9C;AACD,SAfD,MAeO;AACL;AACA;AACA;AACA,cAAIipB,SAAS,IAAIA,SAAS,CAACnuB,MAA3B,EAAmC;AACjCmW,YAAAA,WAAW,CAAC1V,EAAD,EAAK,yCACZ,qBADO,CAAX;AAEA;AACD;AACF,SAlC8B,CAmC/B;AACA;;;AACA,YAAI+2B,QAAJ,EAAc;AACZ1H,UAAAA,SAAS,GAAG0H,QAAQ,CAAC,CAAD,CAApB;AACAC,UAAAA,KAAK,GAAGhlB,QAAQ,CAAC+kB,QAAQ,CAAC,CAAD,CAAT,CAAhB;;AACA,cAAI1H,SAAJ,EAAe;AACb,gBAAIA,SAAS,CAACtoB,OAAV,CAAkB,GAAlB,KAA0B,CAAC,CAA/B,EAAkC;AAChCkwB,cAAAA,OAAO,GAAG,IAAV;AACD;;AACD,gBAAI5H,SAAS,CAACtoB,OAAV,CAAkB,GAAlB,KAA0B,CAAC,CAA/B,EAAkC;AAChCwvB,cAAAA,MAAM,GAAG,IAAT;AACD;;AACD,gBAAIr1B,SAAS,CAAC,MAAD,CAAb,EAAuB;AACpBiuB,cAAAA,SAAS,GAAGA,SAAS,GAAG,GAAZ,GAAkBE,SAA9B;AACF,aAFD,MAEO;AACJF,cAAAA,SAAS,GAAGA,SAAS,CAACvwB,OAAV,CAAkB,KAAlB,EAAyB,KAAzB,IAAkC,GAAlC,GAAwCywB,SAApD;AACF;AACF;AACF;;AACD,YAAIF,SAAJ,EAAe;AACb;AACA;AACA,cAAI;AACF1Z,YAAAA,iBAAiB,CAACzV,EAAD,EAAKmvB,SAAL,EAAgB;AAAK;AAArB,cACf;AAAK;AADU,aAAjB;AAED,WAHD,CAGE,OAAOje,CAAP,EAAU;AACVwE,YAAAA,WAAW,CAAC1V,EAAD,EAAK,oBAAoBmvB,SAAzB,CAAX;AACA;AACD;AACF;;AACD2H,QAAAA,WAAW,GAAGA,WAAW,IAAIzsB,cAAc,CAAC0B,yBAA5C;;AACA,YAAI+qB,WAAW,KAAKxzB,SAApB,EAA+B;AAC7BoS,UAAAA,WAAW,CAAC1V,EAAD,EAAK,2CAAL,CAAX;AACA;AACD;;AACD,YAAIW,KAAK,GAAGoU,cAAc,CAAC/U,EAAD,CAA1B;AACA,YAAI0S,KAAK,GAAG/R,KAAK,CAACwU,QAAN,EAAZ;AACA,YAAIwgB,SAAS,GAAI7C,MAAM,CAACrwB,IAAP,KAAgBa,SAAjB,GAA8BwvB,MAAM,CAACrwB,IAArC,GAA4CzC,EAAE,CAACoF,SAAH,GAAe3C,IAA3E;AACA,YAAI6wB,OAAO,GAAGR,MAAM,CAACQ,OAAP,IAAkBqC,SAAhC;;AACA,YAAIA,SAAS,IAAI31B,EAAE,CAAC0G,SAAH,EAAb,IAA+B4sB,OAAO,IAAItzB,EAAE,CAAC2G,QAAH,EAA9C,EAA6D;AAC3D2sB,UAAAA,OAAO,GAAG9a,QAAV;AACD;;AACD,YAAIwe,KAAJ,EAAW;AACTrB,UAAAA,SAAS,GAAGrC,OAAZ;AACAA,UAAAA,OAAO,GAAGqC,SAAS,GAAGqB,KAAZ,GAAoB,CAA9B;AACD;;AACD,YAAIE,QAAQ,GAAGpf,mBAAmB,CAAC9X,EAAD,EAAKH,GAAG,CAAC81B,SAAD,EAAY,CAAZ,CAAR,CAAlC;AACA,YAAIhtB,MAAM,GAAG3I,EAAE,CAAC8U,eAAH,CAAmBpC,KAAnB,EAA0BwkB,QAA1B,CAAb;AACAC,QAAAA,SAAS,CAACn3B,EAAD,EAAKi3B,OAAL,EAAcV,MAAd,EAAsBZ,SAAtB,EAAiCrC,OAAjC,EAA0C3qB,MAA1C,EAAkD+J,KAAlD,EAAyDokB,WAAzD,EAAsEhE,MAAM,CAACtrB,QAA7E,CAAT;AACD,OA/Wc;AAgXfwd,MAAAA,IAAI,EAAEtoB,UAAU,CAACsjB,QAAX,CAAoBgF,IAhXX;AAiXfF,MAAAA,IAAI,EAAEpoB,UAAU,CAACsjB,QAAX,CAAoB8E,IAjXX;AAkXfsS,MAAAA,KAAK,EAAE,UAASp3B,EAAT,EAAa;AAClB,YAAItD,UAAU,CAACsjB,QAAX,CAAoBqX,IAAxB,EAA8B;AAC5B;AACA36B,UAAAA,UAAU,CAACsjB,QAAX,CAAoBqX,IAApB,CAAyBr3B,EAAzB;AACD,SAHD,MAGO,IAAIA,EAAE,CAACq3B,IAAP,EAAa;AAClB;AACAr3B,UAAAA,EAAE,CAACq3B,IAAH;AACD;AACF,OA1Xc;AA2XfC,MAAAA,UAAU,EAAE,UAASt3B,EAAT,EAAa;AACvB2W,QAAAA,oBAAoB,CAAC3W,EAAD,CAApB;AACD,OA7Xc;AA8XfmhB,MAAAA,IAAI,EAAE,UAAUnhB,EAAV,EAAc;AAClB,YAAIua,GAAG,GAAG1C,UAAU,CAAC7X,EAAE,CAACoF,SAAH,EAAD,CAApB;AACA,YAAI3C,IAAI,GAAG8X,GAAG,CAAC9X,IAAf;AACA,YAAIwb,QAAQ,GAAGje,EAAE,CAACuC,OAAH,CAAWE,IAAX,CAAf;AACA4H,QAAAA,cAAc,CAACI,kBAAf,CAAkC8H,QAAlC,CACE,GADF,EACO,MADP,EACe0L,QADf,EACyB,IADzB,EAC+B,IAD/B;AAED,OApYc;AAqYfsZ,MAAAA,QAAQ,EAAE,UAASv3B,EAAT,EAAa8yB,MAAb,EAAqB;AAC7B,YAAI,CAACA,MAAM,CAACpF,SAAR,IAAqB,CAACrG,IAAI,CAACyL,MAAM,CAACpF,SAAR,CAA9B,EAAkD;AAChDhY,UAAAA,WAAW,CAAC1V,EAAD,EAAK,mBAAL,CAAX;AACA;AACD;;AAED,YAAIW,KAAK,GAAGX,EAAE,CAACW,KAAH,CAASC,GAArB;AACA,YAAI+tB,MAAM,GAAG,IAAIjyB,UAAU,CAACkyB,YAAf,CAA4BvH,IAAI,CAACyL,MAAM,CAACpF,SAAR,CAAhC,CAAb;;AACA,eAAO,CAACiB,MAAM,CAACG,GAAP,EAAR,EAAsB;AACpBH,UAAAA,MAAM,CAAC0G,QAAP,GADoB,CAGpB;AACA;;AACA,cAAI2B,KAAK,GAAGrI,MAAM,CAAC1T,GAAnB;;AAEA,cAAI,CAAC0T,MAAM,CAACnf,KAAP,CAAa,UAAb,EAAyB,KAAzB,CAAL,EAAsC;AACpCkG,YAAAA,WAAW,CAAC1V,EAAD,EAAK,uBAAuB8yB,MAAM,CAACpF,SAAP,CAAiBhe,SAAjB,CAA2BsnB,KAA3B,CAA5B,CAAX;AACA;AACD;;AAED,cAAIQ,GAAG,GAAG7I,MAAM,CAAC7tB,IAAP,EAAV,CAZoB,CAapB;;AACA,cAAI6tB,MAAM,CAACnf,KAAP,CAAa,GAAb,EAAkB,IAAlB,CAAJ,EAA6B;AAC3B;AAEA;AACA,gBAAI,CAACmf,MAAM,CAACnf,KAAP,CAAa,UAAb,EAAyB,KAAzB,CAAL,EAAsC;AACpCkG,cAAAA,WAAW,CAAC1V,EAAD,EAAK,uBAAuB8yB,MAAM,CAACpF,SAAP,CAAiBhe,SAAjB,CAA2BsnB,KAA3B,CAA5B,CAAX;AACA;AACD;;AAED,gBAAIS,SAAS,GAAGD,GAAhB;AACA,gBAAIE,UAAU,GAAG/I,MAAM,CAAC7tB,IAAP,EAAjB,CAV2B,CAW3B;AACA;;AACA,gBAAI8F,WAAW,CAAC6wB,SAAD,CAAX,IAA0B7wB,WAAW,CAAC8wB,UAAD,CAArC,IACA7yB,WAAW,CAAC4yB,SAAD,CAAX,IAA0B5yB,WAAW,CAAC6yB,UAAD,CADzC,EACuD;AACrD,kBAAI9xB,KAAK,GAAG6xB,SAAS,CAACE,UAAV,CAAqB,CAArB,CAAZ;AACA,kBAAIC,MAAM,GAAGF,UAAU,CAACC,UAAX,CAAsB,CAAtB,CAAb;;AACA,kBAAI/xB,KAAK,IAAIgyB,MAAb,EAAqB;AACnBliB,gBAAAA,WAAW,CAAC1V,EAAD,EAAK,uBAAuB8yB,MAAM,CAACpF,SAAP,CAAiBhe,SAAjB,CAA2BsnB,KAA3B,CAA5B,CAAX;AACA;AACD,eANoD,CAQrD;AACA;AACA;;;AACA,mBAAK,IAAIxoB,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIopB,MAAM,GAAGhyB,KAA9B,EAAqC4I,CAAC,EAAtC,EAA0C;AACxC,oBAAIrF,IAAI,GAAGrD,MAAM,CAACC,YAAP,CAAoBH,KAAK,GAAG4I,CAA5B,CAAX;AACA,uBAAO7N,KAAK,CAACmC,KAAN,CAAYqG,IAAZ,CAAP;AACD;AACF,aAhBD,MAgBO;AACLuM,cAAAA,WAAW,CAAC1V,EAAD,EAAK,uBAAuBy3B,SAAvB,GAAmC,GAAxC,CAAX;AACA;AACD;AACF,WAjCD,MAiCO;AACL;AACA,mBAAO92B,KAAK,CAACmC,KAAN,CAAY00B,GAAZ,CAAP;AACD;AACF;AACF;AAjcc,KAAjB;AAocA,QAAIlqB,mBAAmB,GAAG,IAAIglB,mBAAJ,EAA1B;AAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACI,aAAS6E,SAAT,CAAmBn3B,EAAnB,EAAuBi3B,OAAvB,EAAgCV,MAAhC,EAAwCZ,SAAxC,EAAmDrC,OAAnD,EAA4DuE,YAA5D,EAA0EnlB,KAA1E,EACI0S,WADJ,EACiB5d,QADjB,EAC2B;AACzB;AACAxH,MAAAA,EAAE,CAACW,KAAH,CAASC,GAAT,CAAak3B,MAAb,GAAsB,IAAtB;AACA,UAAI3F,IAAI,GAAG,KAAX;AACA,UAAI4F,OAAJ,EAAaC,kBAAb,EAAiCC,MAAjC;;AACA,eAASC,UAAT,GAAsB;AACpBl4B,QAAAA,EAAE,CAAC8Q,SAAH,CAAa,YAAW;AACtB,iBAAO,CAACqhB,IAAR,EAAc;AACZvzB,YAAAA,OAAO;AACPkC,YAAAA,IAAI;AACL;;AACDkqB,UAAAA,IAAI;AACL,SAND;AAOD;;AACD,eAASpsB,OAAT,GAAmB;AACjB,YAAIuT,IAAI,GAAGnS,EAAE,CAAC0f,QAAH,CAAYmY,YAAY,CAAChd,IAAb,EAAZ,EAAiCgd,YAAY,CAAC/c,EAAb,EAAjC,CAAX;AACA,YAAIqd,OAAO,GAAGhmB,IAAI,CAACvT,OAAL,CAAa8T,KAAb,EAAoB0S,WAApB,CAAd;AACA,YAAIgT,oBAAoB,GAAGP,YAAY,CAAC/c,EAAb,GAAkBrY,IAA7C;AACAo1B,QAAAA,YAAY,CAACj5B,OAAb,CAAqBu5B,OAArB;AACAH,QAAAA,kBAAkB,GAAGH,YAAY,CAAC/c,EAAb,GAAkBrY,IAAvC;AACA6wB,QAAAA,OAAO,IAAI0E,kBAAkB,GAAGI,oBAAhC;AACAH,QAAAA,MAAM,GAAGD,kBAAkB,GAAGI,oBAA9B;AACD;;AACD,eAASC,kBAAT,GAA8B;AAC5B,YAAIC,WAAW,GAAGP,OAAO,IAAIlgB,UAAU,CAACggB,YAAY,CAAC/c,EAAb,EAAD,CAAvC;AACA,YAAItL,KAAK,GAAGqoB,YAAY,CAACnhB,QAAb,EAAZ;;AACA,YAAIlH,KAAK,IAAI,CAACA,KAAK,CAAC,CAAD,CAAf,IAAsB8oB,WAAtB,IAAqCtvB,WAAW,CAAC6uB,YAAY,CAAChd,IAAb,EAAD,EAAsByd,WAAtB,CAApD,EAAwF;AACtF9oB,UAAAA,KAAK,GAAGqoB,YAAY,CAACnhB,QAAb,EAAR;AACD;;AACD,eAAOlH,KAAP;AACD;;AACD,eAAS1O,IAAT,GAAgB;AACd;AACA;AACA,eAAMu3B,kBAAkB,MAClBvG,SAAS,CAAC+F,YAAY,CAAChd,IAAb,EAAD,EAAsB8a,SAAtB,EAAiCrC,OAAjC,CADf,EAC0D;AACxD,cAAI,CAACiD,MAAD,IAAWsB,YAAY,CAAChd,IAAb,GAAoBpY,IAApB,IAA4Bu1B,kBAAvC,IAA6D,CAACC,MAAlE,EAA0E;AACxE;AACD;;AACDj4B,UAAAA,EAAE,CAACyW,cAAH,CAAkBohB,YAAY,CAAChd,IAAb,EAAlB,EAAuC,EAAvC;AACA7a,UAAAA,EAAE,CAACkgB,YAAH,CAAgB2X,YAAY,CAAChd,IAAb,EAAhB,EAAqCgd,YAAY,CAAC/c,EAAb,EAArC;AACAid,UAAAA,OAAO,GAAGF,YAAY,CAAChd,IAAb,EAAV;AACAsX,UAAAA,IAAI,GAAG,KAAP;AACA;AACD;;AACDA,QAAAA,IAAI,GAAG,IAAP;AACD;;AACD,eAASnH,IAAT,CAAc/U,KAAd,EAAqB;AACnB,YAAIA,KAAJ,EAAW;AAAEA,UAAAA,KAAK;AAAK;;AACvBjW,QAAAA,EAAE,CAAC8W,KAAH;;AACA,YAAIihB,OAAJ,EAAa;AACX/3B,UAAAA,EAAE,CAACkF,SAAH,CAAa6yB,OAAb;AACA,cAAIn3B,GAAG,GAAGZ,EAAE,CAACW,KAAH,CAASC,GAAnB;AACAA,UAAAA,GAAG,CAACk3B,MAAJ,GAAa,KAAb;AACAl3B,UAAAA,GAAG,CAACsK,QAAJ,GAAetK,GAAG,CAACuK,SAAJ,GAAgB4sB,OAAO,CAACr1B,EAAvC;AACD;;AACD,YAAI8E,QAAJ,EAAc;AAAEA,UAAAA,QAAQ;AAAK;AAC9B;;AACD,eAASoP,eAAT,CAAyB1F,CAAzB,EAA4BqnB,MAA5B,EAAoCtiB,KAApC,EAA2C;AACzC;AACAvZ,QAAAA,UAAU,CAACma,MAAX,CAAkB3F,CAAlB;AACA,YAAIgF,OAAO,GAAGxZ,UAAU,CAACwZ,OAAX,CAAmBhF,CAAnB,CAAd;;AACA,gBAAQgF,OAAR;AACE,eAAK,GAAL;AACEtX,YAAAA,OAAO;AAAIkC,YAAAA,IAAI;AAAI;;AACrB,eAAK,GAAL;AACEA,YAAAA,IAAI;AAAI;;AACV,eAAK,GAAL;AACE;AACA;AACA,gBAAI03B,aAAa,GAAGhxB,QAApB;AACAA,YAAAA,QAAQ,GAAGlE,SAAX;AACAtD,YAAAA,EAAE,CAAC8Q,SAAH,CAAaonB,UAAb;AACA1wB,YAAAA,QAAQ,GAAGgxB,aAAX;AACA;;AACF,eAAK,GAAL;AACE55B,YAAAA,OAAO;AACP;;AACF,eAAK,GAAL;AACA,eAAK,KAAL;AACA,eAAK,QAAL;AACA,eAAK,QAAL;AACEosB,YAAAA,IAAI,CAAC/U,KAAD,CAAJ;AACA;AArBJ;;AAuBA,YAAIkc,IAAJ,EAAU;AAAEnH,UAAAA,IAAI,CAAC/U,KAAD,CAAJ;AAAc;;AAC1B,eAAO,IAAP;AACD,OAvFwB,CAyFzB;;;AACAnV,MAAAA,IAAI;;AACJ,UAAIqxB,IAAJ,EAAU;AACRzc,QAAAA,WAAW,CAAC1V,EAAD,EAAK,oBAAoB0S,KAAK,CAACye,MAA/B,CAAX;AACA;AACD;;AACD,UAAI,CAAC8F,OAAL,EAAc;AACZiB,QAAAA,UAAU;;AACV,YAAI1wB,QAAJ,EAAc;AAAEA,UAAAA,QAAQ;AAAK;;AAC7B;AACD;;AACDwP,MAAAA,UAAU,CAAChX,EAAD,EAAK;AACb0O,QAAAA,MAAM,EAAE6gB,GAAG,CAAC,MAAD,EAAS,eAAT,EAA0BA,GAAG,CAAC,QAAD,EAAWnK,WAAX,CAA7B,EAAsD,cAAtD,CADE;AAEbhO,QAAAA,SAAS,EAAER;AAFE,OAAL,CAAV;AAID;;AAEDla,IAAAA,UAAU,CAACqE,MAAX,CAAkBH,GAAlB,GAAwB;AACtBY,MAAAA,MAAM,EAAEC,YADc;AAEtBg3B,MAAAA,MAAM,EAAE53B,YAFc;AAGtBomB,MAAAA,IAAI,EAAE7jB;AAHgB,KAAxB;;AAMA,aAASkM,cAAT,CAAwBtP,EAAxB,EAA4B;AAC1B,UAAIY,GAAG,GAAGZ,EAAE,CAACW,KAAH,CAASC,GAAnB;AACA,UAAIwJ,cAAc,GAAGC,cAAc,CAACD,cAApC;AACA,UAAIsuB,wBAAwB,GAAGruB,cAAc,CAACI,kBAAf,CAAkCC,WAAlC,CAA8C,GAA9C,CAA/B;AACA,UAAIb,SAAS,GAAGO,cAAc,CAACP,SAA/B;AACA,UAAI8uB,UAAU,GAAGvuB,cAAc,CAACH,qBAAhC;;AACA,UAAI,CAACJ,SAAL,EAAgB;AACd7J,QAAAA,EAAE,CAACU,GAAH,CAAO,QAAP,EAAiB4hB,QAAjB;AACA5lB,QAAAA,UAAU,CAACgE,GAAX,CAAeV,EAAE,CAACO,aAAH,EAAf,EAAmC,SAAnC,EAA8CgiB,uBAA9C;AACD;;AACD,UAAI,CAAC1Y,SAAD,IAAcjJ,GAAG,CAAC0K,gBAAJ,GAAuB,CAAzC,EAA4C;AAC1C;AACAya,QAAAA,cAAc,CAAC/lB,EAAD,EAAKY,GAAL,EAAUA,GAAG,CAAC0K,gBAAJ,GAAuB,CAAjC,EACV;AAAK;AADK,SAAd;AAEA1K,QAAAA,GAAG,CAACoK,kBAAJ,CAAuBkJ,cAAvB,GAAwCtT,GAAG,CAAC0K,gBAA5C;AACD;;AACD,aAAO1K,GAAG,CAAC0K,gBAAX;AACA1K,MAAAA,GAAG,CAACqE,UAAJ,GAAiB,KAAjB;AACAjF,MAAAA,EAAE,CAACkF,SAAH,CAAalF,EAAE,CAACoF,SAAH,GAAe3C,IAA5B,EAAkCzC,EAAE,CAACoF,SAAH,GAAe1C,EAAf,GAAkB,CAApD;AACA1C,MAAAA,EAAE,CAACC,SAAH,CAAa,QAAb,EAAuB,KAAvB;AACAD,MAAAA,EAAE,CAACC,SAAH,CAAa,cAAb,EAA6B,IAA7B;AACAD,MAAAA,EAAE,CAACkiB,eAAH,CAAmB,KAAnB,EArB0B,CAqBC;AAC3B;;AACAwW,MAAAA,wBAAwB,CAACpmB,OAAzB,CAAiCqmB,UAAU,CAAClvB,OAAX,CAAmB1E,IAAnB,CAAwB,EAAxB,CAAjC;AACArI,MAAAA,UAAU,CAACwD,MAAX,CAAkBF,EAAlB,EAAsB,iBAAtB,EAAyC;AAACG,QAAAA,IAAI,EAAE;AAAP,OAAzC;;AACA,UAAIiK,cAAc,CAACN,WAAnB,EAAgC;AAC9B8uB,QAAAA,mBAAmB,CAACxuB,cAAD,CAAnB;AACD;AACF;;AAED,aAAS4D,WAAT,CAAqBgB,OAArB,EAA8B;AAC5BrS,MAAAA,aAAa,CAACm3B,OAAd,CAAsB9kB,OAAtB;AACD;;AAED,aAASyC,UAAT,CAAoB7U,IAApB,EAA0BC,IAA1B,EAAgC4C,IAAhC,EAAsC+f,IAAtC,EAA4CqZ,KAA5C,EAAmD;AACjD,UAAI7pB,OAAO,GAAG;AAACpS,QAAAA,IAAI,EAAEA,IAAP;AAAaC,QAAAA,IAAI,EAAEA;AAAnB,OAAd;AACAmS,MAAAA,OAAO,CAACnS,IAAD,CAAP,GAAgB4C,IAAhB;AACAuP,MAAAA,OAAO,CAACnS,IAAI,GAAG,MAAR,CAAP,GAAyB2iB,IAAzB;;AACA,WAAK,IAAInc,GAAT,IAAgBw1B,KAAhB,EACE7pB,OAAO,CAAC3L,GAAD,CAAP,GAAew1B,KAAK,CAACx1B,GAAD,CAApB;;AACF2K,MAAAA,WAAW,CAACgB,OAAD,CAAX;AACD,KAtkKkB,CAwkKnB;AACA;;;AACAhM,IAAAA,YAAY,CAAC,0BAAD,EAA6B,GAA7B,EAAkC,QAAlC,CAAZ;AAEAtG,IAAAA,UAAU,CAACqE,MAAX,CAAkB,YAAlB,IAAkC;AAChC;AACA;AACA+3B,MAAAA,WAAW,EAAE,CAAC,SAAD,CAHmB;AAIhCt3B,MAAAA,MAAM,EAAEC,YAJwB;AAKhCg3B,MAAAA,MAAM,EAAE53B,YALwB;AAMhComB,MAAAA,IAAI,EAAE7jB;AAN0B,KAAlC;AASA1G,IAAAA,UAAU,CAACqE,MAAX,CAAkB,aAAlB,IAAmC;AACjC,mBAAa,YADoB;AAEjC+3B,MAAAA,WAAW,EAAE,CAAC,YAAD,CAFoB;AAGjCt3B,MAAAA,MAAM,EAAEC,YAHyB;AAIjCg3B,MAAAA,MAAM,EAAE53B,YAJyB;AAKjComB,MAAAA,IAAI,EAAE7jB;AAL2B,KAAnC;;AAQA,aAAS6e,oBAAT,CAA8BjiB,EAA9B,EAAkCY,GAAlC,EAAuCwJ,cAAvC,EAAuDG,YAAvD,EAAqE;AACnE,UAAIC,QAAQ,GAAGH,cAAc,CAACI,kBAAf,CAAkCC,WAAlC,CAA8CH,YAA9C,CAAf;;AACA,UAAIA,YAAY,IAAI,GAApB,EAAyB;AACvB;AACA,YAAIC,QAAQ,CAACqF,SAAT,CAAmB,CAAnB,CAAJ,EAA2B;AACzBvC,UAAAA,mBAAmB,CAAC2D,cAApB,CAAmCjR,EAAnC,EAAuCwK,QAAQ,CAACqF,SAAT,CAAmB,CAAnB,CAAvC;AACD;;AACDzF,QAAAA,cAAc,CAACP,SAAf,GAA2B,KAA3B;AACA;AACD;;AACD,UAAIgG,SAAS,GAAGrF,QAAQ,CAACqF,SAAzB;AACA,UAAIkpB,GAAG,GAAG,CAAV;AACA3uB,MAAAA,cAAc,CAACP,SAAf,GAA2B,IAA3B;AACAO,MAAAA,cAAc,CAACL,mBAAf,GAAqCS,QAAQ,CAAC6H,aAAT,CAAuB/D,KAAvB,CAA6B,CAA7B,CAArC;;AACA,WAAK,IAAInM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG0N,SAAS,CAACtQ,MAA9B,EAAsC4C,CAAC,EAAvC,EAA2C;AACzC,YAAIgQ,IAAI,GAAGtC,SAAS,CAAC1N,CAAD,CAApB;AACA,YAAIqN,KAAJ,EAAWnM,GAAX;;AACA,eAAO8O,IAAP,EAAa;AACX;AACA;AACA3C,UAAAA,KAAK,GAAI,mBAAD,CAAsBC,IAAtB,CAA2B0C,IAA3B,CAAR;AACA9O,UAAAA,GAAG,GAAGmM,KAAK,CAAC,CAAD,CAAX;AACA2C,UAAAA,IAAI,GAAGA,IAAI,CAACzC,SAAL,CAAeF,KAAK,CAACG,KAAN,GAActM,GAAG,CAAC9D,MAAjC,CAAP;AACA7C,UAAAA,UAAU,CAACoD,GAAX,CAAegP,SAAf,CAAyB9O,EAAzB,EAA6BqD,GAA7B,EAAkC,OAAlC;;AACA,cAAIzC,GAAG,CAACqE,UAAR,EAAoB;AAClB,gBAAIwE,OAAO,GAAGe,QAAQ,CAAC4H,iBAAT,CAA2B2mB,GAAG,EAA9B,EAAkCtvB,OAAhD;AACAY,YAAAA,cAAc,CAACD,cAAf,CAA8BH,qBAA9B,CAAoDR,OAApD,GACIA,OADJ;AAEAuvB,YAAAA,uBAAuB,CAACh5B,EAAD,EAAKyJ,OAAL,EAAc,CAAd,CAAvB;AACA6F,YAAAA,cAAc,CAACtP,EAAD,CAAd;AACD;AACF;AACF;;AACDoK,MAAAA,cAAc,CAACP,SAAf,GAA2B,KAA3B;AACD;;AAED,aAASsF,MAAT,CAAgB/E,cAAhB,EAAgC/G,GAAhC,EAAqC;AACnC,UAAI+G,cAAc,CAACP,SAAnB,EAA8B;AAAE;AAAS;;AACzC,UAAIU,YAAY,GAAGH,cAAc,CAACR,cAAlC;AACA,UAAIY,QAAQ,GAAGH,cAAc,CAACI,kBAAf,CAAkCC,WAAlC,CAA8CH,YAA9C,CAAf;;AACA,UAAIC,QAAJ,EAAc;AACZA,QAAAA,QAAQ,CAAC+H,QAAT,CAAkBlP,GAAlB;AACD;AACF;;AAED,aAASu1B,mBAAT,CAA6BxuB,cAA7B,EAA6C;AAC3C,UAAIA,cAAc,CAACP,SAAnB,EAA8B;AAAE;AAAS;;AACzC,UAAIU,YAAY,GAAGH,cAAc,CAACR,cAAlC;AACA,UAAIY,QAAQ,GAAGH,cAAc,CAACI,kBAAf,CAAkCC,WAAlC,CAA8CH,YAA9C,CAAf;;AACA,UAAIC,QAAQ,IAAIA,QAAQ,CAACgI,qBAAzB,EAAgD;AAC9ChI,QAAAA,QAAQ,CAACgI,qBAAT,CAA+BpI,cAAc,CAACH,qBAA9C;AACD;AACF;;AAED,aAAS8L,cAAT,CAAwB3L,cAAxB,EAAwCsI,KAAxC,EAA+C;AAC7C,UAAItI,cAAc,CAACP,SAAnB,EAA8B;AAAE;AAAS;;AACzC,UAAIU,YAAY,GAAGH,cAAc,CAACR,cAAlC;AACA,UAAIY,QAAQ,GAAGH,cAAc,CAACI,kBAAf,CAAkCC,WAAlC,CAA8CH,YAA9C,CAAf;;AACA,UAAIC,QAAQ,IAAIA,QAAQ,CAACiI,eAAzB,EAA0C;AACxCjI,QAAAA,QAAQ,CAACiI,eAAT,CAAyBC,KAAzB;AACD;AACF;AAED;AACJ;AACA;AACA;;;AACI,aAAS4P,QAAT,CAAkBtiB,EAAlB,EAAsBi5B,SAAtB,EAAiC;AAC/B,UAAI7uB,cAAc,GAAGC,cAAc,CAACD,cAApC;AACA,UAAIuuB,UAAU,GAAGvuB,cAAc,CAACH,qBAAhC;;AACA,UAAI,CAACG,cAAc,CAACP,SAApB,EAA+B;AAC7B,eAAMovB,SAAN,EAAiB;AACfN,UAAAA,UAAU,CAACjvB,6BAAX,GAA2C,IAA3C;;AACA,cAAIivB,UAAU,CAACO,WAAX,GAAyB,CAA7B,EAAgC;AAC9BP,YAAAA,UAAU,CAACO,WAAX;AACD,WAFD,MAEO,IAAID,SAAS,CAAClqB,MAAV,IAAoB,QAApB,IAAgCkqB,SAAS,CAAClqB,MAAV,IAAoB,OAApD,IACJkqB,SAAS,CAAClqB,MAAV,KAAqBzL;AAAU;AAD/B,YACsD;AAC3D,gBAAI61B,cAAc,GAAGn5B,EAAE,CAACiC,cAAH,GAAoB1C,MAAzC;AACA,gBAAI45B,cAAc,GAAG,CAArB,EACER,UAAU,CAACO,WAAX,GAAyBC,cAAzB;AACF,gBAAIhnB,IAAI,GAAG8mB,SAAS,CAAC9mB,IAAV,CAAepN,IAAf,CAAoB,IAApB,CAAX;;AACA,gBAAI4zB,UAAU,CAACS,UAAf,EAA2B;AACzBT,cAAAA,UAAU,CAAClvB,OAAX,GAAqB,EAArB;AACAkvB,cAAAA,UAAU,CAACS,UAAX,GAAwB,KAAxB;AACD;;AACD,gBAAIjnB,IAAJ,EAAU;AACR,kBAAInS,EAAE,CAACW,KAAH,CAASwhB,SAAT,IAAsB,CAAC,KAAKhf,IAAL,CAAUgP,IAAV,CAA3B,EAA4C;AAC1CwmB,gBAAAA,UAAU,CAAClvB,OAAX,CAAmB9G,IAAnB,CAAwB,CAACwP,IAAD,CAAxB;AACD,eAFD,MAEO;AACLwmB,gBAAAA,UAAU,CAAClvB,OAAX,CAAmB9G,IAAnB,CAAwBwP,IAAxB;AACD;AACF;AACF,WArBc,CAsBf;;;AACA8mB,UAAAA,SAAS,GAAGA,SAAS,CAACn4B,IAAtB;AACD;AACF;AACF;AAED;AACJ;AACA;;;AACI,aAAST,gBAAT,CAA0BL,EAA1B,EAA8B;AAC5B,UAAIY,GAAG,GAAGZ,EAAE,CAACW,KAAH,CAASC,GAAnB;;AACA,UAAIA,GAAG,CAACqE,UAAR,EAAoB;AAClB;AACA,YAAImF,cAAc,GAAGC,cAAc,CAACD,cAApC;;AACA,YAAIA,cAAc,CAACP,SAAnB,EAA8B;AAAE;AAAS;;AACzC,YAAI8uB,UAAU,GAAGvuB,cAAc,CAACH,qBAAhC;;AACA,YAAI0uB,UAAU,CAACjvB,6BAAf,EAA8C;AAC5CivB,UAAAA,UAAU,CAACjvB,6BAAX,GAA2C,KAA3C;AACD,SAFD,MAEO;AACL;AACAivB,UAAAA,UAAU,CAACS,UAAX,GAAwB,IAAxB;AACD;AACF,OAXD,MAWO,IAAI,CAACp5B,EAAE,CAAC+Q,KAAH,CAASC,OAAd,EAAuB;AAC5BqoB,QAAAA,uBAAuB,CAACr5B,EAAD,EAAKY,GAAL,CAAvB;AACD;;AACD,UAAIA,GAAG,CAAC2K,UAAR,EAAoB;AAClBid,QAAAA,gBAAgB,CAACxoB,EAAD,CAAhB;AACD;AACF;AACD;AACJ;AACA;;;AACI,aAASwoB,gBAAT,CAA0BxoB,EAA1B,EAA8B;AAC5B,UAAI6C,SAAS,GAAG,uBAAhB;AACA,UAAIjC,GAAG,GAAGZ,EAAE,CAACW,KAAH,CAASC,GAAnB;AACA,UAAIia,IAAI,GAAG/C,mBAAmB,CAAC9X,EAAD,EAAK6X,UAAU,CAACjX,GAAG,CAAC+K,GAAJ,CAAQ1D,IAAT,CAAf,CAA9B;AACA,UAAI6S,EAAE,GAAG3V,YAAY,CAAC0V,IAAD,EAAO,CAAP,EAAU,CAAV,CAArB;AACAiO,MAAAA,eAAe,CAACloB,GAAD,CAAf,CAL4B,CAM5B;;AACA,UAAIia,IAAI,CAACnY,EAAL,IAAW1C,EAAE,CAACuC,OAAH,CAAWsY,IAAI,CAACpY,IAAhB,EAAsBlD,MAArC,EAA6C;AAC3C,YAAI+5B,MAAM,GAAG/J,GAAG,CAAC,MAAD,EAAS;AAAE,mBAAS1sB;AAAX,SAAT,EAAiC,QAAjC,CAAhB;AACAjC,QAAAA,GAAG,CAAC24B,kBAAJ,GAAyBv5B,EAAE,CAAC6I,WAAH,CAAegS,IAAf,EAAqB;AAACye,UAAAA,MAAM,EAAEA;AAAT,SAArB,CAAzB;AACD,OAHD,MAGO;AACL14B,QAAAA,GAAG,CAACyK,UAAJ,GAAiBrL,EAAE,CAAC4C,QAAH,CAAYiY,IAAZ,EAAkBC,EAAlB,EAAsB;AAACjY,UAAAA,SAAS,EAAEA;AAAZ,SAAtB,CAAjB;AACD;AACF;;AACD,aAASimB,eAAT,CAAyBloB,GAAzB,EAA8B;AAC5B,UAAIA,GAAG,CAACyK,UAAR,EAAoB;AAClBzK,QAAAA,GAAG,CAACyK,UAAJ,CAAetI,KAAf;AACAnC,QAAAA,GAAG,CAACyK,UAAJ,GAAiB,IAAjB;AACD;;AACD,UAAIzK,GAAG,CAAC24B,kBAAR,EAA4B;AAC1B34B,QAAAA,GAAG,CAAC24B,kBAAJ,CAAuBx2B,KAAvB;AACAnC,QAAAA,GAAG,CAAC24B,kBAAJ,GAAyB,IAAzB;AACD;AACF;;AACD,aAASF,uBAAT,CAAiCr5B,EAAjC,EAAqCY,GAArC,EAA0C;AACxC,UAAI4B,MAAM,GAAGxC,EAAE,CAACoF,SAAH,CAAa,QAAb,CAAb;AACA,UAAI6C,IAAI,GAAGjI,EAAE,CAACoF,SAAH,CAAa,MAAb,CAAX,CAFwC,CAGxC;;AACA,UAAIxE,GAAG,CAAC2K,UAAJ,IAAkB,CAACvL,EAAE,CAACw5B,iBAAH,EAAvB,EAA+C;AAC7CnqB,QAAAA,cAAc,CAACrP,EAAD,EAAK,KAAL,CAAd;AACD,OAFD,MAEO,IAAI,CAACY,GAAG,CAAC2K,UAAL,IAAmB,CAAC3K,GAAG,CAACqE,UAAxB,IAAsCjF,EAAE,CAACw5B,iBAAH,EAA1C,EAAkE;AACvE54B,QAAAA,GAAG,CAAC2K,UAAJ,GAAiB,IAAjB;AACA3K,QAAAA,GAAG,CAACtC,UAAJ,GAAiB,KAAjB;AACA5B,QAAAA,UAAU,CAACwD,MAAX,CAAkBF,EAAlB,EAAsB,iBAAtB,EAAyC;AAACG,UAAAA,IAAI,EAAE;AAAP,SAAzC;AACD;;AACD,UAAIS,GAAG,CAAC2K,UAAR,EAAoB;AAClB;AACA;AACA,YAAIkd,UAAU,GAAG,CAAC/P,cAAc,CAACzQ,IAAD,EAAOzF,MAAP,CAAf,GAAgC,CAAC,CAAjC,GAAqC,CAAtD;AACA,YAAIkmB,YAAY,GAAGhQ,cAAc,CAACzQ,IAAD,EAAOzF,MAAP,CAAd,GAA+B,CAAC,CAAhC,GAAoC,CAAvD;AACAyF,QAAAA,IAAI,GAAG9C,YAAY,CAAC8C,IAAD,EAAO,CAAP,EAAUwgB,UAAV,CAAnB;AACAjmB,QAAAA,MAAM,GAAG2C,YAAY,CAAC3C,MAAD,EAAS,CAAT,EAAYkmB,YAAZ,CAArB;AACA9nB,QAAAA,GAAG,CAAC+K,GAAJ,GAAU;AACRnJ,UAAAA,MAAM,EAAEA,MADA;AAERyF,UAAAA,IAAI,EAAEA;AAFE,SAAV;AAIAwQ,QAAAA,UAAU,CAACzY,EAAD,EAAKY,GAAL,EAAU,GAAV,EAAesY,SAAS,CAACjR,IAAD,EAAOzF,MAAP,CAAxB,CAAV;AACAiW,QAAAA,UAAU,CAACzY,EAAD,EAAKY,GAAL,EAAU,GAAV,EAAeuY,SAAS,CAAClR,IAAD,EAAOzF,MAAP,CAAxB,CAAV;AACD,OAbD,MAaO,IAAI,CAAC5B,GAAG,CAACqE,UAAT,EAAqB;AAC1B;AACArE,QAAAA,GAAG,CAACsK,QAAJ,GAAelL,EAAE,CAACoF,SAAH,GAAe1C,EAA9B;AACD;AACF;AAED;;;AACA,aAASuK,aAAT,CAAuBiJ,OAAvB,EAAgC;AAC9B,WAAKA,OAAL,GAAeA,OAAf;AACD;AAED;AACJ;AACA;AACA;AACA;;;AACI,aAASqM,uBAAT,CAAiCrR,CAAjC,EAAoC;AAClC,UAAI9G,cAAc,GAAGC,cAAc,CAACD,cAApC;AACA,UAAIuuB,UAAU,GAAGvuB,cAAc,CAACH,qBAAhC;AACA,UAAIiM,OAAO,GAAGxZ,UAAU,CAACwZ,OAAX,CAAmBhF,CAAnB,CAAd;;AACA,UAAI,CAACgF,OAAL,EAAc;AAAE;AAAS;;AACzB,eAASujB,UAAT,GAAsB;AACpB,YAAId,UAAU,CAACS,UAAf,EAA2B;AACzBT,UAAAA,UAAU,CAAClvB,OAAX,GAAqB,EAArB;AACAkvB,UAAAA,UAAU,CAACS,UAAX,GAAwB,KAAxB;AACD;;AACDT,QAAAA,UAAU,CAAClvB,OAAX,CAAmB9G,IAAnB,CAAwB,IAAIsK,aAAJ,CAAkBiJ,OAAlB,CAAxB;AACA,eAAO,IAAP;AACD;;AACD,UAAIA,OAAO,CAACnP,OAAR,CAAgB,QAAhB,KAA6B,CAAC,CAA9B,IAAmCmP,OAAO,CAACnP,OAAR,CAAgB,WAAhB,KAAgC,CAAC,CAAxE,EAA2E;AACzErK,QAAAA,UAAU,CAACg9B,SAAX,CAAqBxjB,OAArB,EAA8B,YAA9B,EAA4CujB,UAA5C;AACD;AACF;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI,aAAS1T,cAAT,CAAwB/lB,EAAxB,EAA4BY,GAA5B,EAAiCmR,MAAjC,EAAyC4nB,eAAzC,EAA0D;AACxD,UAAIvvB,cAAc,GAAGC,cAAc,CAACD,cAApC;AACAA,MAAAA,cAAc,CAACP,SAAf,GAA2B,IAA3B;AACA,UAAI+vB,QAAQ,GAAG,CAAC,CAACh5B,GAAG,CAACqK,qBAArB;AACA,UAAI4uB,gBAAgB,GAAGj5B,GAAG,CAACkK,UAA3B;;AACA,eAASgvB,aAAT,GAAyB;AACvB,YAAIF,QAAJ,EAAc;AACZ7pB,UAAAA,iBAAiB,CAACuE,aAAlB,CAAgCtU,EAAhC,EAAoCY,GAApC,EAAyCA,GAAG,CAACqK,qBAA7C;AACD,SAFD,MAEO;AACL8E,UAAAA,iBAAiB,CAAC2E,SAAlB,CAA4B1U,EAA5B,EAAgCY,GAAhC;AACD;AACF;;AACD,eAASm5B,YAAT,CAAsBhoB,MAAtB,EAA8B;AAC5B,YAAI3H,cAAc,CAACH,qBAAf,CAAqCR,OAArC,CAA6ClK,MAA7C,GAAsD,CAA1D,EAA6D;AAC3D;AACA;AACAwS,UAAAA,MAAM,GAAG,CAACnR,GAAG,CAACqK,qBAAL,GAA6B,CAA7B,GAAiC8G,MAA1C;AACA,cAAIioB,YAAY,GAAG5vB,cAAc,CAACH,qBAAlC;AACA+uB,UAAAA,uBAAuB,CAACh5B,EAAD,EAAKg6B,YAAY,CAACvwB,OAAlB,EAA2BsI,MAA3B,CAAvB;AACD;AACF;;AACDnR,MAAAA,GAAG,CAACkK,UAAJ,GAAiBlK,GAAG,CAACoK,kBAArB;;AACA,UAAI4uB,QAAQ,IAAIh5B,GAAG,CAACqK,qBAAJ,CAA0BxM,qBAA1C,EAAiE;AAC/D;AACA;AACA,aAAK,IAAI0D,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG4P,MAApB,EAA4B5P,CAAC,EAA7B,EAAiC;AAC/B23B,UAAAA,aAAa;AACbC,UAAAA,YAAY,CAAC,CAAD,CAAZ;AACD;AACF,OAPD,MAOO;AACL,YAAI,CAACJ,eAAL,EAAsB;AACpB;AACA;AACA;AACAG,UAAAA,aAAa;AACd;;AACDC,QAAAA,YAAY,CAAChoB,MAAD,CAAZ;AACD;;AACDnR,MAAAA,GAAG,CAACkK,UAAJ,GAAiB+uB,gBAAjB;;AACA,UAAIj5B,GAAG,CAACqE,UAAJ,IAAkB,CAAC00B,eAAvB,EAAwC;AACtC;AACA;AACArqB,QAAAA,cAAc,CAACtP,EAAD,CAAd;AACD;;AACDoK,MAAAA,cAAc,CAACP,SAAf,GAA2B,KAA3B;AACD;;AAED,aAASmvB,uBAAT,CAAiCh5B,EAAjC,EAAqCyJ,OAArC,EAA8CsI,MAA9C,EAAsD;AACpD,eAASkoB,UAAT,CAAoBC,OAApB,EAA6B;AAC3B,YAAI,OAAOA,OAAP,IAAkB,QAAtB,EAAgC;AAC9Bx9B,UAAAA,UAAU,CAACsjB,QAAX,CAAoBka,OAApB,EAA6Bl6B,EAA7B;AACD,SAFD,MAEO;AACLk6B,UAAAA,OAAO,CAACl6B,EAAD,CAAP;AACD;;AACD,eAAO,IAAP;AACD;;AACD,UAAIiI,IAAI,GAAGjI,EAAE,CAACoF,SAAH,CAAa,MAAb,CAAX;AACA,UAAIoG,WAAW,GAAGnB,cAAc,CAACD,cAAf,CAA8BH,qBAA9B,CAAoDuB,WAAtE;;AACA,UAAIA,WAAJ,EAAiB;AACf;AACAgX,QAAAA,eAAe,CAACxiB,EAAD,EAAKiI,IAAL,EAAWuD,WAAW,GAAG,CAAzB,CAAf;AACAuG,QAAAA,MAAM,GAAG/R,EAAE,CAACiC,cAAH,GAAoB1C,MAA7B;AACAS,QAAAA,EAAE,CAACkF,SAAH,CAAa+C,IAAb;AACD;;AACD,WAAK,IAAI9F,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG4P,MAApB,EAA4B5P,CAAC,EAA7B,EAAiC;AAC/B,YAAIqJ,WAAJ,EAAiB;AACfxL,UAAAA,EAAE,CAACkF,SAAH,CAAaC,YAAY,CAAC8C,IAAD,EAAO9F,CAAP,EAAU,CAAV,CAAzB;AACD;;AACD,aAAK,IAAIqM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG/E,OAAO,CAAClK,MAA5B,EAAoCiP,CAAC,EAArC,EAAyC;AACvC,cAAI+Q,MAAM,GAAG9V,OAAO,CAAC+E,CAAD,CAApB;;AACA,cAAI+Q,MAAM,YAAYtS,aAAtB,EAAqC;AACnCvQ,YAAAA,UAAU,CAACg9B,SAAX,CAAqBna,MAAM,CAACrJ,OAA5B,EAAqC,YAArC,EAAmD+jB,UAAnD;AACD,WAFD,MAEO,IAAI,OAAO1a,MAAP,IAAiB,QAArB,EAA+B;AACpC,gBAAIhF,GAAG,GAAGva,EAAE,CAACoF,SAAH,EAAV;AACApF,YAAAA,EAAE,CAACuQ,YAAH,CAAgBgP,MAAhB,EAAwBhF,GAAxB,EAA6BA,GAA7B;AACD,WAHM,MAGA;AACL,gBAAI3U,KAAK,GAAG5F,EAAE,CAACoF,SAAH,EAAZ;AACA,gBAAIoS,GAAG,GAAGrS,YAAY,CAACS,KAAD,EAAQ,CAAR,EAAW2Z,MAAM,CAAC,CAAD,CAAN,CAAUhgB,MAArB,CAAtB;AACAS,YAAAA,EAAE,CAACuQ,YAAH,CAAgBgP,MAAM,CAAC,CAAD,CAAtB,EAA2B3Z,KAA3B,EAAkC4R,GAAlC;AACD;AACF;AACF;;AACD,UAAIhM,WAAJ,EAAiB;AACfxL,QAAAA,EAAE,CAACkF,SAAH,CAAaC,YAAY,CAAC8C,IAAD,EAAO,CAAP,EAAU,CAAV,CAAzB;AACD;AACF;;AAED2D,IAAAA,mBAAmB;AACnB,WAAOc,MAAP;AACD,GA94KD,CAjNsB,CAgmLtB;;;AACAhQ,EAAAA,UAAU,CAACoD,GAAX,GAAiBA,GAAG,EAApB;AACD,CAzmLD","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n/**\n * Supported keybindings:\n *   Too many to list. Refer to defaultKeymap below.\n *\n * Supported Ex commands:\n *   Refer to defaultExCommandMap below.\n *\n * Registers: unnamed, -, ., :, /, _, a-z, A-Z, 0-9\n *   (Does not respect the special case for number registers when delete\n *    operator is made with these commands: %, (, ),  , /, ?, n, N, {, } )\n *   TODO: Implement the remaining registers.\n *\n * Marks: a-z, A-Z, and 0-9\n *   TODO: Implement the remaining special marks. They have more complex\n *       behavior.\n *\n * Events:\n *  'vim-mode-change' - raised on the editor anytime the current mode changes,\n *                      Event object: {mode: \"visual\", subMode: \"linewise\"}\n *\n * Code structure:\n *  1. Default keymap\n *  2. Variable declarations and short basic helpers\n *  3. Instance (External API) implementation\n *  4. Internal state tracking objects (input state, counter) implementation\n *     and instantiation\n *  5. Key handler (the main command dispatcher) implementation\n *  6. Motion, operator, and action implementations\n *  7. Helper functions for the key handler, motions, operators, and actions\n *  8. Set up Vim to work as a keymap for CodeMirror.\n *  9. Ex command implementations.\n */\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../lib/codemirror\"), require(\"../addon/search/searchcursor\"), require(\"../addon/dialog/dialog\"), require(\"../addon/edit/matchbrackets.js\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../lib/codemirror\", \"../addon/search/searchcursor\", \"../addon/dialog/dialog\", \"../addon/edit/matchbrackets\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  'use strict';\n\n  var defaultKeymap = [\n    // Key to key mapping. This goes first to make it possible to override\n    // existing mappings.\n    { keys: '<Left>', type: 'keyToKey', toKeys: 'h' },\n    { keys: '<Right>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<Up>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<Down>', type: 'keyToKey', toKeys: 'j' },\n    { keys: '<Space>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<BS>', type: 'keyToKey', toKeys: 'h', context: 'normal'},\n    { keys: '<Del>', type: 'keyToKey', toKeys: 'x', context: 'normal'},\n    { keys: '<C-Space>', type: 'keyToKey', toKeys: 'W' },\n    { keys: '<C-BS>', type: 'keyToKey', toKeys: 'B', context: 'normal' },\n    { keys: '<S-Space>', type: 'keyToKey', toKeys: 'w' },\n    { keys: '<S-BS>', type: 'keyToKey', toKeys: 'b', context: 'normal' },\n    { keys: '<C-n>', type: 'keyToKey', toKeys: 'j' },\n    { keys: '<C-p>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: 's', type: 'keyToKey', toKeys: 'cl', context: 'normal' },\n    { keys: 's', type: 'keyToKey', toKeys: 'c', context: 'visual'},\n    { keys: 'S', type: 'keyToKey', toKeys: 'cc', context: 'normal' },\n    { keys: 'S', type: 'keyToKey', toKeys: 'VdO', context: 'visual' },\n    { keys: '<Home>', type: 'keyToKey', toKeys: '0' },\n    { keys: '<End>', type: 'keyToKey', toKeys: '$' },\n    { keys: '<PageUp>', type: 'keyToKey', toKeys: '<C-b>' },\n    { keys: '<PageDown>', type: 'keyToKey', toKeys: '<C-f>' },\n    { keys: '<CR>', type: 'keyToKey', toKeys: 'j^', context: 'normal' },\n    { keys: '<Ins>', type: 'action', action: 'toggleOverwrite', context: 'insert' },\n    // Motions\n    { keys: 'H', type: 'motion', motion: 'moveToTopLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'M', type: 'motion', motion: 'moveToMiddleLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'L', type: 'motion', motion: 'moveToBottomLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'h', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: false }},\n    { keys: 'l', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: true }},\n    { keys: 'j', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, linewise: true }},\n    { keys: 'k', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, linewise: true }},\n    { keys: 'gj', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: true }},\n    { keys: 'gk', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: false }},\n    { keys: 'w', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false }},\n    { keys: 'W', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false, bigWord: true }},\n    { keys: 'e', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, inclusive: true }},\n    { keys: 'E', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: 'b', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }},\n    { keys: 'B', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false, bigWord: true }},\n    { keys: 'ge', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, inclusive: true }},\n    { keys: 'gE', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: '{', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: false, toJumplist: true }},\n    { keys: '}', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: true, toJumplist: true }},\n    { keys: '(', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: false }},\n    { keys: ')', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: true }},\n    { keys: '<C-f>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: true }},\n    { keys: '<C-b>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: false }},\n    { keys: '<C-d>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: true, explicitRepeat: true }},\n    { keys: '<C-u>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: false, explicitRepeat: true }},\n    { keys: 'gg', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: false, explicitRepeat: true, linewise: true, toJumplist: true }},\n    { keys: 'G', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: true, explicitRepeat: true, linewise: true, toJumplist: true }},\n    { keys: '0', type: 'motion', motion: 'moveToStartOfLine' },\n    { keys: '^', type: 'motion', motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '+', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true }},\n    { keys: '-', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, toFirstChar:true }},\n    { keys: '_', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true, repeatOffset:-1 }},\n    { keys: '$', type: 'motion', motion: 'moveToEol', motionArgs: { inclusive: true }},\n    { keys: '%', type: 'motion', motion: 'moveToMatchedSymbol', motionArgs: { inclusive: true, toJumplist: true }},\n    { keys: 'f<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: true , inclusive: true }},\n    { keys: 'F<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: false }},\n    { keys: 't<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: true, inclusive: true }},\n    { keys: 'T<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: false }},\n    { keys: ';', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: true }},\n    { keys: ',', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: false }},\n    { keys: '\\'<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true, linewise: true}},\n    { keys: '`<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true}},\n    { keys: ']`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true } },\n    { keys: '[`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false } },\n    { keys: ']\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true, linewise: true } },\n    { keys: '[\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false, linewise: true } },\n    // the next two aren't motions but must come before more general motion declarations\n    { keys: ']p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true, matchIndent: true}},\n    { keys: '[p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true, matchIndent: true}},\n    { keys: ']<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: true, toJumplist: true}},\n    { keys: '[<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: false, toJumplist: true}},\n    { keys: '|', type: 'motion', motion: 'moveToColumn'},\n    { keys: 'o', type: 'motion', motion: 'moveToOtherHighlightedEnd', context:'visual'},\n    { keys: 'O', type: 'motion', motion: 'moveToOtherHighlightedEnd', motionArgs: {sameLine: true}, context:'visual'},\n    // Operators\n    { keys: 'd', type: 'operator', operator: 'delete' },\n    { keys: 'y', type: 'operator', operator: 'yank' },\n    { keys: 'c', type: 'operator', operator: 'change' },\n    { keys: '=', type: 'operator', operator: 'indentAuto' },\n    { keys: '>', type: 'operator', operator: 'indent', operatorArgs: { indentRight: true }},\n    { keys: '<', type: 'operator', operator: 'indent', operatorArgs: { indentRight: false }},\n    { keys: 'g~', type: 'operator', operator: 'changeCase' },\n    { keys: 'gu', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, isEdit: true },\n    { keys: 'gU', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, isEdit: true },\n    { keys: 'n', type: 'motion', motion: 'findNext', motionArgs: { forward: true, toJumplist: true }},\n    { keys: 'N', type: 'motion', motion: 'findNext', motionArgs: { forward: false, toJumplist: true }},\n    { keys: 'gn', type: 'motion', motion: 'findAndSelectNextInclusive', motionArgs: { forward: true }},\n    { keys: 'gN', type: 'motion', motion: 'findAndSelectNextInclusive', motionArgs: { forward: false }},\n    // Operator-Motion dual commands\n    { keys: 'x', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorMotionArgs: { visualLine: false }},\n    { keys: 'X', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: false }, operatorMotionArgs: { visualLine: true }},\n    { keys: 'D', type: 'operatorMotion', operator: 'delete', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'D', type: 'operator', operator: 'delete', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'Y', type: 'operatorMotion', operator: 'yank', motion: 'expandToLine', motionArgs: { linewise: true }, context: 'normal'},\n    { keys: 'Y', type: 'operator', operator: 'yank', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'C', type: 'operatorMotion', operator: 'change', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'C', type: 'operator', operator: 'change', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: '~', type: 'operatorMotion', operator: 'changeCase', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorArgs: { shouldMoveCursor: true }, context: 'normal'},\n    { keys: '~', type: 'operator', operator: 'changeCase', context: 'visual'},\n    { keys: '<C-w>', type: 'operatorMotion', operator: 'delete', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }, context: 'insert' },\n    //ignore C-w in normal mode\n    { keys: '<C-w>', type: 'idle', context: 'normal' },\n    // Actions\n    { keys: '<C-i>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: true }},\n    { keys: '<C-o>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: false }},\n    { keys: '<C-e>', type: 'action', action: 'scroll', actionArgs: { forward: true, linewise: true }},\n    { keys: '<C-y>', type: 'action', action: 'scroll', actionArgs: { forward: false, linewise: true }},\n    { keys: 'a', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'charAfter' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'eol' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'endOfSelectedArea' }, context: 'visual' },\n    { keys: 'i', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'inplace' }, context: 'normal' },\n    { keys: 'gi', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'lastEdit' }, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'firstNonBlank'}, context: 'normal' },\n    { keys: 'gI', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'bol'}, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'startOfSelectedArea' }, context: 'visual' },\n    { keys: 'o', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: true }, context: 'normal' },\n    { keys: 'O', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: false }, context: 'normal' },\n    { keys: 'v', type: 'action', action: 'toggleVisualMode' },\n    { keys: 'V', type: 'action', action: 'toggleVisualMode', actionArgs: { linewise: true }},\n    { keys: '<C-v>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: '<C-q>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: 'gv', type: 'action', action: 'reselectLastSelection' },\n    { keys: 'J', type: 'action', action: 'joinLines', isEdit: true },\n    { keys: 'gJ', type: 'action', action: 'joinLines', actionArgs: { keepSpaces: true }, isEdit: true },\n    { keys: 'p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true }},\n    { keys: 'P', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true }},\n    { keys: 'r<character>', type: 'action', action: 'replace', isEdit: true },\n    { keys: '@<character>', type: 'action', action: 'replayMacro' },\n    { keys: 'q<character>', type: 'action', action: 'enterMacroRecordMode' },\n    // Handle Replace-mode as a special case of insert mode.\n    { keys: 'R', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { replace: true }, context: 'normal'},\n    { keys: 'R', type: 'operator', operator: 'change', operatorArgs: { linewise: true, fullLine: true }, context: 'visual', exitVisualBlock: true},\n    { keys: 'u', type: 'action', action: 'undo', context: 'normal' },\n    { keys: 'u', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, context: 'visual', isEdit: true },\n    { keys: 'U', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, context: 'visual', isEdit: true },\n    { keys: '<C-r>', type: 'action', action: 'redo' },\n    { keys: 'm<character>', type: 'action', action: 'setMark' },\n    { keys: '\"<character>', type: 'action', action: 'setRegister' },\n    { keys: 'zz', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }},\n    { keys: 'z.', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'zt', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }},\n    { keys: 'z<CR>', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'z-', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }},\n    { keys: 'zb', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '.', type: 'action', action: 'repeatLastEdit' },\n    { keys: '<C-a>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: true, backtrack: false}},\n    { keys: '<C-x>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: false, backtrack: false}},\n    { keys: '<C-t>', type: 'action', action: 'indent', actionArgs: { indentRight: true }, context: 'insert' },\n    { keys: '<C-d>', type: 'action', action: 'indent', actionArgs: { indentRight: false }, context: 'insert' },\n    // Text object motions\n    { keys: 'a<character>', type: 'motion', motion: 'textObjectManipulation' },\n    { keys: 'i<character>', type: 'motion', motion: 'textObjectManipulation', motionArgs: { textObjectInner: true }},\n    // Search\n    { keys: '/', type: 'search', searchArgs: { forward: true, querySrc: 'prompt', toJumplist: true }},\n    { keys: '?', type: 'search', searchArgs: { forward: false, querySrc: 'prompt', toJumplist: true }},\n    { keys: '*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: '#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: 'g*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', toJumplist: true }},\n    { keys: 'g#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', toJumplist: true }},\n    // Ex command\n    { keys: ':', type: 'ex' }\n  ];\n  var defaultKeymapLength = defaultKeymap.length;\n\n  /**\n   * Ex commands\n   * Care must be taken when adding to the default Ex command map. For any\n   * pair of commands that have a shared prefix, at least one of their\n   * shortNames must not match the prefix of the other command.\n   */\n  var defaultExCommandMap = [\n    { name: 'colorscheme', shortName: 'colo' },\n    { name: 'map' },\n    { name: 'imap', shortName: 'im' },\n    { name: 'nmap', shortName: 'nm' },\n    { name: 'vmap', shortName: 'vm' },\n    { name: 'unmap' },\n    { name: 'write', shortName: 'w' },\n    { name: 'undo', shortName: 'u' },\n    { name: 'redo', shortName: 'red' },\n    { name: 'set', shortName: 'se' },\n    { name: 'setlocal', shortName: 'setl' },\n    { name: 'setglobal', shortName: 'setg' },\n    { name: 'sort', shortName: 'sor' },\n    { name: 'substitute', shortName: 's', possiblyAsync: true },\n    { name: 'nohlsearch', shortName: 'noh' },\n    { name: 'yank', shortName: 'y' },\n    { name: 'delmarks', shortName: 'delm' },\n    { name: 'registers', shortName: 'reg', excludeFromCommandHistory: true },\n    { name: 'vglobal', shortName: 'v' },\n    { name: 'global', shortName: 'g' }\n  ];\n\n  var Pos = CodeMirror.Pos;\n\n  var Vim = function() {\n    function enterVimMode(cm) {\n      cm.setOption('disableInput', true);\n      cm.setOption('showCursorWhenSelecting', false);\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      cm.on('cursorActivity', onCursorActivity);\n      maybeInitVimState(cm);\n      CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));\n    }\n\n    function leaveVimMode(cm) {\n      cm.setOption('disableInput', false);\n      cm.off('cursorActivity', onCursorActivity);\n      CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));\n      cm.state.vim = null;\n    }\n\n    function detachVimMap(cm, next) {\n      if (this == CodeMirror.keyMap.vim) {\n        CodeMirror.rmClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n        if (cm.getOption(\"inputStyle\") == \"contenteditable\" && document.body.style.caretColor != null) {\n          disableFatCursorMark(cm);\n          cm.getInputField().style.caretColor = \"\";\n        }\n      }\n\n      if (!next || next.attach != attachVimMap)\n        leaveVimMode(cm);\n    }\n    function attachVimMap(cm, prev) {\n      if (this == CodeMirror.keyMap.vim) {\n        CodeMirror.addClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n        if (cm.getOption(\"inputStyle\") == \"contenteditable\" && document.body.style.caretColor != null) {\n          enableFatCursorMark(cm);\n          cm.getInputField().style.caretColor = \"transparent\";\n        }\n      }\n\n      if (!prev || prev.attach != attachVimMap)\n        enterVimMode(cm);\n    }\n\n    function updateFatCursorMark(cm) {\n      if (!cm.state.fatCursorMarks) return;\n      clearFatCursorMark(cm);\n      var ranges = cm.listSelections(), result = []\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n        if (range.empty()) {\n          var lineLength = cm.getLine(range.anchor.line).length;\n          if (range.anchor.ch < lineLength) {\n            result.push(cm.markText(range.anchor, Pos(range.anchor.line, range.anchor.ch + 1),\n                                    {className: \"cm-fat-cursor-mark\"}));\n          } else {\n            result.push(cm.markText(Pos(range.anchor.line, lineLength - 1),\n                                    Pos(range.anchor.line, lineLength),\n                                    {className: \"cm-fat-cursor-mark\"}));\n          }\n        }\n      }\n      cm.state.fatCursorMarks = result;\n    }\n\n    function clearFatCursorMark(cm) {\n      var marks = cm.state.fatCursorMarks;\n      if (marks) for (var i = 0; i < marks.length; i++) marks[i].clear();\n    }\n\n    function enableFatCursorMark(cm) {\n      cm.state.fatCursorMarks = [];\n      updateFatCursorMark(cm)\n      cm.on(\"cursorActivity\", updateFatCursorMark)\n    }\n\n    function disableFatCursorMark(cm) {\n      clearFatCursorMark(cm);\n      cm.off(\"cursorActivity\", updateFatCursorMark);\n      // explicitly set fatCursorMarks to null because event listener above\n      // can be invoke after removing it, if off is called from operation\n      cm.state.fatCursorMarks = null;\n    }\n\n    // Deprecated, simply setting the keymap works again.\n    CodeMirror.defineOption('vimMode', false, function(cm, val, prev) {\n      if (val && cm.getOption(\"keyMap\") != \"vim\")\n        cm.setOption(\"keyMap\", \"vim\");\n      else if (!val && prev != CodeMirror.Init && /^vim/.test(cm.getOption(\"keyMap\")))\n        cm.setOption(\"keyMap\", \"default\");\n    });\n\n    function cmKey(key, cm) {\n      if (!cm) { return undefined; }\n      if (this[key]) { return this[key]; }\n      var vimKey = cmKeyToVimKey(key);\n      if (!vimKey) {\n        return false;\n      }\n      var cmd = CodeMirror.Vim.findKey(cm, vimKey);\n      if (typeof cmd == 'function') {\n        CodeMirror.signal(cm, 'vim-keypress', vimKey);\n      }\n      return cmd;\n    }\n\n    var modifiers = {Shift:'S',Ctrl:'C',Alt:'A',Cmd:'D',Mod:'A',CapsLock:''};\n    var specialKeys = {Enter:'CR',Backspace:'BS',Delete:'Del',Insert:'Ins'};\n    function cmKeyToVimKey(key) {\n      if (key.charAt(0) == '\\'') {\n        // Keypress character binding of format \"'a'\"\n        return key.charAt(1);\n      }\n      var pieces = key.split(/-(?!$)/);\n      var lastPiece = pieces[pieces.length - 1];\n      if (pieces.length == 1 && pieces[0].length == 1) {\n        // No-modifier bindings use literal character bindings above. Skip.\n        return false;\n      } else if (pieces.length == 2 && pieces[0] == 'Shift' && lastPiece.length == 1) {\n        // Ignore Shift+char bindings as they should be handled by literal character.\n        return false;\n      }\n      var hasCharacter = false;\n      for (var i = 0; i < pieces.length; i++) {\n        var piece = pieces[i];\n        if (piece in modifiers) { pieces[i] = modifiers[piece]; }\n        else { hasCharacter = true; }\n        if (piece in specialKeys) { pieces[i] = specialKeys[piece]; }\n      }\n      if (!hasCharacter) {\n        // Vim does not support modifier only keys.\n        return false;\n      }\n      // TODO: Current bindings expect the character to be lower case, but\n      // it looks like vim key notation uses upper case.\n      if (isUpperCase(lastPiece)) {\n        pieces[pieces.length - 1] = lastPiece.toLowerCase();\n      }\n      return '<' + pieces.join('-') + '>';\n    }\n\n    function getOnPasteFn(cm) {\n      var vim = cm.state.vim;\n      if (!vim.onPasteFn) {\n        vim.onPasteFn = function() {\n          if (!vim.insertMode) {\n            cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));\n            actions.enterInsertMode(cm, {}, vim);\n          }\n        };\n      }\n      return vim.onPasteFn;\n    }\n\n    var numberRegex = /[\\d]/;\n    var wordCharTest = [CodeMirror.isWordChar, function(ch) {\n      return ch && !CodeMirror.isWordChar(ch) && !/\\s/.test(ch);\n    }], bigWordCharTest = [function(ch) {\n      return /\\S/.test(ch);\n    }];\n    function makeKeyRange(start, size) {\n      var keys = [];\n      for (var i = start; i < start + size; i++) {\n        keys.push(String.fromCharCode(i));\n      }\n      return keys;\n    }\n    var upperCaseAlphabet = makeKeyRange(65, 26);\n    var lowerCaseAlphabet = makeKeyRange(97, 26);\n    var numbers = makeKeyRange(48, 10);\n    var validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['<', '>']);\n    var validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['-', '\"', '.', ':', '_', '/']);\n    var upperCaseChars;\n    try { upperCaseChars = new RegExp(\"^[\\\\p{Lu}]$\", \"u\"); }\n    catch (_) { upperCaseChars = /^[A-Z]$/; }\n\n    function isLine(cm, line) {\n      return line >= cm.firstLine() && line <= cm.lastLine();\n    }\n    function isLowerCase(k) {\n      return (/^[a-z]$/).test(k);\n    }\n    function isMatchableSymbol(k) {\n      return '()[]{}'.indexOf(k) != -1;\n    }\n    function isNumber(k) {\n      return numberRegex.test(k);\n    }\n    function isUpperCase(k) {\n      return upperCaseChars.test(k);\n    }\n    function isWhiteSpaceString(k) {\n      return (/^\\s*$/).test(k);\n    }\n    function isEndOfSentenceSymbol(k) {\n      return '.?!'.indexOf(k) != -1;\n    }\n    function inArray(val, arr) {\n      for (var i = 0; i < arr.length; i++) {\n        if (arr[i] == val) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    var options = {};\n    function defineOption(name, defaultValue, type, aliases, callback) {\n      if (defaultValue === undefined && !callback) {\n        throw Error('defaultValue is required unless callback is provided');\n      }\n      if (!type) { type = 'string'; }\n      options[name] = {\n        type: type,\n        defaultValue: defaultValue,\n        callback: callback\n      };\n      if (aliases) {\n        for (var i = 0; i < aliases.length; i++) {\n          options[aliases[i]] = options[name];\n        }\n      }\n      if (defaultValue) {\n        setOption(name, defaultValue);\n      }\n    }\n\n    function setOption(name, value, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n      if (option.type == 'boolean') {\n        if (value && value !== true) {\n          return new Error('Invalid argument: ' + name + '=' + value);\n        } else if (value !== false) {\n          // Boolean options are set to true if value is not defined.\n          value = true;\n        }\n      }\n      if (option.callback) {\n        if (scope !== 'local') {\n          option.callback(value, undefined);\n        }\n        if (scope !== 'global' && cm) {\n          option.callback(value, cm);\n        }\n      } else {\n        if (scope !== 'local') {\n          option.value = option.type == 'boolean' ? !!value : value;\n        }\n        if (scope !== 'global' && cm) {\n          cm.state.vim.options[name] = {value: value};\n        }\n      }\n    }\n\n    function getOption(name, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n      if (option.callback) {\n        var local = cm && option.callback(undefined, cm);\n        if (scope !== 'global' && local !== undefined) {\n          return local;\n        }\n        if (scope !== 'local') {\n          return option.callback();\n        }\n        return;\n      } else {\n        var local = (scope !== 'global') && (cm && cm.state.vim.options[name]);\n        return (local || (scope !== 'local') && option || {}).value;\n      }\n    }\n\n    defineOption('filetype', undefined, 'string', ['ft'], function(name, cm) {\n      // Option is local. Do nothing for global.\n      if (cm === undefined) {\n        return;\n      }\n      // The 'filetype' option proxies to the CodeMirror 'mode' option.\n      if (name === undefined) {\n        var mode = cm.getOption('mode');\n        return mode == 'null' ? '' : mode;\n      } else {\n        var mode = name == '' ? 'null' : name;\n        cm.setOption('mode', mode);\n      }\n    });\n\n    var createCircularJumpList = function() {\n      var size = 100;\n      var pointer = -1;\n      var head = 0;\n      var tail = 0;\n      var buffer = new Array(size);\n      function add(cm, oldCur, newCur) {\n        var current = pointer % size;\n        var curMark = buffer[current];\n        function useNextSlot(cursor) {\n          var next = ++pointer % size;\n          var trashMark = buffer[next];\n          if (trashMark) {\n            trashMark.clear();\n          }\n          buffer[next] = cm.setBookmark(cursor);\n        }\n        if (curMark) {\n          var markPos = curMark.find();\n          // avoid recording redundant cursor position\n          if (markPos && !cursorEqual(markPos, oldCur)) {\n            useNextSlot(oldCur);\n          }\n        } else {\n          useNextSlot(oldCur);\n        }\n        useNextSlot(newCur);\n        head = pointer;\n        tail = pointer - size + 1;\n        if (tail < 0) {\n          tail = 0;\n        }\n      }\n      function move(cm, offset) {\n        pointer += offset;\n        if (pointer > head) {\n          pointer = head;\n        } else if (pointer < tail) {\n          pointer = tail;\n        }\n        var mark = buffer[(size + pointer) % size];\n        // skip marks that are temporarily removed from text buffer\n        if (mark && !mark.find()) {\n          var inc = offset > 0 ? 1 : -1;\n          var newCur;\n          var oldCur = cm.getCursor();\n          do {\n            pointer += inc;\n            mark = buffer[(size + pointer) % size];\n            // skip marks that are the same as current position\n            if (mark &&\n                (newCur = mark.find()) &&\n                !cursorEqual(oldCur, newCur)) {\n              break;\n            }\n          } while (pointer < head && pointer > tail);\n        }\n        return mark;\n      }\n      function find(cm, offset) {\n        var oldPointer = pointer;\n        var mark = move(cm, offset);\n        pointer = oldPointer;\n        return mark && mark.find();\n      }\n      return {\n        cachedCursor: undefined, //used for # and * jumps\n        add: add,\n        find: find,\n        move: move\n      };\n    };\n\n    // Returns an object to track the changes associated insert mode.  It\n    // clones the object that is passed in, or creates an empty object one if\n    // none is provided.\n    var createInsertModeChanges = function(c) {\n      if (c) {\n        // Copy construction\n        return {\n          changes: c.changes,\n          expectCursorActivityForChange: c.expectCursorActivityForChange\n        };\n      }\n      return {\n        // Change list\n        changes: [],\n        // Set to true on change, false on cursorActivity.\n        expectCursorActivityForChange: false\n      };\n    };\n\n    function MacroModeState() {\n      this.latestRegister = undefined;\n      this.isPlaying = false;\n      this.isRecording = false;\n      this.replaySearchQueries = [];\n      this.onRecordingDone = undefined;\n      this.lastInsertModeChanges = createInsertModeChanges();\n    }\n    MacroModeState.prototype = {\n      exitMacroRecordMode: function() {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.onRecordingDone) {\n          macroModeState.onRecordingDone(); // close dialog\n        }\n        macroModeState.onRecordingDone = undefined;\n        macroModeState.isRecording = false;\n      },\n      enterMacroRecordMode: function(cm, registerName) {\n        var register =\n            vimGlobalState.registerController.getRegister(registerName);\n        if (register) {\n          register.clear();\n          this.latestRegister = registerName;\n          if (cm.openDialog) {\n            this.onRecordingDone = cm.openDialog(\n                document.createTextNode('(recording)['+registerName+']'), null, {bottom:true});\n          }\n          this.isRecording = true;\n        }\n      }\n    };\n\n    function maybeInitVimState(cm) {\n      if (!cm.state.vim) {\n        // Store instance state in the CodeMirror object.\n        cm.state.vim = {\n          inputState: new InputState(),\n          // Vim's input state that triggered the last edit, used to repeat\n          // motions and operators with '.'.\n          lastEditInputState: undefined,\n          // Vim's action command before the last edit, used to repeat actions\n          // with '.' and insert mode repeat.\n          lastEditActionCommand: undefined,\n          // When using jk for navigation, if you move from a longer line to a\n          // shorter line, the cursor may clip to the end of the shorter line.\n          // If j is pressed again and cursor goes to the next line, the\n          // cursor should go back to its horizontal position on the longer\n          // line if it can. This is to keep track of the horizontal position.\n          lastHPos: -1,\n          // Doing the same with screen-position for gj/gk\n          lastHSPos: -1,\n          // The last motion command run. Cleared if a non-motion command gets\n          // executed in between.\n          lastMotion: null,\n          marks: {},\n          // Mark for rendering fake cursor for visual mode.\n          fakeCursor: null,\n          insertMode: false,\n          // Repeat count for changes made in insert mode, triggered by key\n          // sequences like 3,i. Only exists when insertMode is true.\n          insertModeRepeat: undefined,\n          visualMode: false,\n          // If we are in visual line mode. No effect if visualMode is false.\n          visualLine: false,\n          visualBlock: false,\n          lastSelection: null,\n          lastPastedText: null,\n          sel: {},\n          // Buffer-local/window-local values of vim options.\n          options: {}\n        };\n      }\n      return cm.state.vim;\n    }\n    var vimGlobalState;\n    function resetVimGlobalState() {\n      vimGlobalState = {\n        // The current search query.\n        searchQuery: null,\n        // Whether we are searching backwards.\n        searchIsReversed: false,\n        // Replace part of the last substituted pattern\n        lastSubstituteReplacePart: undefined,\n        jumpList: createCircularJumpList(),\n        macroModeState: new MacroModeState,\n        // Recording latest f, t, F or T motion command.\n        lastCharacterSearch: {increment:0, forward:true, selectedCharacter:''},\n        registerController: new RegisterController({}),\n        // search history buffer\n        searchHistoryController: new HistoryController(),\n        // ex Command history buffer\n        exCommandHistoryController : new HistoryController()\n      };\n      for (var optionName in options) {\n        var option = options[optionName];\n        option.value = option.defaultValue;\n      }\n    }\n\n    var lastInsertModeKeyTimer;\n    var vimApi= {\n      buildKeyMap: function() {\n        // TODO: Convert keymap into dictionary format for fast lookup.\n      },\n      // Testing hook, though it might be useful to expose the register\n      // controller anyway.\n      getRegisterController: function() {\n        return vimGlobalState.registerController;\n      },\n      // Testing hook.\n      resetVimGlobalState_: resetVimGlobalState,\n\n      // Testing hook.\n      getVimGlobalState_: function() {\n        return vimGlobalState;\n      },\n\n      // Testing hook.\n      maybeInitVimState_: maybeInitVimState,\n\n      suppressErrorLogging: false,\n\n      InsertModeKey: InsertModeKey,\n      map: function(lhs, rhs, ctx) {\n        // Add user defined key bindings.\n        exCommandDispatcher.map(lhs, rhs, ctx);\n      },\n      unmap: function(lhs, ctx) {\n        exCommandDispatcher.unmap(lhs, ctx);\n      },\n      // Non-recursive map function.\n      // NOTE: This will not create mappings to key maps that aren't present\n      // in the default key map. See TODO at bottom of function.\n      noremap: function(lhs, rhs, ctx) {\n        function toCtxArray(ctx) {\n          return ctx ? [ctx] : ['normal', 'insert', 'visual'];\n        }\n        var ctxsToMap = toCtxArray(ctx);\n        // Look through all actual defaults to find a map candidate.\n        var actualLength = defaultKeymap.length, origLength = defaultKeymapLength;\n        for (var i = actualLength - origLength;\n             i < actualLength && ctxsToMap.length;\n             i++) {\n          var mapping = defaultKeymap[i];\n          // Omit mappings that operate in the wrong context(s) and those of invalid type.\n          if (mapping.keys == rhs &&\n              (!ctx || !mapping.context || mapping.context === ctx) &&\n              mapping.type.substr(0, 2) !== 'ex' &&\n              mapping.type.substr(0, 3) !== 'key') {\n            // Make a shallow copy of the original keymap entry.\n            var newMapping = {};\n            for (var key in mapping) {\n              newMapping[key] = mapping[key];\n            }\n            // Modify it point to the new mapping with the proper context.\n            newMapping.keys = lhs;\n            if (ctx && !newMapping.context) {\n              newMapping.context = ctx;\n            }\n            // Add it to the keymap with a higher priority than the original.\n            this._mapCommand(newMapping);\n            // Record the mapped contexts as complete.\n            var mappedCtxs = toCtxArray(mapping.context);\n            ctxsToMap = ctxsToMap.filter(function(el) { return mappedCtxs.indexOf(el) === -1; });\n          }\n        }\n        // TODO: Create non-recursive keyToKey mappings for the unmapped contexts once those exist.\n      },\n      // Remove all user-defined mappings for the provided context.\n      mapclear: function(ctx) {\n        // Partition the existing keymap into user-defined and true defaults.\n        var actualLength = defaultKeymap.length,\n            origLength = defaultKeymapLength;\n        var userKeymap = defaultKeymap.slice(0, actualLength - origLength);\n        defaultKeymap = defaultKeymap.slice(actualLength - origLength);\n        if (ctx) {\n          // If a specific context is being cleared, we need to keep mappings\n          // from all other contexts.\n          for (var i = userKeymap.length - 1; i >= 0; i--) {\n            var mapping = userKeymap[i];\n            if (ctx !== mapping.context) {\n              if (mapping.context) {\n                this._mapCommand(mapping);\n              } else {\n                // `mapping` applies to all contexts so create keymap copies\n                // for each context except the one being cleared.\n                var contexts = ['normal', 'insert', 'visual'];\n                for (var j in contexts) {\n                  if (contexts[j] !== ctx) {\n                    var newMapping = {};\n                    for (var key in mapping) {\n                      newMapping[key] = mapping[key];\n                    }\n                    newMapping.context = contexts[j];\n                    this._mapCommand(newMapping);\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n      // TODO: Expose setOption and getOption as instance methods. Need to decide how to namespace\n      // them, or somehow make them work with the existing CodeMirror setOption/getOption API.\n      setOption: setOption,\n      getOption: getOption,\n      defineOption: defineOption,\n      defineEx: function(name, prefix, func){\n        if (!prefix) {\n          prefix = name;\n        } else if (name.indexOf(prefix) !== 0) {\n          throw new Error('(Vim.defineEx) \"'+prefix+'\" is not a prefix of \"'+name+'\", command not registered');\n        }\n        exCommands[name]=func;\n        exCommandDispatcher.commandMap_[prefix]={name:name, shortName:prefix, type:'api'};\n      },\n      handleKey: function (cm, key, origin) {\n        var command = this.findKey(cm, key, origin);\n        if (typeof command === 'function') {\n          return command();\n        }\n      },\n      /**\n       * This is the outermost function called by CodeMirror, after keys have\n       * been mapped to their Vim equivalents.\n       *\n       * Finds a command based on the key (and cached keys if there is a\n       * multi-key sequence). Returns `undefined` if no key is matched, a noop\n       * function if a partial match is found (multi-key), and a function to\n       * execute the bound command if a a key is matched. The function always\n       * returns true.\n       */\n      findKey: function(cm, key, origin) {\n        var vim = maybeInitVimState(cm);\n        function handleMacroRecording() {\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            if (key == 'q') {\n              macroModeState.exitMacroRecordMode();\n              clearInputState(cm);\n              return true;\n            }\n            if (origin != 'mapping') {\n              logKey(macroModeState, key);\n            }\n          }\n        }\n        function handleEsc() {\n          if (key == '<Esc>') {\n            // Clear input state and get back to normal mode.\n            clearInputState(cm);\n            if (vim.visualMode) {\n              exitVisualMode(cm);\n            } else if (vim.insertMode) {\n              exitInsertMode(cm);\n            }\n            return true;\n          }\n        }\n        function doKeyToKey(keys) {\n          // TODO: prevent infinite recursion.\n          var match;\n          while (keys) {\n            // Pull off one command key, which is either a single character\n            // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n            match = (/<\\w+-.+?>|<\\w+>|./).exec(keys);\n            key = match[0];\n            keys = keys.substring(match.index + key.length);\n            CodeMirror.Vim.handleKey(cm, key, 'mapping');\n          }\n        }\n\n        function handleKeyInsertMode() {\n          if (handleEsc()) { return true; }\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n          var keysAreChars = key.length == 1;\n          var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n          // Need to check all key substrings in insert mode.\n          while (keys.length > 1 && match.type != 'full') {\n            var keys = vim.inputState.keyBuffer = keys.slice(1);\n            var thisMatch = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n            if (thisMatch.type != 'none') { match = thisMatch; }\n          }\n          if (match.type == 'none') { clearInputState(cm); return false; }\n          else if (match.type == 'partial') {\n            if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n            lastInsertModeKeyTimer = window.setTimeout(\n              function() { if (vim.insertMode && vim.inputState.keyBuffer) { clearInputState(cm); } },\n              getOption('insertModeEscKeysTimeout'));\n            return !keysAreChars;\n          }\n\n          if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n          if (keysAreChars) {\n            var selections = cm.listSelections();\n            for (var i = 0; i < selections.length; i++) {\n              var here = selections[i].head;\n              cm.replaceRange('', offsetCursor(here, 0, -(keys.length - 1)), here, '+input');\n            }\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();\n          }\n          clearInputState(cm);\n          return match.command;\n        }\n\n        function handleKeyNonInsertMode() {\n          if (handleMacroRecording() || handleEsc()) { return true; }\n\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n          if (/^[1-9]\\d*$/.test(keys)) { return true; }\n\n          var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (!keysMatcher) { clearInputState(cm); return false; }\n          var context = vim.visualMode ? 'visual' :\n                                         'normal';\n          var mainKey = keysMatcher[2] || keysMatcher[1];\n          if (vim.inputState.operatorShortcut && vim.inputState.operatorShortcut.slice(-1) == mainKey) {\n            // multikey operators act linewise by repeating only the last character\n            mainKey = vim.inputState.operatorShortcut;\n          }\n          var match = commandDispatcher.matchCommand(mainKey, defaultKeymap, vim.inputState, context);\n          if (match.type == 'none') { clearInputState(cm); return false; }\n          else if (match.type == 'partial') { return true; }\n\n          vim.inputState.keyBuffer = '';\n          var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (keysMatcher[1] && keysMatcher[1] != '0') {\n            vim.inputState.pushRepeatDigit(keysMatcher[1]);\n          }\n          return match.command;\n        }\n\n        var command;\n        if (vim.insertMode) { command = handleKeyInsertMode(); }\n        else { command = handleKeyNonInsertMode(); }\n        if (command === false) {\n          return !vim.insertMode && key.length === 1 ? function() { return true; } : undefined;\n        } else if (command === true) {\n          // TODO: Look into using CodeMirror's multi-key handling.\n          // Return no-op since we are caching the key. Counts as handled, but\n          // don't want act on it just yet.\n          return function() { return true; };\n        } else {\n          return function() {\n            return cm.operation(function() {\n              cm.curOp.isVimOp = true;\n              try {\n                if (command.type == 'keyToKey') {\n                  doKeyToKey(command.toKeys);\n                } else {\n                  commandDispatcher.processCommand(cm, vim, command);\n                }\n              } catch (e) {\n                // clear VIM state in case it's in a bad state.\n                cm.state.vim = undefined;\n                maybeInitVimState(cm);\n                if (!CodeMirror.Vim.suppressErrorLogging) {\n                  console['log'](e);\n                }\n                throw e;\n              }\n              return true;\n            });\n          };\n        }\n      },\n      handleEx: function(cm, input) {\n        exCommandDispatcher.processCommand(cm, input);\n      },\n\n      defineMotion: defineMotion,\n      defineAction: defineAction,\n      defineOperator: defineOperator,\n      mapCommand: mapCommand,\n      _mapCommand: _mapCommand,\n\n      defineRegister: defineRegister,\n\n      exitVisualMode: exitVisualMode,\n      exitInsertMode: exitInsertMode\n    };\n\n    // Represents the current input state.\n    function InputState() {\n      this.prefixRepeat = [];\n      this.motionRepeat = [];\n\n      this.operator = null;\n      this.operatorArgs = null;\n      this.motion = null;\n      this.motionArgs = null;\n      this.keyBuffer = []; // For matching multi-key commands.\n      this.registerName = null; // Defaults to the unnamed register.\n    }\n    InputState.prototype.pushRepeatDigit = function(n) {\n      if (!this.operator) {\n        this.prefixRepeat = this.prefixRepeat.concat(n);\n      } else {\n        this.motionRepeat = this.motionRepeat.concat(n);\n      }\n    };\n    InputState.prototype.getRepeat = function() {\n      var repeat = 0;\n      if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\n        repeat = 1;\n        if (this.prefixRepeat.length > 0) {\n          repeat *= parseInt(this.prefixRepeat.join(''), 10);\n        }\n        if (this.motionRepeat.length > 0) {\n          repeat *= parseInt(this.motionRepeat.join(''), 10);\n        }\n      }\n      return repeat;\n    };\n\n    function clearInputState(cm, reason) {\n      cm.state.vim.inputState = new InputState();\n      CodeMirror.signal(cm, 'vim-command-done', reason);\n    }\n\n    /*\n     * Register stores information about copy and paste registers.  Besides\n     * text, a register must store whether it is linewise (i.e., when it is\n     * pasted, should it insert itself into a new line, or should the text be\n     * inserted at the cursor position.)\n     */\n    function Register(text, linewise, blockwise) {\n      this.clear();\n      this.keyBuffer = [text || ''];\n      this.insertModeChanges = [];\n      this.searchQueries = [];\n      this.linewise = !!linewise;\n      this.blockwise = !!blockwise;\n    }\n    Register.prototype = {\n      setText: function(text, linewise, blockwise) {\n        this.keyBuffer = [text || ''];\n        this.linewise = !!linewise;\n        this.blockwise = !!blockwise;\n      },\n      pushText: function(text, linewise) {\n        // if this register has ever been set to linewise, use linewise.\n        if (linewise) {\n          if (!this.linewise) {\n            this.keyBuffer.push('\\n');\n          }\n          this.linewise = true;\n        }\n        this.keyBuffer.push(text);\n      },\n      pushInsertModeChanges: function(changes) {\n        this.insertModeChanges.push(createInsertModeChanges(changes));\n      },\n      pushSearchQuery: function(query) {\n        this.searchQueries.push(query);\n      },\n      clear: function() {\n        this.keyBuffer = [];\n        this.insertModeChanges = [];\n        this.searchQueries = [];\n        this.linewise = false;\n      },\n      toString: function() {\n        return this.keyBuffer.join('');\n      }\n    };\n\n    /**\n     * Defines an external register.\n     *\n     * The name should be a single character that will be used to reference the register.\n     * The register should support setText, pushText, clear, and toString(). See Register\n     * for a reference implementation.\n     */\n    function defineRegister(name, register) {\n      var registers = vimGlobalState.registerController.registers;\n      if (!name || name.length != 1) {\n        throw Error('Register name must be 1 character');\n      }\n      if (registers[name]) {\n        throw Error('Register already defined ' + name);\n      }\n      registers[name] = register;\n      validRegisters.push(name);\n    }\n\n    /*\n     * vim registers allow you to keep many independent copy and paste buffers.\n     * See http://usevim.com/2012/04/13/registers/ for an introduction.\n     *\n     * RegisterController keeps the state of all the registers.  An initial\n     * state may be passed in.  The unnamed register '\"' will always be\n     * overridden.\n     */\n    function RegisterController(registers) {\n      this.registers = registers;\n      this.unnamedRegister = registers['\"'] = new Register();\n      registers['.'] = new Register();\n      registers[':'] = new Register();\n      registers['/'] = new Register();\n    }\n    RegisterController.prototype = {\n      pushText: function(registerName, operator, text, linewise, blockwise) {\n        // The black hole register, \"_, means delete/yank to nowhere.\n        if (registerName === '_') return;\n        if (linewise && text.charAt(text.length - 1) !== '\\n'){\n          text += '\\n';\n        }\n        // Lowercase and uppercase registers refer to the same register.\n        // Uppercase just means append.\n        var register = this.isValidRegister(registerName) ?\n            this.getRegister(registerName) : null;\n        // if no register/an invalid register was specified, things go to the\n        // default registers\n        if (!register) {\n          switch (operator) {\n            case 'yank':\n              // The 0 register contains the text from the most recent yank.\n              this.registers['0'] = new Register(text, linewise, blockwise);\n              break;\n            case 'delete':\n            case 'change':\n              if (text.indexOf('\\n') == -1) {\n                // Delete less than 1 line. Update the small delete register.\n                this.registers['-'] = new Register(text, linewise);\n              } else {\n                // Shift down the contents of the numbered registers and put the\n                // deleted text into register 1.\n                this.shiftNumericRegisters_();\n                this.registers['1'] = new Register(text, linewise);\n              }\n              break;\n          }\n          // Make sure the unnamed register is set to what just happened\n          this.unnamedRegister.setText(text, linewise, blockwise);\n          return;\n        }\n\n        // If we've gotten to this point, we've actually specified a register\n        var append = isUpperCase(registerName);\n        if (append) {\n          register.pushText(text, linewise);\n        } else {\n          register.setText(text, linewise, blockwise);\n        }\n        // The unnamed register always has the same value as the last used\n        // register.\n        this.unnamedRegister.setText(register.toString(), linewise);\n      },\n      // Gets the register named @name.  If one of @name doesn't already exist,\n      // create it.  If @name is invalid, return the unnamedRegister.\n      getRegister: function(name) {\n        if (!this.isValidRegister(name)) {\n          return this.unnamedRegister;\n        }\n        name = name.toLowerCase();\n        if (!this.registers[name]) {\n          this.registers[name] = new Register();\n        }\n        return this.registers[name];\n      },\n      isValidRegister: function(name) {\n        return name && inArray(name, validRegisters);\n      },\n      shiftNumericRegisters_: function() {\n        for (var i = 9; i >= 2; i--) {\n          this.registers[i] = this.getRegister('' + (i - 1));\n        }\n      }\n    };\n    function HistoryController() {\n        this.historyBuffer = [];\n        this.iterator = 0;\n        this.initialPrefix = null;\n    }\n    HistoryController.prototype = {\n      // the input argument here acts a user entered prefix for a small time\n      // until we start autocompletion in which case it is the autocompleted.\n      nextMatch: function (input, up) {\n        var historyBuffer = this.historyBuffer;\n        var dir = up ? -1 : 1;\n        if (this.initialPrefix === null) this.initialPrefix = input;\n        for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i+= dir) {\n          var element = historyBuffer[i];\n          for (var j = 0; j <= element.length; j++) {\n            if (this.initialPrefix == element.substring(0, j)) {\n              this.iterator = i;\n              return element;\n            }\n          }\n        }\n        // should return the user input in case we reach the end of buffer.\n        if (i >= historyBuffer.length) {\n          this.iterator = historyBuffer.length;\n          return this.initialPrefix;\n        }\n        // return the last autocompleted query or exCommand as it is.\n        if (i < 0 ) return input;\n      },\n      pushInput: function(input) {\n        var index = this.historyBuffer.indexOf(input);\n        if (index > -1) this.historyBuffer.splice(index, 1);\n        if (input.length) this.historyBuffer.push(input);\n      },\n      reset: function() {\n        this.initialPrefix = null;\n        this.iterator = this.historyBuffer.length;\n      }\n    };\n    var commandDispatcher = {\n      matchCommand: function(keys, keyMap, inputState, context) {\n        var matches = commandMatches(keys, keyMap, context, inputState);\n        if (!matches.full && !matches.partial) {\n          return {type: 'none'};\n        } else if (!matches.full && matches.partial) {\n          return {type: 'partial'};\n        }\n\n        var bestMatch;\n        for (var i = 0; i < matches.full.length; i++) {\n          var match = matches.full[i];\n          if (!bestMatch) {\n            bestMatch = match;\n          }\n        }\n        if (bestMatch.keys.slice(-11) == '<character>') {\n          var character = lastChar(keys);\n          if (!character) return {type: 'none'};\n          inputState.selectedCharacter = character;\n        }\n        return {type: 'full', command: bestMatch};\n      },\n      processCommand: function(cm, vim, command) {\n        vim.inputState.repeatOverride = command.repeatOverride;\n        switch (command.type) {\n          case 'motion':\n            this.processMotion(cm, vim, command);\n            break;\n          case 'operator':\n            this.processOperator(cm, vim, command);\n            break;\n          case 'operatorMotion':\n            this.processOperatorMotion(cm, vim, command);\n            break;\n          case 'action':\n            this.processAction(cm, vim, command);\n            break;\n          case 'search':\n            this.processSearch(cm, vim, command);\n            break;\n          case 'ex':\n          case 'keyToEx':\n            this.processEx(cm, vim, command);\n            break;\n          default:\n            break;\n        }\n      },\n      processMotion: function(cm, vim, command) {\n        vim.inputState.motion = command.motion;\n        vim.inputState.motionArgs = copyArgs(command.motionArgs);\n        this.evalInput(cm, vim);\n      },\n      processOperator: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        if (inputState.operator) {\n          if (inputState.operator == command.operator) {\n            // Typing an operator twice like 'dd' makes the operator operate\n            // linewise\n            inputState.motion = 'expandToLine';\n            inputState.motionArgs = { linewise: true };\n            this.evalInput(cm, vim);\n            return;\n          } else {\n            // 2 different operators in a row doesn't make sense.\n            clearInputState(cm);\n          }\n        }\n        inputState.operator = command.operator;\n        inputState.operatorArgs = copyArgs(command.operatorArgs);\n        if (command.keys.length > 1) {\n          inputState.operatorShortcut = command.keys;\n        }\n        if (command.exitVisualBlock) {\n            vim.visualBlock = false;\n            updateCmSelection(cm);\n        }\n        if (vim.visualMode) {\n          // Operating on a selection in visual mode. We don't need a motion.\n          this.evalInput(cm, vim);\n        }\n      },\n      processOperatorMotion: function(cm, vim, command) {\n        var visualMode = vim.visualMode;\n        var operatorMotionArgs = copyArgs(command.operatorMotionArgs);\n        if (operatorMotionArgs) {\n          // Operator motions may have special behavior in visual mode.\n          if (visualMode && operatorMotionArgs.visualLine) {\n            vim.visualLine = true;\n          }\n        }\n        this.processOperator(cm, vim, command);\n        if (!visualMode) {\n          this.processMotion(cm, vim, command);\n        }\n      },\n      processAction: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        var repeat = inputState.getRepeat();\n        var repeatIsExplicit = !!repeat;\n        var actionArgs = copyArgs(command.actionArgs) || {};\n        if (inputState.selectedCharacter) {\n          actionArgs.selectedCharacter = inputState.selectedCharacter;\n        }\n        // Actions may or may not have motions and operators. Do these first.\n        if (command.operator) {\n          this.processOperator(cm, vim, command);\n        }\n        if (command.motion) {\n          this.processMotion(cm, vim, command);\n        }\n        if (command.motion || command.operator) {\n          this.evalInput(cm, vim);\n        }\n        actionArgs.repeat = repeat || 1;\n        actionArgs.repeatIsExplicit = repeatIsExplicit;\n        actionArgs.registerName = inputState.registerName;\n        clearInputState(cm);\n        vim.lastMotion = null;\n        if (command.isEdit) {\n          this.recordLastEdit(vim, inputState, command);\n        }\n        actions[command.action](cm, actionArgs, vim);\n      },\n      processSearch: function(cm, vim, command) {\n        if (!cm.getSearchCursor) {\n          // Search depends on SearchCursor.\n          return;\n        }\n        var forward = command.searchArgs.forward;\n        var wholeWordOnly = command.searchArgs.wholeWordOnly;\n        getSearchState(cm).setReversed(!forward);\n        var promptPrefix = (forward) ? '/' : '?';\n        var originalQuery = getSearchState(cm).getQuery();\n        var originalScrollPos = cm.getScrollInfo();\n        function handleQuery(query, ignoreCase, smartCase) {\n          vimGlobalState.searchHistoryController.pushInput(query);\n          vimGlobalState.searchHistoryController.reset();\n          try {\n            updateSearchQuery(cm, query, ignoreCase, smartCase);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + query);\n            clearInputState(cm);\n            return;\n          }\n          commandDispatcher.processMotion(cm, vim, {\n            type: 'motion',\n            motion: 'findNext',\n            motionArgs: { forward: true, toJumplist: command.searchArgs.toJumplist }\n          });\n        }\n        function onPromptClose(query) {\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          handleQuery(query, true /** ignoreCase */, true /** smartCase */);\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            logSearchQuery(macroModeState, query);\n          }\n        }\n        function onPromptKeyUp(e, query, close) {\n          var keyName = CodeMirror.keyName(e), up, offset;\n          if (keyName == 'Up' || keyName == 'Down') {\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';\n            close(query);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else {\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n              vimGlobalState.searchHistoryController.reset();\n          }\n          var parsedQuery;\n          try {\n            parsedQuery = updateSearchQuery(cm, query,\n                true /** ignoreCase */, true /** smartCase */);\n          } catch (e) {\n            // Swallow bad regexes for incremental search.\n          }\n          if (parsedQuery) {\n            cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);\n          } else {\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          }\n        }\n        function onPromptKeyDown(e, query, close) {\n          var keyName = CodeMirror.keyName(e);\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n              (keyName == 'Backspace' && query == '')) {\n            vimGlobalState.searchHistoryController.pushInput(query);\n            vimGlobalState.searchHistoryController.reset();\n            updateSearchQuery(cm, originalQuery);\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          } else if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          }\n        }\n        switch (command.searchArgs.querySrc) {\n          case 'prompt':\n            var macroModeState = vimGlobalState.macroModeState;\n            if (macroModeState.isPlaying) {\n              var query = macroModeState.replaySearchQueries.shift();\n              handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            } else {\n              showPrompt(cm, {\n                  onClose: onPromptClose,\n                  prefix: promptPrefix,\n                  desc: '(JavaScript regexp)',\n                  onKeyUp: onPromptKeyUp,\n                  onKeyDown: onPromptKeyDown\n              });\n            }\n            break;\n          case 'wordUnderCursor':\n            var word = expandWordUnderCursor(cm, false /** inclusive */,\n                true /** forward */, false /** bigWord */,\n                true /** noSymbol */);\n            var isKeyword = true;\n            if (!word) {\n              word = expandWordUnderCursor(cm, false /** inclusive */,\n                  true /** forward */, false /** bigWord */,\n                  false /** noSymbol */);\n              isKeyword = false;\n            }\n            if (!word) {\n              return;\n            }\n            var query = cm.getLine(word.start.line).substring(word.start.ch,\n                word.end.ch);\n            if (isKeyword && wholeWordOnly) {\n                query = '\\\\b' + query + '\\\\b';\n            } else {\n              query = escapeRegex(query);\n            }\n\n            // cachedCursor is used to save the old position of the cursor\n            // when * or # causes vim to seek for the nearest word and shift\n            // the cursor before entering the motion.\n            vimGlobalState.jumpList.cachedCursor = cm.getCursor();\n            cm.setCursor(word.start);\n\n            handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            break;\n        }\n      },\n      processEx: function(cm, vim, command) {\n        function onPromptClose(input) {\n          // Give the prompt some time to close so that if processCommand shows\n          // an error, the elements don't overlap.\n          vimGlobalState.exCommandHistoryController.pushInput(input);\n          vimGlobalState.exCommandHistoryController.reset();\n          exCommandDispatcher.processCommand(cm, input);\n        }\n        function onPromptKeyDown(e, input, close) {\n          var keyName = CodeMirror.keyName(e), up, offset;\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n              (keyName == 'Backspace' && input == '')) {\n            vimGlobalState.exCommandHistoryController.pushInput(input);\n            vimGlobalState.exCommandHistoryController.reset();\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          }\n          if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';\n            close(input);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          } else {\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n              vimGlobalState.exCommandHistoryController.reset();\n          }\n        }\n        if (command.type == 'keyToEx') {\n          // Handle user defined Ex to Ex mappings\n          exCommandDispatcher.processCommand(cm, command.exArgs.input);\n        } else {\n          if (vim.visualMode) {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':', value: '\\'<,\\'>',\n                onKeyDown: onPromptKeyDown, selectValueOnOpen: false});\n          } else {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':',\n                onKeyDown: onPromptKeyDown});\n          }\n        }\n      },\n      evalInput: function(cm, vim) {\n        // If the motion command is set, execute both the operator and motion.\n        // Otherwise return.\n        var inputState = vim.inputState;\n        var motion = inputState.motion;\n        var motionArgs = inputState.motionArgs || {};\n        var operator = inputState.operator;\n        var operatorArgs = inputState.operatorArgs || {};\n        var registerName = inputState.registerName;\n        var sel = vim.sel;\n        // TODO: Make sure cm and vim selections are identical outside visual mode.\n        var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head): cm.getCursor('head'));\n        var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));\n        var oldHead = copyCursor(origHead);\n        var oldAnchor = copyCursor(origAnchor);\n        var newHead, newAnchor;\n        var repeat;\n        if (operator) {\n          this.recordLastEdit(vim, inputState);\n        }\n        if (inputState.repeatOverride !== undefined) {\n          // If repeatOverride is specified, that takes precedence over the\n          // input state's repeat. Used by Ex mode and can be user defined.\n          repeat = inputState.repeatOverride;\n        } else {\n          repeat = inputState.getRepeat();\n        }\n        if (repeat > 0 && motionArgs.explicitRepeat) {\n          motionArgs.repeatIsExplicit = true;\n        } else if (motionArgs.noRepeat ||\n            (!motionArgs.explicitRepeat && repeat === 0)) {\n          repeat = 1;\n          motionArgs.repeatIsExplicit = false;\n        }\n        if (inputState.selectedCharacter) {\n          // If there is a character input, stick it in all of the arg arrays.\n          motionArgs.selectedCharacter = operatorArgs.selectedCharacter =\n              inputState.selectedCharacter;\n        }\n        motionArgs.repeat = repeat;\n        clearInputState(cm);\n        if (motion) {\n          var motionResult = motions[motion](cm, origHead, motionArgs, vim, inputState);\n          vim.lastMotion = motions[motion];\n          if (!motionResult) {\n            return;\n          }\n          if (motionArgs.toJumplist) {\n            var jumpList = vimGlobalState.jumpList;\n            // if the current motion is # or *, use cachedCursor\n            var cachedCursor = jumpList.cachedCursor;\n            if (cachedCursor) {\n              recordJumpPosition(cm, cachedCursor, motionResult);\n              delete jumpList.cachedCursor;\n            } else {\n              recordJumpPosition(cm, origHead, motionResult);\n            }\n          }\n          if (motionResult instanceof Array) {\n            newAnchor = motionResult[0];\n            newHead = motionResult[1];\n          } else {\n            newHead = motionResult;\n          }\n          // TODO: Handle null returns from motion commands better.\n          if (!newHead) {\n            newHead = copyCursor(origHead);\n          }\n          if (vim.visualMode) {\n            if (!(vim.visualBlock && newHead.ch === Infinity)) {\n              newHead = clipCursorToContent(cm, newHead);\n            }\n            if (newAnchor) {\n              newAnchor = clipCursorToContent(cm, newAnchor);\n            }\n            newAnchor = newAnchor || oldAnchor;\n            sel.anchor = newAnchor;\n            sel.head = newHead;\n            updateCmSelection(cm);\n            updateMark(cm, vim, '<',\n                cursorIsBefore(newAnchor, newHead) ? newAnchor\n                    : newHead);\n            updateMark(cm, vim, '>',\n                cursorIsBefore(newAnchor, newHead) ? newHead\n                    : newAnchor);\n          } else if (!operator) {\n            newHead = clipCursorToContent(cm, newHead);\n            cm.setCursor(newHead.line, newHead.ch);\n          }\n        }\n        if (operator) {\n          if (operatorArgs.lastSel) {\n            // Replaying a visual mode operation\n            newAnchor = oldAnchor;\n            var lastSel = operatorArgs.lastSel;\n            var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);\n            var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);\n            if (lastSel.visualLine) {\n              // Linewise Visual mode: The same number of lines.\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            } else if (lastSel.visualBlock) {\n              // Blockwise Visual mode: The same number of lines and columns.\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);\n            } else if (lastSel.head.line == lastSel.anchor.line) {\n              // Normal Visual mode within one line: The same number of characters.\n              newHead = Pos(oldAnchor.line, oldAnchor.ch + chOffset);\n            } else {\n              // Normal Visual mode with several lines: The same number of lines, in the\n              // last line the same number of characters as in the last line the last time.\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            }\n            vim.visualMode = true;\n            vim.visualLine = lastSel.visualLine;\n            vim.visualBlock = lastSel.visualBlock;\n            sel = vim.sel = {\n              anchor: newAnchor,\n              head: newHead\n            };\n            updateCmSelection(cm);\n          } else if (vim.visualMode) {\n            operatorArgs.lastSel = {\n              anchor: copyCursor(sel.anchor),\n              head: copyCursor(sel.head),\n              visualBlock: vim.visualBlock,\n              visualLine: vim.visualLine\n            };\n          }\n          var curStart, curEnd, linewise, mode;\n          var cmSel;\n          if (vim.visualMode) {\n            // Init visual op\n            curStart = cursorMin(sel.head, sel.anchor);\n            curEnd = cursorMax(sel.head, sel.anchor);\n            linewise = vim.visualLine || operatorArgs.linewise;\n            mode = vim.visualBlock ? 'block' :\n                   linewise ? 'line' :\n                   'char';\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode);\n            if (linewise) {\n              var ranges = cmSel.ranges;\n              if (mode == 'block') {\n                // Linewise operators in visual block mode extend to end of line\n                for (var i = 0; i < ranges.length; i++) {\n                  ranges[i].head.ch = lineLength(cm, ranges[i].head.line);\n                }\n              } else if (mode == 'line') {\n                ranges[0].head = Pos(ranges[0].head.line + 1, 0);\n              }\n            }\n          } else {\n            // Init motion op\n            curStart = copyCursor(newAnchor || oldAnchor);\n            curEnd = copyCursor(newHead || oldHead);\n            if (cursorIsBefore(curEnd, curStart)) {\n              var tmp = curStart;\n              curStart = curEnd;\n              curEnd = tmp;\n            }\n            linewise = motionArgs.linewise || operatorArgs.linewise;\n            if (linewise) {\n              // Expand selection to entire line.\n              expandSelectionToLine(cm, curStart, curEnd);\n            } else if (motionArgs.forward) {\n              // Clip to trailing newlines only if the motion goes forward.\n              clipToLine(cm, curStart, curEnd);\n            }\n            mode = 'char';\n            var exclusive = !motionArgs.inclusive || linewise;\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode, exclusive);\n          }\n          cm.setSelections(cmSel.ranges, cmSel.primary);\n          vim.lastMotion = null;\n          operatorArgs.repeat = repeat; // For indent in visual mode.\n          operatorArgs.registerName = registerName;\n          // Keep track of linewise as it affects how paste and change behave.\n          operatorArgs.linewise = linewise;\n          var operatorMoveTo = operators[operator](\n            cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);\n          if (vim.visualMode) {\n            exitVisualMode(cm, operatorMoveTo != null);\n          }\n          if (operatorMoveTo) {\n            cm.setCursor(operatorMoveTo);\n          }\n        }\n      },\n      recordLastEdit: function(vim, inputState, actionCommand) {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) { return; }\n        vim.lastEditInputState = inputState;\n        vim.lastEditActionCommand = actionCommand;\n        macroModeState.lastInsertModeChanges.changes = [];\n        macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;\n        macroModeState.lastInsertModeChanges.visualBlock = vim.visualBlock ? vim.sel.head.line - vim.sel.anchor.line : 0;\n      }\n    };\n\n    /**\n     * typedef {Object{line:number,ch:number}} Cursor An object containing the\n     *     position of the cursor.\n     */\n    // All of the functions below return Cursor objects.\n    var motions = {\n      moveToTopLine: function(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).top + motionArgs.repeat -1;\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToMiddleLine: function(cm) {\n        var range = getUserVisibleLines(cm);\n        var line = Math.floor((range.top + range.bottom) * 0.5);\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToBottomLine: function(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).bottom - motionArgs.repeat +1;\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      expandToLine: function(_cm, head, motionArgs) {\n        // Expands forward to end of line, and then to next line if repeat is\n        // >1. Does not handle backward motion!\n        var cur = head;\n        return Pos(cur.line + motionArgs.repeat - 1, Infinity);\n      },\n      findNext: function(cm, _head, motionArgs) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        if (!query) {\n          return;\n        }\n        var prev = !motionArgs.forward;\n        // If search is initiated with ? instead of /, negate direction.\n        prev = (state.isReversed()) ? !prev : prev;\n        highlightSearchMatches(cm, query);\n        return findNext(cm, prev/** prev */, query, motionArgs.repeat);\n      },\n      /**\n       * Find and select the next occurrence of the search query. If the cursor is currently\n       * within a match, then find and select the current match. Otherwise, find the next occurrence in the\n       * appropriate direction.\n       *\n       * This differs from `findNext` in the following ways:\n       *\n       * 1. Instead of only returning the \"from\", this returns a \"from\", \"to\" range.\n       * 2. If the cursor is currently inside a search match, this selects the current match\n       *    instead of the next match.\n       * 3. If there is no associated operator, this will turn on visual mode.\n       */\n      findAndSelectNextInclusive: function(cm, _head, motionArgs, vim, prevInputState) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n\n        if (!query) {\n          return;\n        }\n\n        var prev = !motionArgs.forward;\n        prev = (state.isReversed()) ? !prev : prev;\n\n        // next: [from, to] | null\n        var next = findNextFromAndToInclusive(cm, prev, query, motionArgs.repeat, vim);\n\n        // No matches.\n        if (!next) {\n          return;\n        }\n\n        // If there's an operator that will be executed, return the selection.\n        if (prevInputState.operator) {\n          return next;\n        }\n\n        // At this point, we know that there is no accompanying operator -- let's\n        // deal with visual mode in order to select an appropriate match.\n\n        var from = next[0];\n        // For whatever reason, when we use the \"to\" as returned by searchcursor.js directly,\n        // the resulting selection is extended by 1 char. Let's shrink it so that only the\n        // match is selected.\n        var to = Pos(next[1].line, next[1].ch - 1);\n\n        if (vim.visualMode) {\n          // If we were in visualLine or visualBlock mode, get out of it.\n          if (vim.visualLine || vim.visualBlock) {\n            vim.visualLine = false;\n            vim.visualBlock = false;\n            CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: \"\"});\n          }\n\n          // If we're currently in visual mode, we should extend the selection to include\n          // the search result.\n          var anchor = vim.sel.anchor;\n          if (anchor) {\n            if (state.isReversed()) {\n              if (motionArgs.forward) {\n                return [anchor, from];\n              }\n\n              return [anchor, to];\n            } else {\n              if (motionArgs.forward) {\n                return [anchor, to];\n              }\n\n              return [anchor, from];\n            }\n          }\n        } else {\n          // Let's turn visual mode on.\n          vim.visualMode = true;\n          vim.visualLine = false;\n          vim.visualBlock = false;\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: \"\"});\n        }\n\n        return prev ? [to, from] : [from, to];\n      },\n      goToMark: function(cm, _head, motionArgs, vim) {\n        var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);\n        if (pos) {\n          return motionArgs.linewise ? { line: pos.line, ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line)) } : pos;\n        }\n        return null;\n      },\n      moveToOtherHighlightedEnd: function(cm, _head, motionArgs, vim) {\n        if (vim.visualBlock && motionArgs.sameLine) {\n          var sel = vim.sel;\n          return [\n            clipCursorToContent(cm, Pos(sel.anchor.line, sel.head.ch)),\n            clipCursorToContent(cm, Pos(sel.head.line, sel.anchor.ch))\n          ];\n        } else {\n          return ([vim.sel.head, vim.sel.anchor]);\n        }\n      },\n      jumpToMark: function(cm, head, motionArgs, vim) {\n        var best = head;\n        for (var i = 0; i < motionArgs.repeat; i++) {\n          var cursor = best;\n          for (var key in vim.marks) {\n            if (!isLowerCase(key)) {\n              continue;\n            }\n            var mark = vim.marks[key].find();\n            var isWrongDirection = (motionArgs.forward) ?\n              cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);\n\n            if (isWrongDirection) {\n              continue;\n            }\n            if (motionArgs.linewise && (mark.line == cursor.line)) {\n              continue;\n            }\n\n            var equal = cursorEqual(cursor, best);\n            var between = (motionArgs.forward) ?\n              cursorIsBetween(cursor, mark, best) :\n              cursorIsBetween(best, mark, cursor);\n\n            if (equal || between) {\n              best = mark;\n            }\n          }\n        }\n\n        if (motionArgs.linewise) {\n          // Vim places the cursor on the first non-whitespace character of\n          // the line if there is one, else it places the cursor at the end\n          // of the line, regardless of whether a mark was found.\n          best = Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));\n        }\n        return best;\n      },\n      moveByCharacters: function(_cm, head, motionArgs) {\n        var cur = head;\n        var repeat = motionArgs.repeat;\n        var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;\n        return Pos(cur.line, ch);\n      },\n      moveByLines: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        var endCh = cur.ch;\n        // Depending what our last motion was, we may want to do different\n        // things. If our last motion was moving vertically, we want to\n        // preserve the HPos from our last horizontal move.  If our last motion\n        // was going to the end of a line, moving vertically we should go to\n        // the end of the line, etc.\n        switch (vim.lastMotion) {\n          case this.moveByLines:\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveToColumn:\n          case this.moveToEol:\n            endCh = vim.lastHPos;\n            break;\n          default:\n            vim.lastHPos = endCh;\n        }\n        var repeat = motionArgs.repeat+(motionArgs.repeatOffset||0);\n        var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\n        var first = cm.firstLine();\n        var last = cm.lastLine();\n        var posV = cm.findPosV(cur, (motionArgs.forward ? repeat : -repeat), 'line', vim.lastHSPos);\n        var hasMarkedText = motionArgs.forward ? posV.line > line : posV.line < line;\n        if (hasMarkedText) {\n          line = posV.line;\n          endCh = posV.ch;\n        }\n        // Vim go to line begin or line end when cursor at first/last line and\n        // move to previous/next line is triggered.\n        if (line < first && cur.line == first){\n          return this.moveToStartOfLine(cm, head, motionArgs, vim);\n        } else if (line > last && cur.line == last){\n            return moveToEol(cm, head, motionArgs, vim, true);\n        }\n        if (motionArgs.toFirstChar){\n          endCh=findFirstNonWhiteSpaceCharacter(cm.getLine(line));\n          vim.lastHPos = endCh;\n        }\n        vim.lastHSPos = cm.charCoords(Pos(line, endCh),'div').left;\n        return Pos(line, endCh);\n      },\n      moveByDisplayLines: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        switch (vim.lastMotion) {\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveByLines:\n          case this.moveToColumn:\n          case this.moveToEol:\n            break;\n          default:\n            vim.lastHSPos = cm.charCoords(cur,'div').left;\n        }\n        var repeat = motionArgs.repeat;\n        var res=cm.findPosV(cur,(motionArgs.forward ? repeat : -repeat),'line',vim.lastHSPos);\n        if (res.hitSide) {\n          if (motionArgs.forward) {\n            var lastCharCoords = cm.charCoords(res, 'div');\n            var goalCoords = { top: lastCharCoords.top + 8, left: vim.lastHSPos };\n            var res = cm.coordsChar(goalCoords, 'div');\n          } else {\n            var resCoords = cm.charCoords(Pos(cm.firstLine(), 0), 'div');\n            resCoords.left = vim.lastHSPos;\n            res = cm.coordsChar(resCoords, 'div');\n          }\n        }\n        vim.lastHPos = res.ch;\n        return res;\n      },\n      moveByPage: function(cm, head, motionArgs) {\n        // CodeMirror only exposes functions that move the cursor page down, so\n        // doing this bad hack to move the cursor and move it back. evalInput\n        // will move the cursor to where it should be in the end.\n        var curStart = head;\n        var repeat = motionArgs.repeat;\n        return cm.findPosV(curStart, (motionArgs.forward ? repeat : -repeat), 'page');\n      },\n      moveByParagraph: function(cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findParagraph(cm, head, motionArgs.repeat, dir);\n      },\n      moveBySentence: function(cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findSentence(cm, head, motionArgs.repeat, dir);\n      },\n      moveByScroll: function(cm, head, motionArgs, vim) {\n        var scrollbox = cm.getScrollInfo();\n        var curEnd = null;\n        var repeat = motionArgs.repeat;\n        if (!repeat) {\n          repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());\n        }\n        var orig = cm.charCoords(head, 'local');\n        motionArgs.repeat = repeat;\n        var curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);\n        if (!curEnd) {\n          return null;\n        }\n        var dest = cm.charCoords(curEnd, 'local');\n        cm.scrollTo(null, scrollbox.top + dest.top - orig.top);\n        return curEnd;\n      },\n      moveByWords: function(cm, head, motionArgs) {\n        return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward,\n            !!motionArgs.wordEnd, !!motionArgs.bigWord);\n      },\n      moveTillCharacter: function(cm, _head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        var curEnd = moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter);\n        var increment = motionArgs.forward ? -1 : 1;\n        recordLastCharacterSearch(increment, motionArgs);\n        if (!curEnd) return null;\n        curEnd.ch += increment;\n        return curEnd;\n      },\n      moveToCharacter: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        recordLastCharacterSearch(0, motionArgs);\n        return moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || head;\n      },\n      moveToSymbol: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        return findSymbol(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || head;\n      },\n      moveToColumn: function(cm, head, motionArgs, vim) {\n        var repeat = motionArgs.repeat;\n        // repeat is equivalent to which column we want to move to!\n        vim.lastHPos = repeat - 1;\n        vim.lastHSPos = cm.charCoords(head,'div').left;\n        return moveToColumn(cm, repeat);\n      },\n      moveToEol: function(cm, head, motionArgs, vim) {\n        return moveToEol(cm, head, motionArgs, vim, false);\n      },\n      moveToFirstNonWhiteSpaceCharacter: function(cm, head) {\n        // Go to the start of the line where the text begins, or the end for\n        // whitespace-only lines\n        var cursor = head;\n        return Pos(cursor.line,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));\n      },\n      moveToMatchedSymbol: function(cm, head) {\n        var cursor = head;\n        var line = cursor.line;\n        var ch = cursor.ch;\n        var lineText = cm.getLine(line);\n        var symbol;\n        for (; ch < lineText.length; ch++) {\n          symbol = lineText.charAt(ch);\n          if (symbol && isMatchableSymbol(symbol)) {\n            var style = cm.getTokenTypeAt(Pos(line, ch + 1));\n            if (style !== \"string\" && style !== \"comment\") {\n              break;\n            }\n          }\n        }\n        if (ch < lineText.length) {\n          // Only include angle brackets in analysis if they are being matched.\n          var re = (ch === '<' || ch === '>') ? /[(){}[\\]<>]/ : /[(){}[\\]]/;\n          var matched = cm.findMatchingBracket(Pos(line, ch), {bracketRegex: re});\n          return matched.to;\n        } else {\n          return cursor;\n        }\n      },\n      moveToStartOfLine: function(_cm, head) {\n        return Pos(head.line, 0);\n      },\n      moveToLineOrEdgeOfDocument: function(cm, _head, motionArgs) {\n        var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();\n        if (motionArgs.repeatIsExplicit) {\n          lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');\n        }\n        return Pos(lineNum,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));\n      },\n      textObjectManipulation: function(cm, head, motionArgs, vim) {\n        // TODO: lots of possible exceptions that can be thrown here. Try da(\n        //     outside of a () block.\n        var mirroredPairs = {'(': ')', ')': '(',\n                             '{': '}', '}': '{',\n                             '[': ']', ']': '[',\n                             '<': '>', '>': '<'};\n        var selfPaired = {'\\'': true, '\"': true, '`': true};\n\n        var character = motionArgs.selectedCharacter;\n        // 'b' refers to  '()' block.\n        // 'B' refers to  '{}' block.\n        if (character == 'b') {\n          character = '(';\n        } else if (character == 'B') {\n          character = '{';\n        }\n\n        // Inclusive is the difference between a and i\n        // TODO: Instead of using the additional text object map to perform text\n        //     object operations, merge the map into the defaultKeyMap and use\n        //     motionArgs to define behavior. Define separate entries for 'aw',\n        //     'iw', 'a[', 'i[', etc.\n        var inclusive = !motionArgs.textObjectInner;\n\n        var tmp;\n        if (mirroredPairs[character]) {\n          tmp = selectCompanionObject(cm, head, character, inclusive);\n        } else if (selfPaired[character]) {\n          tmp = findBeginningAndEnd(cm, head, character, inclusive);\n        } else if (character === 'W') {\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\n                                                     true /** bigWord */);\n        } else if (character === 'w') {\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\n                                                     false /** bigWord */);\n        } else if (character === 'p') {\n          tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);\n          motionArgs.linewise = true;\n          if (vim.visualMode) {\n            if (!vim.visualLine) { vim.visualLine = true; }\n          } else {\n            var operatorArgs = vim.inputState.operatorArgs;\n            if (operatorArgs) { operatorArgs.linewise = true; }\n            tmp.end.line--;\n          }\n        } else if (character === 't') {\n          tmp = expandTagUnderCursor(cm, head, inclusive);\n        } else {\n          // No text object defined for this, don't move.\n          return null;\n        }\n\n        if (!cm.state.vim.visualMode) {\n          return [tmp.start, tmp.end];\n        } else {\n          return expandSelection(cm, tmp.start, tmp.end);\n        }\n      },\n\n      repeatLastCharacterSearch: function(cm, head, motionArgs) {\n        var lastSearch = vimGlobalState.lastCharacterSearch;\n        var repeat = motionArgs.repeat;\n        var forward = motionArgs.forward === lastSearch.forward;\n        var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);\n        cm.moveH(-increment, 'char');\n        motionArgs.inclusive = forward ? true : false;\n        var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);\n        if (!curEnd) {\n          cm.moveH(increment, 'char');\n          return head;\n        }\n        curEnd.ch += increment;\n        return curEnd;\n      }\n    };\n\n    function defineMotion(name, fn) {\n      motions[name] = fn;\n    }\n\n    function fillArray(val, times) {\n      var arr = [];\n      for (var i = 0; i < times; i++) {\n        arr.push(val);\n      }\n      return arr;\n    }\n    /**\n     * An operator acts on a text selection. It receives the list of selections\n     * as input. The corresponding CodeMirror selection is guaranteed to\n    * match the input selection.\n     */\n    var operators = {\n      change: function(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        var anchor = ranges[0].anchor,\n            head = ranges[0].head;\n        if (!vim.visualMode) {\n          text = cm.getRange(anchor, head);\n          var lastState = vim.lastEditInputState || {};\n          if (lastState.motion == \"moveByWords\" && !isWhiteSpaceString(text)) {\n            // Exclude trailing whitespace if the range is not all whitespace.\n            var match = (/\\s+$/).exec(text);\n            if (match && lastState.motionArgs && lastState.motionArgs.forward) {\n              head = offsetCursor(head, 0, - match[0].length);\n              text = text.slice(0, - match[0].length);\n            }\n          }\n          var prevLineEnd = new Pos(anchor.line - 1, Number.MAX_VALUE);\n          var wasLastLine = cm.firstLine() == cm.lastLine();\n          if (head.line > cm.lastLine() && args.linewise && !wasLastLine) {\n            cm.replaceRange('', prevLineEnd, head);\n          } else {\n            cm.replaceRange('', anchor, head);\n          }\n          if (args.linewise) {\n            // Push the next line back down, if there is a next line.\n            if (!wasLastLine) {\n              cm.setCursor(prevLineEnd);\n              CodeMirror.commands.newlineAndIndent(cm);\n            }\n            // make sure cursor ends up at the end of the line.\n            anchor.ch = Number.MAX_VALUE;\n          }\n          finalHead = anchor;\n        } else if (args.fullLine) {\n            head.ch = Number.MAX_VALUE;\n            head.line--;\n            cm.setSelection(anchor, head)\n            text = cm.getSelection();\n            cm.replaceSelection(\"\");\n            finalHead = anchor;\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'change', text,\n            args.linewise, ranges.length > 1);\n        actions.enterInsertMode(cm, {head: finalHead}, cm.state.vim);\n      },\n      // delete is a javascript keyword.\n      'delete': function(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        if (!vim.visualBlock) {\n          var anchor = ranges[0].anchor,\n              head = ranges[0].head;\n          if (args.linewise &&\n              head.line != cm.firstLine() &&\n              anchor.line == cm.lastLine() &&\n              anchor.line == head.line - 1) {\n            // Special case for dd on last line (and first line).\n            if (anchor.line == cm.firstLine()) {\n              anchor.ch = 0;\n            } else {\n              anchor = Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));\n            }\n          }\n          text = cm.getRange(anchor, head);\n          cm.replaceRange('', anchor, head);\n          finalHead = anchor;\n          if (args.linewise) {\n            finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);\n          }\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = ranges[0].anchor;\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'delete', text,\n            args.linewise, vim.visualBlock);\n        return clipCursorToContent(cm, finalHead);\n      },\n      indent: function(cm, args, ranges) {\n        var vim = cm.state.vim;\n        var startLine = ranges[0].anchor.line;\n        var endLine = vim.visualBlock ?\n          ranges[ranges.length - 1].anchor.line :\n          ranges[0].head.line;\n        // In visual mode, n> shifts the selection right n times, instead of\n        // shifting n lines right once.\n        var repeat = (vim.visualMode) ? args.repeat : 1;\n        if (args.linewise) {\n          // The only way to delete a newline is to delete until the start of\n          // the next line, so in linewise mode evalInput will include the next\n          // line. We don't want this in indent, so we go back a line.\n          endLine--;\n        }\n        for (var i = startLine; i <= endLine; i++) {\n          for (var j = 0; j < repeat; j++) {\n            cm.indentLine(i, args.indentRight);\n          }\n        }\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n      },\n      indentAuto: function(cm, _args, ranges) {\n        cm.execCommand(\"indentAuto\");\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n      },\n      changeCase: function(cm, args, ranges, oldAnchor, newHead) {\n        var selections = cm.getSelections();\n        var swapped = [];\n        var toLower = args.toLower;\n        for (var j = 0; j < selections.length; j++) {\n          var toSwap = selections[j];\n          var text = '';\n          if (toLower === true) {\n            text = toSwap.toLowerCase();\n          } else if (toLower === false) {\n            text = toSwap.toUpperCase();\n          } else {\n            for (var i = 0; i < toSwap.length; i++) {\n              var character = toSwap.charAt(i);\n              text += isUpperCase(character) ? character.toLowerCase() :\n                  character.toUpperCase();\n            }\n          }\n          swapped.push(text);\n        }\n        cm.replaceSelections(swapped);\n        if (args.shouldMoveCursor){\n          return newHead;\n        } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {\n          return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);\n        } else if (args.linewise){\n          return oldAnchor;\n        } else {\n          return cursorMin(ranges[0].anchor, ranges[0].head);\n        }\n      },\n      yank: function(cm, args, ranges, oldAnchor) {\n        var vim = cm.state.vim;\n        var text = cm.getSelection();\n        var endPos = vim.visualMode\n          ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor)\n          : oldAnchor;\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'yank',\n            text, args.linewise, vim.visualBlock);\n        return endPos;\n      }\n    };\n\n    function defineOperator(name, fn) {\n      operators[name] = fn;\n    }\n\n    var actions = {\n      jumpListWalk: function(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat;\n        var forward = actionArgs.forward;\n        var jumpList = vimGlobalState.jumpList;\n\n        var mark = jumpList.move(cm, forward ? repeat : -repeat);\n        var markPos = mark ? mark.find() : undefined;\n        markPos = markPos ? markPos : cm.getCursor();\n        cm.setCursor(markPos);\n      },\n      scroll: function(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat || 1;\n        var lineHeight = cm.defaultTextHeight();\n        var top = cm.getScrollInfo().top;\n        var delta = lineHeight * repeat;\n        var newPos = actionArgs.forward ? top + delta : top - delta;\n        var cursor = copyCursor(cm.getCursor());\n        var cursorCoords = cm.charCoords(cursor, 'local');\n        if (actionArgs.forward) {\n          if (newPos > cursorCoords.top) {\n             cursor.line += (newPos - cursorCoords.top) / lineHeight;\n             cursor.line = Math.ceil(cursor.line);\n             cm.setCursor(cursor);\n             cursorCoords = cm.charCoords(cursor, 'local');\n             cm.scrollTo(null, cursorCoords.top);\n          } else {\n             // Cursor stays within bounds.  Just reposition the scroll window.\n             cm.scrollTo(null, newPos);\n          }\n        } else {\n          var newBottom = newPos + cm.getScrollInfo().clientHeight;\n          if (newBottom < cursorCoords.bottom) {\n             cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;\n             cursor.line = Math.floor(cursor.line);\n             cm.setCursor(cursor);\n             cursorCoords = cm.charCoords(cursor, 'local');\n             cm.scrollTo(\n                 null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);\n          } else {\n             // Cursor stays within bounds.  Just reposition the scroll window.\n             cm.scrollTo(null, newPos);\n          }\n        }\n      },\n      scrollToCursor: function(cm, actionArgs) {\n        var lineNum = cm.getCursor().line;\n        var charCoords = cm.charCoords(Pos(lineNum, 0), 'local');\n        var height = cm.getScrollInfo().clientHeight;\n        var y = charCoords.top;\n        var lineHeight = charCoords.bottom - y;\n        switch (actionArgs.position) {\n          case 'center': y = y - (height / 2) + lineHeight;\n            break;\n          case 'bottom': y = y - height + lineHeight;\n            break;\n        }\n        cm.scrollTo(null, y);\n      },\n      replayMacro: function(cm, actionArgs, vim) {\n        var registerName = actionArgs.selectedCharacter;\n        var repeat = actionArgs.repeat;\n        var macroModeState = vimGlobalState.macroModeState;\n        if (registerName == '@') {\n          registerName = macroModeState.latestRegister;\n        } else {\n          macroModeState.latestRegister = registerName;\n        }\n        while(repeat--){\n          executeMacroRegister(cm, vim, macroModeState, registerName);\n        }\n      },\n      enterMacroRecordMode: function(cm, actionArgs) {\n        var macroModeState = vimGlobalState.macroModeState;\n        var registerName = actionArgs.selectedCharacter;\n        if (vimGlobalState.registerController.isValidRegister(registerName)) {\n          macroModeState.enterMacroRecordMode(cm, registerName);\n        }\n      },\n      toggleOverwrite: function(cm) {\n        if (!cm.state.overwrite) {\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n        }\n      },\n      enterInsertMode: function(cm, actionArgs, vim) {\n        if (cm.getOption('readOnly')) { return; }\n        vim.insertMode = true;\n        vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;\n        var insertAt = (actionArgs) ? actionArgs.insertAt : null;\n        var sel = vim.sel;\n        var head = actionArgs.head || cm.getCursor('head');\n        var height = cm.listSelections().length;\n        if (insertAt == 'eol') {\n          head = Pos(head.line, lineLength(cm, head.line));\n        } else if (insertAt == 'bol') {\n          head = Pos(head.line, 0);\n        } else if (insertAt == 'charAfter') {\n          head = offsetCursor(head, 0, 1);\n        } else if (insertAt == 'firstNonBlank') {\n          head = motions.moveToFirstNonWhiteSpaceCharacter(cm, head);\n        } else if (insertAt == 'startOfSelectedArea') {\n          if (!vim.visualMode)\n              return;\n          if (!vim.visualBlock) {\n            if (sel.head.line < sel.anchor.line) {\n              head = sel.head;\n            } else {\n              head = Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.min(sel.head.ch, sel.anchor.ch));\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'endOfSelectedArea') {\n            if (!vim.visualMode)\n              return;\n          if (!vim.visualBlock) {\n            if (sel.head.line >= sel.anchor.line) {\n              head = offsetCursor(sel.head, 0, 1);\n            } else {\n              head = Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.max(sel.head.ch + 1, sel.anchor.ch));\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'inplace') {\n          if (vim.visualMode){\n            return;\n          }\n        } else if (insertAt == 'lastEdit') {\n          head = getLastEditPos(cm) || head;\n        }\n        cm.setOption('disableInput', false);\n        if (actionArgs && actionArgs.replace) {\n          // Handle Replace-mode as a special case of insert mode.\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n        }\n        if (!vimGlobalState.macroModeState.isPlaying) {\n          // Only record if not replaying.\n          cm.on('change', onChange);\n          CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n        selectForInsert(cm, head, height);\n      },\n      toggleVisualMode: function(cm, actionArgs, vim) {\n        var repeat = actionArgs.repeat;\n        var anchor = cm.getCursor();\n        var head;\n        // TODO: The repeat should actually select number of characters/lines\n        //     equal to the repeat times the size of the previous visual\n        //     operation.\n        if (!vim.visualMode) {\n          // Entering visual mode\n          vim.visualMode = true;\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          head = clipCursorToContent(\n              cm, Pos(anchor.line, anchor.ch + repeat - 1));\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n        } else if (vim.visualLine ^ actionArgs.linewise ||\n            vim.visualBlock ^ actionArgs.blockwise) {\n          // Toggling between modes\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n          updateCmSelection(cm);\n        } else {\n          exitVisualMode(cm);\n        }\n      },\n      reselectLastSelection: function(cm, _actionArgs, vim) {\n        var lastSelection = vim.lastSelection;\n        if (vim.visualMode) {\n          updateLastSelection(cm, vim);\n        }\n        if (lastSelection) {\n          var anchor = lastSelection.anchorMark.find();\n          var head = lastSelection.headMark.find();\n          if (!anchor || !head) {\n            // If the marks have been destroyed due to edits, do nothing.\n            return;\n          }\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          vim.visualMode = true;\n          vim.visualLine = lastSelection.visualLine;\n          vim.visualBlock = lastSelection.visualBlock;\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n          CodeMirror.signal(cm, 'vim-mode-change', {\n            mode: 'visual',\n            subMode: vim.visualLine ? 'linewise' :\n                     vim.visualBlock ? 'blockwise' : ''});\n        }\n      },\n      joinLines: function(cm, actionArgs, vim) {\n        var curStart, curEnd;\n        if (vim.visualMode) {\n          curStart = cm.getCursor('anchor');\n          curEnd = cm.getCursor('head');\n          if (cursorIsBefore(curEnd, curStart)) {\n            var tmp = curEnd;\n            curEnd = curStart;\n            curStart = tmp;\n          }\n          curEnd.ch = lineLength(cm, curEnd.line) - 1;\n        } else {\n          // Repeat is the number of lines to join. Minimum 2 lines.\n          var repeat = Math.max(actionArgs.repeat, 2);\n          curStart = cm.getCursor();\n          curEnd = clipCursorToContent(cm, Pos(curStart.line + repeat - 1,\n                                               Infinity));\n        }\n        var finalCh = 0;\n        for (var i = curStart.line; i < curEnd.line; i++) {\n          finalCh = lineLength(cm, curStart.line);\n          var tmp = Pos(curStart.line + 1,\n                        lineLength(cm, curStart.line + 1));\n          var text = cm.getRange(curStart, tmp);\n          text = actionArgs.keepSpaces\n            ? text.replace(/\\n\\r?/g, '')\n            : text.replace(/\\n\\s*/g, ' ');\n          cm.replaceRange(text, curStart, tmp);\n        }\n        var curFinalPos = Pos(curStart.line, finalCh);\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curFinalPos);\n      },\n      newLineAndEnterInsertMode: function(cm, actionArgs, vim) {\n        vim.insertMode = true;\n        var insertAt = copyCursor(cm.getCursor());\n        if (insertAt.line === cm.firstLine() && !actionArgs.after) {\n          // Special case for inserting newline before start of document.\n          cm.replaceRange('\\n', Pos(cm.firstLine(), 0));\n          cm.setCursor(cm.firstLine(), 0);\n        } else {\n          insertAt.line = (actionArgs.after) ? insertAt.line :\n              insertAt.line - 1;\n          insertAt.ch = lineLength(cm, insertAt.line);\n          cm.setCursor(insertAt);\n          var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment ||\n              CodeMirror.commands.newlineAndIndent;\n          newlineFn(cm);\n        }\n        this.enterInsertMode(cm, { repeat: actionArgs.repeat }, vim);\n      },\n      paste: function(cm, actionArgs, vim) {\n        var cur = copyCursor(cm.getCursor());\n        var register = vimGlobalState.registerController.getRegister(\n            actionArgs.registerName);\n        var text = register.toString();\n        if (!text) {\n          return;\n        }\n        if (actionArgs.matchIndent) {\n          var tabSize = cm.getOption(\"tabSize\");\n          // length that considers tabs and tabSize\n          var whitespaceLength = function(str) {\n            var tabs = (str.split(\"\\t\").length - 1);\n            var spaces = (str.split(\" \").length - 1);\n            return tabs * tabSize + spaces * 1;\n          };\n          var currentLine = cm.getLine(cm.getCursor().line);\n          var indent = whitespaceLength(currentLine.match(/^\\s*/)[0]);\n          // chomp last newline b/c don't want it to match /^\\s*/gm\n          var chompedText = text.replace(/\\n$/, '');\n          var wasChomped = text !== chompedText;\n          var firstIndent = whitespaceLength(text.match(/^\\s*/)[0]);\n          var text = chompedText.replace(/^\\s*/gm, function(wspace) {\n            var newIndent = indent + (whitespaceLength(wspace) - firstIndent);\n            if (newIndent < 0) {\n              return \"\";\n            }\n            else if (cm.getOption(\"indentWithTabs\")) {\n              var quotient = Math.floor(newIndent / tabSize);\n              return Array(quotient + 1).join('\\t');\n            }\n            else {\n              return Array(newIndent + 1).join(' ');\n            }\n          });\n          text += wasChomped ? \"\\n\" : \"\";\n        }\n        if (actionArgs.repeat > 1) {\n          var text = Array(actionArgs.repeat + 1).join(text);\n        }\n        var linewise = register.linewise;\n        var blockwise = register.blockwise;\n        if (blockwise) {\n          text = text.split('\\n');\n          if (linewise) {\n              text.pop();\n          }\n          for (var i = 0; i < text.length; i++) {\n            text[i] = (text[i] == '') ? ' ' : text[i];\n          }\n          cur.ch += actionArgs.after ? 1 : 0;\n          cur.ch = Math.min(lineLength(cm, cur.line), cur.ch);\n        } else if (linewise) {\n          if(vim.visualMode) {\n            text = vim.visualLine ? text.slice(0, -1) : '\\n' + text.slice(0, text.length - 1) + '\\n';\n          } else if (actionArgs.after) {\n            // Move the newline at the end to the start instead, and paste just\n            // before the newline character of the line we are on right now.\n            text = '\\n' + text.slice(0, text.length - 1);\n            cur.ch = lineLength(cm, cur.line);\n          } else {\n            cur.ch = 0;\n          }\n        } else {\n          cur.ch += actionArgs.after ? 1 : 0;\n        }\n        var curPosFinal;\n        var idx;\n        if (vim.visualMode) {\n          //  save the pasted text for reselection if the need arises\n          vim.lastPastedText = text;\n          var lastSelectionCurEnd;\n          var selectedArea = getSelectedAreaRange(cm, vim);\n          var selectionStart = selectedArea[0];\n          var selectionEnd = selectedArea[1];\n          var selectedText = cm.getSelection();\n          var selections = cm.listSelections();\n          var emptyStrings = new Array(selections.length).join('1').split('1');\n          // save the curEnd marker before it get cleared due to cm.replaceRange.\n          if (vim.lastSelection) {\n            lastSelectionCurEnd = vim.lastSelection.headMark.find();\n          }\n          // push the previously selected text to unnamed register\n          vimGlobalState.registerController.unnamedRegister.setText(selectedText);\n          if (blockwise) {\n            // first delete the selected text\n            cm.replaceSelections(emptyStrings);\n            // Set new selections as per the block length of the yanked text\n            selectionEnd = Pos(selectionStart.line + text.length-1, selectionStart.ch);\n            cm.setCursor(selectionStart);\n            selectBlock(cm, selectionEnd);\n            cm.replaceSelections(text);\n            curPosFinal = selectionStart;\n          } else if (vim.visualBlock) {\n            cm.replaceSelections(emptyStrings);\n            cm.setCursor(selectionStart);\n            cm.replaceRange(text, selectionStart, selectionStart);\n            curPosFinal = selectionStart;\n          } else {\n            cm.replaceRange(text, selectionStart, selectionEnd);\n            curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);\n          }\n          // restore the the curEnd marker\n          if(lastSelectionCurEnd) {\n            vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);\n          }\n          if (linewise) {\n            curPosFinal.ch=0;\n          }\n        } else {\n          if (blockwise) {\n            cm.setCursor(cur);\n            for (var i = 0; i < text.length; i++) {\n              var line = cur.line+i;\n              if (line > cm.lastLine()) {\n                cm.replaceRange('\\n',  Pos(line, 0));\n              }\n              var lastCh = lineLength(cm, line);\n              if (lastCh < cur.ch) {\n                extendLineToColumn(cm, line, cur.ch);\n              }\n            }\n            cm.setCursor(cur);\n            selectBlock(cm, Pos(cur.line + text.length-1, cur.ch));\n            cm.replaceSelections(text);\n            curPosFinal = cur;\n          } else {\n            cm.replaceRange(text, cur);\n            // Now fine tune the cursor to where we want it.\n            if (linewise && actionArgs.after) {\n              curPosFinal = Pos(\n              cur.line + 1,\n              findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line + 1)));\n            } else if (linewise && !actionArgs.after) {\n              curPosFinal = Pos(\n                cur.line,\n                findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line)));\n            } else if (!linewise && actionArgs.after) {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length - 1);\n            } else {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length);\n            }\n          }\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curPosFinal);\n      },\n      undo: function(cm, actionArgs) {\n        cm.operation(function() {\n          repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();\n          cm.setCursor(cm.getCursor('anchor'));\n        });\n      },\n      redo: function(cm, actionArgs) {\n        repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();\n      },\n      setRegister: function(_cm, actionArgs, vim) {\n        vim.inputState.registerName = actionArgs.selectedCharacter;\n      },\n      setMark: function(cm, actionArgs, vim) {\n        var markName = actionArgs.selectedCharacter;\n        updateMark(cm, vim, markName, cm.getCursor());\n      },\n      replace: function(cm, actionArgs, vim) {\n        var replaceWith = actionArgs.selectedCharacter;\n        var curStart = cm.getCursor();\n        var replaceTo;\n        var curEnd;\n        var selections = cm.listSelections();\n        if (vim.visualMode) {\n          curStart = cm.getCursor('start');\n          curEnd = cm.getCursor('end');\n        } else {\n          var line = cm.getLine(curStart.line);\n          replaceTo = curStart.ch + actionArgs.repeat;\n          if (replaceTo > line.length) {\n            replaceTo=line.length;\n          }\n          curEnd = Pos(curStart.line, replaceTo);\n        }\n        if (replaceWith=='\\n') {\n          if (!vim.visualMode) cm.replaceRange('', curStart, curEnd);\n          // special case, where vim help says to replace by just one line-break\n          (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);\n        } else {\n          var replaceWithStr = cm.getRange(curStart, curEnd);\n          //replace all characters in range by selected, but keep linebreaks\n          replaceWithStr = replaceWithStr.replace(/[^\\n]/g, replaceWith);\n          if (vim.visualBlock) {\n            // Tabs are split in visua block before replacing\n            var spaces = new Array(cm.getOption(\"tabSize\")+1).join(' ');\n            replaceWithStr = cm.getSelection();\n            replaceWithStr = replaceWithStr.replace(/\\t/g, spaces).replace(/[^\\n]/g, replaceWith).split('\\n');\n            cm.replaceSelections(replaceWithStr);\n          } else {\n            cm.replaceRange(replaceWithStr, curStart, curEnd);\n          }\n          if (vim.visualMode) {\n            curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ?\n                         selections[0].anchor : selections[0].head;\n            cm.setCursor(curStart);\n            exitVisualMode(cm, false);\n          } else {\n            cm.setCursor(offsetCursor(curEnd, 0, -1));\n          }\n        }\n      },\n      incrementNumberToken: function(cm, actionArgs) {\n        var cur = cm.getCursor();\n        var lineStr = cm.getLine(cur.line);\n        var re = /(-?)(?:(0x)([\\da-f]+)|(0b|0|)(\\d+))/gi;\n        var match;\n        var start;\n        var end;\n        var numberStr;\n        while ((match = re.exec(lineStr)) !== null) {\n          start = match.index;\n          end = start + match[0].length;\n          if (cur.ch < end)break;\n        }\n        if (!actionArgs.backtrack && (end <= cur.ch))return;\n        if (match) {\n          var baseStr = match[2] || match[4]\n          var digits = match[3] || match[5]\n          var increment = actionArgs.increase ? 1 : -1;\n          var base = {'0b': 2, '0': 8, '': 10, '0x': 16}[baseStr.toLowerCase()];\n          var number = parseInt(match[1] + digits, base) + (increment * actionArgs.repeat);\n          numberStr = number.toString(base);\n          var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join('0') : ''\n          if (numberStr.charAt(0) === '-') {\n            numberStr = '-' + baseStr + zeroPadding + numberStr.substr(1);\n          } else {\n            numberStr = baseStr + zeroPadding + numberStr;\n          }\n          var from = Pos(cur.line, start);\n          var to = Pos(cur.line, end);\n          cm.replaceRange(numberStr, from, to);\n        } else {\n          return;\n        }\n        cm.setCursor(Pos(cur.line, start + numberStr.length - 1));\n      },\n      repeatLastEdit: function(cm, actionArgs, vim) {\n        var lastEditInputState = vim.lastEditInputState;\n        if (!lastEditInputState) { return; }\n        var repeat = actionArgs.repeat;\n        if (repeat && actionArgs.repeatIsExplicit) {\n          vim.lastEditInputState.repeatOverride = repeat;\n        } else {\n          repeat = vim.lastEditInputState.repeatOverride || repeat;\n        }\n        repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */);\n      },\n      indent: function(cm, actionArgs) {\n        cm.indentLine(cm.getCursor().line, actionArgs.indentRight);\n      },\n      exitInsertMode: exitInsertMode\n    };\n\n    function defineAction(name, fn) {\n      actions[name] = fn;\n    }\n\n    /*\n     * Below are miscellaneous utility functions used by vim.js\n     */\n\n    /**\n     * Clips cursor to ensure that line is within the buffer's range\n     * If includeLineBreak is true, then allow cur.ch == lineLength.\n     */\n    function clipCursorToContent(cm, cur) {\n      var vim = cm.state.vim;\n      var includeLineBreak = vim.insertMode || vim.visualMode;\n      var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine() );\n      var maxCh = lineLength(cm, line) - 1 + !!includeLineBreak;\n      var ch = Math.min(Math.max(0, cur.ch), maxCh);\n      return Pos(line, ch);\n    }\n    function copyArgs(args) {\n      var ret = {};\n      for (var prop in args) {\n        if (args.hasOwnProperty(prop)) {\n          ret[prop] = args[prop];\n        }\n      }\n      return ret;\n    }\n    function offsetCursor(cur, offsetLine, offsetCh) {\n      if (typeof offsetLine === 'object') {\n        offsetCh = offsetLine.ch;\n        offsetLine = offsetLine.line;\n      }\n      return Pos(cur.line + offsetLine, cur.ch + offsetCh);\n    }\n    function commandMatches(keys, keyMap, context, inputState) {\n      // Partial matches are not applied. They inform the key handler\n      // that the current key sequence is a subsequence of a valid key\n      // sequence, so that the key buffer is not cleared.\n      var match, partial = [], full = [];\n      for (var i = 0; i < keyMap.length; i++) {\n        var command = keyMap[i];\n        if (context == 'insert' && command.context != 'insert' ||\n            command.context && command.context != context ||\n            inputState.operator && command.type == 'action' ||\n            !(match = commandMatch(keys, command.keys))) { continue; }\n        if (match == 'partial') { partial.push(command); }\n        if (match == 'full') { full.push(command); }\n      }\n      return {\n        partial: partial.length && partial,\n        full: full.length && full\n      };\n    }\n    function commandMatch(pressed, mapped) {\n      if (mapped.slice(-11) == '<character>') {\n        // Last character matches anything.\n        var prefixLen = mapped.length - 11;\n        var pressedPrefix = pressed.slice(0, prefixLen);\n        var mappedPrefix = mapped.slice(0, prefixLen);\n        return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' :\n               mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;\n      } else {\n        return pressed == mapped ? 'full' :\n               mapped.indexOf(pressed) == 0 ? 'partial' : false;\n      }\n    }\n    function lastChar(keys) {\n      var match = /^.*(<[^>]+>)$/.exec(keys);\n      var selectedCharacter = match ? match[1] : keys.slice(-1);\n      if (selectedCharacter.length > 1){\n        switch(selectedCharacter){\n          case '<CR>':\n            selectedCharacter='\\n';\n            break;\n          case '<Space>':\n            selectedCharacter=' ';\n            break;\n          default:\n            selectedCharacter='';\n            break;\n        }\n      }\n      return selectedCharacter;\n    }\n    function repeatFn(cm, fn, repeat) {\n      return function() {\n        for (var i = 0; i < repeat; i++) {\n          fn(cm);\n        }\n      };\n    }\n    function copyCursor(cur) {\n      return Pos(cur.line, cur.ch);\n    }\n    function cursorEqual(cur1, cur2) {\n      return cur1.ch == cur2.ch && cur1.line == cur2.line;\n    }\n    function cursorIsBefore(cur1, cur2) {\n      if (cur1.line < cur2.line) {\n        return true;\n      }\n      if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\n        return true;\n      }\n      return false;\n    }\n    function cursorMin(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur1 : cur2;\n    }\n    function cursorMax(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur2 : cur1;\n    }\n    function cursorIsBetween(cur1, cur2, cur3) {\n      // returns true if cur2 is between cur1 and cur3.\n      var cur1before2 = cursorIsBefore(cur1, cur2);\n      var cur2before3 = cursorIsBefore(cur2, cur3);\n      return cur1before2 && cur2before3;\n    }\n    function lineLength(cm, lineNum) {\n      return cm.getLine(lineNum).length;\n    }\n    function trim(s) {\n      if (s.trim) {\n        return s.trim();\n      }\n      return s.replace(/^\\s+|\\s+$/g, '');\n    }\n    function escapeRegex(s) {\n      return s.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g, '\\\\$1');\n    }\n    function extendLineToColumn(cm, lineNum, column) {\n      var endCh = lineLength(cm, lineNum);\n      var spaces = new Array(column-endCh+1).join(' ');\n      cm.setCursor(Pos(lineNum, endCh));\n      cm.replaceRange(spaces, cm.getCursor());\n    }\n    // This functions selects a rectangular block\n    // of text with selectionEnd as any of its corner\n    // Height of block:\n    // Difference in selectionEnd.line and first/last selection.line\n    // Width of the block:\n    // Distance between selectionEnd.ch and any(first considered here) selection.ch\n    function selectBlock(cm, selectionEnd) {\n      var selections = [], ranges = cm.listSelections();\n      var head = copyCursor(cm.clipPos(selectionEnd));\n      var isClipped = !cursorEqual(selectionEnd, head);\n      var curHead = cm.getCursor('head');\n      var primIndex = getIndex(ranges, curHead);\n      var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);\n      var max = ranges.length - 1;\n      var index = max - primIndex > primIndex ? max : 0;\n      var base = ranges[index].anchor;\n\n      var firstLine = Math.min(base.line, head.line);\n      var lastLine = Math.max(base.line, head.line);\n      var baseCh = base.ch, headCh = head.ch;\n\n      var dir = ranges[index].head.ch - baseCh;\n      var newDir = headCh - baseCh;\n      if (dir > 0 && newDir <= 0) {\n        baseCh++;\n        if (!isClipped) { headCh--; }\n      } else if (dir < 0 && newDir >= 0) {\n        baseCh--;\n        if (!wasClipped) { headCh++; }\n      } else if (dir < 0 && newDir == -1) {\n        baseCh--;\n        headCh++;\n      }\n      for (var line = firstLine; line <= lastLine; line++) {\n        var range = {anchor: new Pos(line, baseCh), head: new Pos(line, headCh)};\n        selections.push(range);\n      }\n      cm.setSelections(selections);\n      selectionEnd.ch = headCh;\n      base.ch = baseCh;\n      return base;\n    }\n    function selectForInsert(cm, head, height) {\n      var sel = [];\n      for (var i = 0; i < height; i++) {\n        var lineHead = offsetCursor(head, i, 0);\n        sel.push({anchor: lineHead, head: lineHead});\n      }\n      cm.setSelections(sel, 0);\n    }\n    // getIndex returns the index of the cursor in the selections.\n    function getIndex(ranges, cursor, end) {\n      for (var i = 0; i < ranges.length; i++) {\n        var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor);\n        var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor);\n        if (atAnchor || atHead) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    function getSelectedAreaRange(cm, vim) {\n      var lastSelection = vim.lastSelection;\n      var getCurrentSelectedAreaRange = function() {\n        var selections = cm.listSelections();\n        var start =  selections[0];\n        var end = selections[selections.length-1];\n        var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;\n        var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;\n        return [selectionStart, selectionEnd];\n      };\n      var getLastSelectedAreaRange = function() {\n        var selectionStart = cm.getCursor();\n        var selectionEnd = cm.getCursor();\n        var block = lastSelection.visualBlock;\n        if (block) {\n          var width = block.width;\n          var height = block.height;\n          selectionEnd = Pos(selectionStart.line + height, selectionStart.ch + width);\n          var selections = [];\n          // selectBlock creates a 'proper' rectangular block.\n          // We do not want that in all cases, so we manually set selections.\n          for (var i = selectionStart.line; i < selectionEnd.line; i++) {\n            var anchor = Pos(i, selectionStart.ch);\n            var head = Pos(i, selectionEnd.ch);\n            var range = {anchor: anchor, head: head};\n            selections.push(range);\n          }\n          cm.setSelections(selections);\n        } else {\n          var start = lastSelection.anchorMark.find();\n          var end = lastSelection.headMark.find();\n          var line = end.line - start.line;\n          var ch = end.ch - start.ch;\n          selectionEnd = {line: selectionEnd.line + line, ch: line ? selectionEnd.ch : ch + selectionEnd.ch};\n          if (lastSelection.visualLine) {\n            selectionStart = Pos(selectionStart.line, 0);\n            selectionEnd = Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));\n          }\n          cm.setSelection(selectionStart, selectionEnd);\n        }\n        return [selectionStart, selectionEnd];\n      };\n      if (!vim.visualMode) {\n      // In case of replaying the action.\n        return getLastSelectedAreaRange();\n      } else {\n        return getCurrentSelectedAreaRange();\n      }\n    }\n    // Updates the previous selection with the current selection's values. This\n    // should only be called in visual mode.\n    function updateLastSelection(cm, vim) {\n      var anchor = vim.sel.anchor;\n      var head = vim.sel.head;\n      // To accommodate the effect of lastPastedText in the last selection\n      if (vim.lastPastedText) {\n        head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);\n        vim.lastPastedText = null;\n      }\n      vim.lastSelection = {'anchorMark': cm.setBookmark(anchor),\n                           'headMark': cm.setBookmark(head),\n                           'anchor': copyCursor(anchor),\n                           'head': copyCursor(head),\n                           'visualMode': vim.visualMode,\n                           'visualLine': vim.visualLine,\n                           'visualBlock': vim.visualBlock};\n    }\n    function expandSelection(cm, start, end) {\n      var sel = cm.state.vim.sel;\n      var head = sel.head;\n      var anchor = sel.anchor;\n      var tmp;\n      if (cursorIsBefore(end, start)) {\n        tmp = end;\n        end = start;\n        start = tmp;\n      }\n      if (cursorIsBefore(head, anchor)) {\n        head = cursorMin(start, head);\n        anchor = cursorMax(anchor, end);\n      } else {\n        anchor = cursorMin(start, anchor);\n        head = cursorMax(head, end);\n        head = offsetCursor(head, 0, -1);\n        if (head.ch == -1 && head.line != cm.firstLine()) {\n          head = Pos(head.line - 1, lineLength(cm, head.line - 1));\n        }\n      }\n      return [anchor, head];\n    }\n    /**\n     * Updates the CodeMirror selection to match the provided vim selection.\n     * If no arguments are given, it uses the current vim selection state.\n     */\n    function updateCmSelection(cm, sel, mode) {\n      var vim = cm.state.vim;\n      sel = sel || vim.sel;\n      var mode = mode ||\n        vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';\n      var cmSel = makeCmSelection(cm, sel, mode);\n      cm.setSelections(cmSel.ranges, cmSel.primary);\n      updateFakeCursor(cm);\n    }\n    function makeCmSelection(cm, sel, mode, exclusive) {\n      var head = copyCursor(sel.head);\n      var anchor = copyCursor(sel.anchor);\n      if (mode == 'char') {\n        var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        head = offsetCursor(sel.head, 0, headOffset);\n        anchor = offsetCursor(sel.anchor, 0, anchorOffset);\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        };\n      } else if (mode == 'line') {\n        if (!cursorIsBefore(sel.head, sel.anchor)) {\n          anchor.ch = 0;\n\n          var lastLine = cm.lastLine();\n          if (head.line > lastLine) {\n            head.line = lastLine;\n          }\n          head.ch = lineLength(cm, head.line);\n        } else {\n          head.ch = 0;\n          anchor.ch = lineLength(cm, anchor.line);\n        }\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        };\n      } else if (mode == 'block') {\n        var top = Math.min(anchor.line, head.line),\n            left = Math.min(anchor.ch, head.ch),\n            bottom = Math.max(anchor.line, head.line),\n            right = Math.max(anchor.ch, head.ch) + 1;\n        var height = bottom - top + 1;\n        var primary = head.line == top ? 0 : height - 1;\n        var ranges = [];\n        for (var i = 0; i < height; i++) {\n          ranges.push({\n            anchor: Pos(top + i, left),\n            head: Pos(top + i, right)\n          });\n        }\n        return {\n          ranges: ranges,\n          primary: primary\n        };\n      }\n    }\n    function getHead(cm) {\n      var cur = cm.getCursor('head');\n      if (cm.getSelection().length == 1) {\n        // Small corner case when only 1 character is selected. The \"real\"\n        // head is the left of head and anchor.\n        cur = cursorMin(cur, cm.getCursor('anchor'));\n      }\n      return cur;\n    }\n\n    /**\n     * If moveHead is set to false, the CodeMirror selection will not be\n     * touched. The caller assumes the responsibility of putting the cursor\n    * in the right place.\n     */\n    function exitVisualMode(cm, moveHead) {\n      var vim = cm.state.vim;\n      if (moveHead !== false) {\n        cm.setCursor(clipCursorToContent(cm, vim.sel.head));\n      }\n      updateLastSelection(cm, vim);\n      vim.visualMode = false;\n      vim.visualLine = false;\n      vim.visualBlock = false;\n      if (!vim.insertMode) CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      clearFakeCursor(vim);\n    }\n\n    // Remove any trailing newlines from the selection. For\n    // example, with the caret at the start of the last word on the line,\n    // 'dw' should word, but not the newline, while 'w' should advance the\n    // caret to the first character of the next line.\n    function clipToLine(cm, curStart, curEnd) {\n      var selection = cm.getRange(curStart, curEnd);\n      // Only clip if the selection ends with trailing newline + whitespace\n      if (/\\n\\s*$/.test(selection)) {\n        var lines = selection.split('\\n');\n        // We know this is all whitespace.\n        lines.pop();\n\n        // Cases:\n        // 1. Last word is an empty line - do not clip the trailing '\\n'\n        // 2. Last word is not an empty line - clip the trailing '\\n'\n        var line;\n        // Find the line containing the last word, and clip all whitespace up\n        // to it.\n        for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {\n          curEnd.line--;\n          curEnd.ch = 0;\n        }\n        // If the last word is not an empty line, clip an additional newline\n        if (line) {\n          curEnd.line--;\n          curEnd.ch = lineLength(cm, curEnd.line);\n        } else {\n          curEnd.ch = 0;\n        }\n      }\n    }\n\n    // Expand the selection to line ends.\n    function expandSelectionToLine(_cm, curStart, curEnd) {\n      curStart.ch = 0;\n      curEnd.ch = 0;\n      curEnd.line++;\n    }\n\n    function findFirstNonWhiteSpaceCharacter(text) {\n      if (!text) {\n        return 0;\n      }\n      var firstNonWS = text.search(/\\S/);\n      return firstNonWS == -1 ? text.length : firstNonWS;\n    }\n\n    function expandWordUnderCursor(cm, inclusive, _forward, bigWord, noSymbol) {\n      var cur = getHead(cm);\n      var line = cm.getLine(cur.line);\n      var idx = cur.ch;\n\n      // Seek to first word or non-whitespace character, depending on if\n      // noSymbol is true.\n      var test = noSymbol ? wordCharTest[0] : bigWordCharTest [0];\n      while (!test(line.charAt(idx))) {\n        idx++;\n        if (idx >= line.length) { return null; }\n      }\n\n      if (bigWord) {\n        test = bigWordCharTest[0];\n      } else {\n        test = wordCharTest[0];\n        if (!test(line.charAt(idx))) {\n          test = wordCharTest[1];\n        }\n      }\n\n      var end = idx, start = idx;\n      while (test(line.charAt(end)) && end < line.length) { end++; }\n      while (test(line.charAt(start)) && start >= 0) { start--; }\n      start++;\n\n      if (inclusive) {\n        // If present, include all whitespace after word.\n        // Otherwise, include all whitespace before word, except indentation.\n        var wordEnd = end;\n        while (/\\s/.test(line.charAt(end)) && end < line.length) { end++; }\n        if (wordEnd == end) {\n          var wordStart = start;\n          while (/\\s/.test(line.charAt(start - 1)) && start > 0) { start--; }\n          if (!start) { start = wordStart; }\n        }\n      }\n      return { start: Pos(cur.line, start), end: Pos(cur.line, end) };\n    }\n\n    /**\n     * Depends on the following:\n     *\n     * - editor mode should be htmlmixedmode / xml\n     * - mode/xml/xml.js should be loaded\n     * - addon/fold/xml-fold.js should be loaded\n     *\n     * If any of the above requirements are not true, this function noops.\n     *\n     * This is _NOT_ a 100% accurate implementation of vim tag text objects.\n     * The following caveats apply (based off cursory testing, I'm sure there\n     * are other discrepancies):\n     *\n     * - Does not work inside comments:\n     *   ```\n     *   <!-- <div>broken</div> -->\n     *   ```\n     * - Does not work when tags have different cases:\n     *   ```\n     *   <div>broken</DIV>\n     *   ```\n     * - Does not work when cursor is inside a broken tag:\n     *   ```\n     *   <div><brok><en></div>\n     *   ```\n     */\n    function expandTagUnderCursor(cm, head, inclusive) {\n      var cur = head;\n      if (!CodeMirror.findMatchingTag || !CodeMirror.findEnclosingTag) {\n        return { start: cur, end: cur };\n      }\n\n      var tags = CodeMirror.findMatchingTag(cm, head) || CodeMirror.findEnclosingTag(cm, head);\n      if (!tags || !tags.open || !tags.close) {\n        return { start: cur, end: cur };\n      }\n\n      if (inclusive) {\n        return { start: tags.open.from, end: tags.close.to };\n      }\n      return { start: tags.open.to, end: tags.close.from };\n    }\n\n    function recordJumpPosition(cm, oldCur, newCur) {\n      if (!cursorEqual(oldCur, newCur)) {\n        vimGlobalState.jumpList.add(cm, oldCur, newCur);\n      }\n    }\n\n    function recordLastCharacterSearch(increment, args) {\n        vimGlobalState.lastCharacterSearch.increment = increment;\n        vimGlobalState.lastCharacterSearch.forward = args.forward;\n        vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;\n    }\n\n    var symbolToMode = {\n        '(': 'bracket', ')': 'bracket', '{': 'bracket', '}': 'bracket',\n        '[': 'section', ']': 'section',\n        '*': 'comment', '/': 'comment',\n        'm': 'method', 'M': 'method',\n        '#': 'preprocess'\n    };\n    var findSymbolModes = {\n      bracket: {\n        isComplete: function(state) {\n          if (state.nextCh === state.symb) {\n            state.depth++;\n            if (state.depth >= 1)return true;\n          } else if (state.nextCh === state.reverseSymb) {\n            state.depth--;\n          }\n          return false;\n        }\n      },\n      section: {\n        init: function(state) {\n          state.curMoveThrough = true;\n          state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';\n        },\n        isComplete: function(state) {\n          return state.index === 0 && state.nextCh === state.symb;\n        }\n      },\n      comment: {\n        isComplete: function(state) {\n          var found = state.lastCh === '*' && state.nextCh === '/';\n          state.lastCh = state.nextCh;\n          return found;\n        }\n      },\n      // TODO: The original Vim implementation only operates on level 1 and 2.\n      // The current implementation doesn't check for code block level and\n      // therefore it operates on any levels.\n      method: {\n        init: function(state) {\n          state.symb = (state.symb === 'm' ? '{' : '}');\n          state.reverseSymb = state.symb === '{' ? '}' : '{';\n        },\n        isComplete: function(state) {\n          if (state.nextCh === state.symb)return true;\n          return false;\n        }\n      },\n      preprocess: {\n        init: function(state) {\n          state.index = 0;\n        },\n        isComplete: function(state) {\n          if (state.nextCh === '#') {\n            var token = state.lineText.match(/^#(\\w+)/)[1];\n            if (token === 'endif') {\n              if (state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth++;\n            } else if (token === 'if') {\n              if (!state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth--;\n            }\n            if (token === 'else' && state.depth === 0)return true;\n          }\n          return false;\n        }\n      }\n    };\n    function findSymbol(cm, repeat, forward, symb) {\n      var cur = copyCursor(cm.getCursor());\n      var increment = forward ? 1 : -1;\n      var endLine = forward ? cm.lineCount() : -1;\n      var curCh = cur.ch;\n      var line = cur.line;\n      var lineText = cm.getLine(line);\n      var state = {\n        lineText: lineText,\n        nextCh: lineText.charAt(curCh),\n        lastCh: null,\n        index: curCh,\n        symb: symb,\n        reverseSymb: (forward ?  { ')': '(', '}': '{' } : { '(': ')', '{': '}' })[symb],\n        forward: forward,\n        depth: 0,\n        curMoveThrough: false\n      };\n      var mode = symbolToMode[symb];\n      if (!mode)return cur;\n      var init = findSymbolModes[mode].init;\n      var isComplete = findSymbolModes[mode].isComplete;\n      if (init) { init(state); }\n      while (line !== endLine && repeat) {\n        state.index += increment;\n        state.nextCh = state.lineText.charAt(state.index);\n        if (!state.nextCh) {\n          line += increment;\n          state.lineText = cm.getLine(line) || '';\n          if (increment > 0) {\n            state.index = 0;\n          } else {\n            var lineLen = state.lineText.length;\n            state.index = (lineLen > 0) ? (lineLen-1) : 0;\n          }\n          state.nextCh = state.lineText.charAt(state.index);\n        }\n        if (isComplete(state)) {\n          cur.line = line;\n          cur.ch = state.index;\n          repeat--;\n        }\n      }\n      if (state.nextCh || state.curMoveThrough) {\n        return Pos(line, state.index);\n      }\n      return cur;\n    }\n\n    /*\n     * Returns the boundaries of the next word. If the cursor in the middle of\n     * the word, then returns the boundaries of the current word, starting at\n     * the cursor. If the cursor is at the start/end of a word, and we are going\n     * forward/backward, respectively, find the boundaries of the next word.\n     *\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Cursor} cur The cursor position.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only [a-zA-Z0-9] characters count as part of the word.\n     * @param {boolean} emptyLineIsWord True if empty lines should be treated\n     *     as words.\n     * @return {Object{from:number, to:number, line: number}} The boundaries of\n     *     the word, or null if there are no more words.\n     */\n    function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {\n      var lineNum = cur.line;\n      var pos = cur.ch;\n      var line = cm.getLine(lineNum);\n      var dir = forward ? 1 : -1;\n      var charTests = bigWord ? bigWordCharTest: wordCharTest;\n\n      if (emptyLineIsWord && line == '') {\n        lineNum += dir;\n        line = cm.getLine(lineNum);\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        pos = (forward) ? 0 : line.length;\n      }\n\n      while (true) {\n        if (emptyLineIsWord && line == '') {\n          return { from: 0, to: 0, line: lineNum };\n        }\n        var stop = (dir > 0) ? line.length : -1;\n        var wordStart = stop, wordEnd = stop;\n        // Find bounds of next word.\n        while (pos != stop) {\n          var foundWord = false;\n          for (var i = 0; i < charTests.length && !foundWord; ++i) {\n            if (charTests[i](line.charAt(pos))) {\n              wordStart = pos;\n              // Advance to end of word.\n              while (pos != stop && charTests[i](line.charAt(pos))) {\n                pos += dir;\n              }\n              wordEnd = pos;\n              foundWord = wordStart != wordEnd;\n              if (wordStart == cur.ch && lineNum == cur.line &&\n                  wordEnd == wordStart + dir) {\n                // We started at the end of a word. Find the next one.\n                continue;\n              } else {\n                return {\n                  from: Math.min(wordStart, wordEnd + 1),\n                  to: Math.max(wordStart, wordEnd),\n                  line: lineNum };\n              }\n            }\n          }\n          if (!foundWord) {\n            pos += dir;\n          }\n        }\n        // Advance to next/prev line.\n        lineNum += dir;\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        line = cm.getLine(lineNum);\n        pos = (dir > 0) ? 0 : line.length;\n      }\n    }\n\n    /**\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Pos} cur The position to start from.\n     * @param {int} repeat Number of words to move past.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} wordEnd True to move to end of word. False to move to\n     *     beginning of word.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only alphabet characters count as part of the word.\n     * @return {Cursor} The position the cursor should move to.\n     */\n    function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {\n      var curStart = copyCursor(cur);\n      var words = [];\n      if (forward && !wordEnd || !forward && wordEnd) {\n        repeat++;\n      }\n      // For 'e', empty lines are not considered words, go figure.\n      var emptyLineIsWord = !(forward && wordEnd);\n      for (var i = 0; i < repeat; i++) {\n        var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);\n        if (!word) {\n          var eodCh = lineLength(cm, cm.lastLine());\n          words.push(forward\n              ? {line: cm.lastLine(), from: eodCh, to: eodCh}\n              : {line: 0, from: 0, to: 0});\n          break;\n        }\n        words.push(word);\n        cur = Pos(word.line, forward ? (word.to - 1) : word.from);\n      }\n      var shortCircuit = words.length != repeat;\n      var firstWord = words[0];\n      var lastWord = words.pop();\n      if (forward && !wordEnd) {\n        // w\n        if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return Pos(lastWord.line, lastWord.from);\n      } else if (forward && wordEnd) {\n        return Pos(lastWord.line, lastWord.to - 1);\n      } else if (!forward && wordEnd) {\n        // ge\n        if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return Pos(lastWord.line, lastWord.to);\n      } else {\n        // b\n        return Pos(lastWord.line, lastWord.from);\n      }\n    }\n\n    function moveToEol(cm, head, motionArgs, vim, keepHPos) {\n      var cur = head;\n      var retval= Pos(cur.line + motionArgs.repeat - 1, Infinity);\n      var end=cm.clipPos(retval);\n      end.ch--;\n      if (!keepHPos) {\n        vim.lastHPos = Infinity;\n        vim.lastHSPos = cm.charCoords(end,'div').left;\n      }\n      return retval;\n    }\n\n    function moveToCharacter(cm, repeat, forward, character) {\n      var cur = cm.getCursor();\n      var start = cur.ch;\n      var idx;\n      for (var i = 0; i < repeat; i ++) {\n        var line = cm.getLine(cur.line);\n        idx = charIdxInLine(start, line, character, forward, true);\n        if (idx == -1) {\n          return null;\n        }\n        start = idx;\n      }\n      return Pos(cm.getCursor().line, idx);\n    }\n\n    function moveToColumn(cm, repeat) {\n      // repeat is always >= 1, so repeat - 1 always corresponds\n      // to the column we want to go to.\n      var line = cm.getCursor().line;\n      return clipCursorToContent(cm, Pos(line, repeat - 1));\n    }\n\n    function updateMark(cm, vim, markName, pos) {\n      if (!inArray(markName, validMarks)) {\n        return;\n      }\n      if (vim.marks[markName]) {\n        vim.marks[markName].clear();\n      }\n      vim.marks[markName] = cm.setBookmark(pos);\n    }\n\n    function charIdxInLine(start, line, character, forward, includeChar) {\n      // Search for char in line.\n      // motion_options: {forward, includeChar}\n      // If includeChar = true, include it too.\n      // If forward = true, search forward, else search backwards.\n      // If char is not found on this line, do nothing\n      var idx;\n      if (forward) {\n        idx = line.indexOf(character, start + 1);\n        if (idx != -1 && !includeChar) {\n          idx -= 1;\n        }\n      } else {\n        idx = line.lastIndexOf(character, start - 1);\n        if (idx != -1 && !includeChar) {\n          idx += 1;\n        }\n      }\n      return idx;\n    }\n\n    function findParagraph(cm, head, repeat, dir, inclusive) {\n      var line = head.line;\n      var min = cm.firstLine();\n      var max = cm.lastLine();\n      var start, end, i = line;\n      function isEmpty(i) { return !cm.getLine(i); }\n      function isBoundary(i, dir, any) {\n        if (any) { return isEmpty(i) != isEmpty(i + dir); }\n        return !isEmpty(i) && isEmpty(i + dir);\n      }\n      if (dir) {\n        while (min <= i && i <= max && repeat > 0) {\n          if (isBoundary(i, dir)) { repeat--; }\n          i += dir;\n        }\n        return new Pos(i, 0);\n      }\n\n      var vim = cm.state.vim;\n      if (vim.visualLine && isBoundary(line, 1, true)) {\n        var anchor = vim.sel.anchor;\n        if (isBoundary(anchor.line, -1, true)) {\n          if (!inclusive || anchor.line != line) {\n            line += 1;\n          }\n        }\n      }\n      var startState = isEmpty(line);\n      for (i = line; i <= max && repeat; i++) {\n        if (isBoundary(i, 1, true)) {\n          if (!inclusive || isEmpty(i) != startState) {\n            repeat--;\n          }\n        }\n      }\n      end = new Pos(i, 0);\n      // select boundary before paragraph for the last one\n      if (i > max && !startState) { startState = true; }\n      else { inclusive = false; }\n      for (i = line; i > min; i--) {\n        if (!inclusive || isEmpty(i) == startState || i == line) {\n          if (isBoundary(i, -1, true)) { break; }\n        }\n      }\n      start = new Pos(i, 0);\n      return { start: start, end: end };\n    }\n\n    function findSentence(cm, cur, repeat, dir) {\n\n      /*\n        Takes an index object\n        {\n          line: the line string,\n          ln: line number,\n          pos: index in line,\n          dir: direction of traversal (-1 or 1)\n        }\n        and modifies the line, ln, and pos members to represent the\n        next valid position or sets them to null if there are\n        no more valid positions.\n       */\n      function nextChar(cm, idx) {\n        if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {\n          idx.ln += idx.dir;\n          if (!isLine(cm, idx.ln)) {\n            idx.line = null;\n            idx.ln = null;\n            idx.pos = null;\n            return;\n          }\n          idx.line = cm.getLine(idx.ln);\n          idx.pos = (idx.dir > 0) ? 0 : idx.line.length - 1;\n        }\n        else {\n          idx.pos += idx.dir;\n        }\n      }\n\n      /*\n        Performs one iteration of traversal in forward direction\n        Returns an index object of the new location\n       */\n      function forward(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n        var stop = (line === \"\");\n\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir,\n        }\n\n        var last_valid = {\n          ln: curr.ln,\n          pos: curr.pos,\n        }\n\n        var skip_empty_lines = (curr.line === \"\");\n\n        // Move one step to skip character we start on\n        nextChar(cm, curr);\n\n        while (curr.line !== null) {\n          last_valid.ln = curr.ln;\n          last_valid.pos = curr.pos;\n\n          if (curr.line === \"\" && !skip_empty_lines) {\n            return { ln: curr.ln, pos: curr.pos, };\n          }\n          else if (stop && curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n            return { ln: curr.ln, pos: curr.pos, };\n          }\n          else if (isEndOfSentenceSymbol(curr.line[curr.pos])\n            && !stop\n            && (curr.pos === curr.line.length - 1\n              || isWhiteSpaceString(curr.line[curr.pos + 1]))) {\n            stop = true;\n          }\n\n          nextChar(cm, curr);\n        }\n\n        /*\n          Set the position to the last non whitespace character on the last\n          valid line in the case that we reach the end of the document.\n        */\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n        for(var i = line.length - 1; i >= 0; --i) {\n          if (!isWhiteSpaceString(line[i])) {\n            last_valid.pos = i;\n            break;\n          }\n        }\n\n        return last_valid;\n\n      }\n\n      /*\n        Performs one iteration of traversal in reverse direction\n        Returns an index object of the new location\n       */\n      function reverse(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir,\n        }\n\n        var last_valid = {\n          ln: curr.ln,\n          pos: null,\n        };\n\n        var skip_empty_lines = (curr.line === \"\");\n\n        // Move one step to skip character we start on\n        nextChar(cm, curr);\n\n        while (curr.line !== null) {\n\n          if (curr.line === \"\" && !skip_empty_lines) {\n            if (last_valid.pos !== null) {\n              return last_valid;\n            }\n            else {\n              return { ln: curr.ln, pos: curr.pos };\n            }\n          }\n          else if (isEndOfSentenceSymbol(curr.line[curr.pos])\n              && last_valid.pos !== null\n              && !(curr.ln === last_valid.ln && curr.pos + 1 === last_valid.pos)) {\n            return last_valid;\n          }\n          else if (curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n            skip_empty_lines = false;\n            last_valid = { ln: curr.ln, pos: curr.pos }\n          }\n\n          nextChar(cm, curr);\n        }\n\n        /*\n          Set the position to the first non whitespace character on the last\n          valid line in the case that we reach the beginning of the document.\n        */\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n        for(var i = 0; i < line.length; ++i) {\n          if (!isWhiteSpaceString(line[i])) {\n            last_valid.pos = i;\n            break;\n          }\n        }\n        return last_valid;\n      }\n\n      var curr_index = {\n        ln: cur.line,\n        pos: cur.ch,\n      };\n\n      while (repeat > 0) {\n        if (dir < 0) {\n          curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        else {\n          curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        repeat--;\n      }\n\n      return Pos(curr_index.ln, curr_index.pos);\n    }\n\n    // TODO: perhaps this finagling of start and end positions belongs\n    // in codemirror/replaceRange?\n    function selectCompanionObject(cm, head, symb, inclusive) {\n      var cur = head, start, end;\n\n      var bracketRegexp = ({\n        '(': /[()]/, ')': /[()]/,\n        '[': /[[\\]]/, ']': /[[\\]]/,\n        '{': /[{}]/, '}': /[{}]/,\n        '<': /[<>]/, '>': /[<>]/})[symb];\n      var openSym = ({\n        '(': '(', ')': '(',\n        '[': '[', ']': '[',\n        '{': '{', '}': '{',\n        '<': '<', '>': '<'})[symb];\n      var curChar = cm.getLine(cur.line).charAt(cur.ch);\n      // Due to the behavior of scanForBracket, we need to add an offset if the\n      // cursor is on a matching open bracket.\n      var offset = curChar === openSym ? 1 : 0;\n\n      start = cm.scanForBracket(Pos(cur.line, cur.ch + offset), -1, undefined, {'bracketRegex': bracketRegexp});\n      end = cm.scanForBracket(Pos(cur.line, cur.ch + offset), 1, undefined, {'bracketRegex': bracketRegexp});\n\n      if (!start || !end) {\n        return { start: cur, end: cur };\n      }\n\n      start = start.pos;\n      end = end.pos;\n\n      if ((start.line == end.line && start.ch > end.ch)\n          || (start.line > end.line)) {\n        var tmp = start;\n        start = end;\n        end = tmp;\n      }\n\n      if (inclusive) {\n        end.ch += 1;\n      } else {\n        start.ch += 1;\n      }\n\n      return { start: start, end: end };\n    }\n\n    // Takes in a symbol and a cursor and tries to simulate text objects that\n    // have identical opening and closing symbols\n    // TODO support across multiple lines\n    function findBeginningAndEnd(cm, head, symb, inclusive) {\n      var cur = copyCursor(head);\n      var line = cm.getLine(cur.line);\n      var chars = line.split('');\n      var start, end, i, len;\n      var firstIndex = chars.indexOf(symb);\n\n      // the decision tree is to always look backwards for the beginning first,\n      // but if the cursor is in front of the first instance of the symb,\n      // then move the cursor forward\n      if (cur.ch < firstIndex) {\n        cur.ch = firstIndex;\n        // Why is this line even here???\n        // cm.setCursor(cur.line, firstIndex+1);\n      }\n      // otherwise if the cursor is currently on the closing symbol\n      else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\n        end = cur.ch; // assign end to the current cursor\n        --cur.ch; // make sure to look backwards\n      }\n\n      // if we're currently on the symbol, we've got a start\n      if (chars[cur.ch] == symb && !end) {\n        start = cur.ch + 1; // assign start to ahead of the cursor\n      } else {\n        // go backwards to find the start\n        for (i = cur.ch; i > -1 && !start; i--) {\n          if (chars[i] == symb) {\n            start = i + 1;\n          }\n        }\n      }\n\n      // look forwards for the end symbol\n      if (start && !end) {\n        for (i = start, len = chars.length; i < len && !end; i++) {\n          if (chars[i] == symb) {\n            end = i;\n          }\n        }\n      }\n\n      // nothing found\n      if (!start || !end) {\n        return { start: cur, end: cur };\n      }\n\n      // include the symbols\n      if (inclusive) {\n        --start; ++end;\n      }\n\n      return {\n        start: Pos(cur.line, start),\n        end: Pos(cur.line, end)\n      };\n    }\n\n    // Search functions\n    defineOption('pcre', true, 'boolean');\n    function SearchState() {}\n    SearchState.prototype = {\n      getQuery: function() {\n        return vimGlobalState.query;\n      },\n      setQuery: function(query) {\n        vimGlobalState.query = query;\n      },\n      getOverlay: function() {\n        return this.searchOverlay;\n      },\n      setOverlay: function(overlay) {\n        this.searchOverlay = overlay;\n      },\n      isReversed: function() {\n        return vimGlobalState.isReversed;\n      },\n      setReversed: function(reversed) {\n        vimGlobalState.isReversed = reversed;\n      },\n      getScrollbarAnnotate: function() {\n        return this.annotate;\n      },\n      setScrollbarAnnotate: function(annotate) {\n        this.annotate = annotate;\n      }\n    };\n    function getSearchState(cm) {\n      var vim = cm.state.vim;\n      return vim.searchState_ || (vim.searchState_ = new SearchState());\n    }\n    function splitBySlash(argString) {\n      return splitBySeparator(argString, '/');\n    }\n\n    function findUnescapedSlashes(argString) {\n      return findUnescapedSeparators(argString, '/');\n    }\n\n    function splitBySeparator(argString, separator) {\n      var slashes = findUnescapedSeparators(argString, separator) || [];\n      if (!slashes.length) return [];\n      var tokens = [];\n      // in case of strings like foo/bar\n      if (slashes[0] !== 0) return;\n      for (var i = 0; i < slashes.length; i++) {\n        if (typeof slashes[i] == 'number')\n          tokens.push(argString.substring(slashes[i] + 1, slashes[i+1]));\n      }\n      return tokens;\n    }\n\n    function findUnescapedSeparators(str, separator) {\n      if (!separator)\n        separator = '/';\n\n      var escapeNextChar = false;\n      var slashes = [];\n      for (var i = 0; i < str.length; i++) {\n        var c = str.charAt(i);\n        if (!escapeNextChar && c == separator) {\n          slashes.push(i);\n        }\n        escapeNextChar = !escapeNextChar && (c == '\\\\');\n      }\n      return slashes;\n    }\n\n    // Translates a search string from ex (vim) syntax into javascript form.\n    function translateRegex(str) {\n      // When these match, add a '\\' if unescaped or remove one if escaped.\n      var specials = '|(){';\n      // Remove, but never add, a '\\' for these.\n      var unescape = '}';\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i+1) || '';\n        var specialComesNext = (n && specials.indexOf(n) != -1);\n        if (escapeNextChar) {\n          if (c !== '\\\\' || !specialComesNext) {\n            out.push(c);\n          }\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            // Treat the unescape list as special for removing, but not adding '\\'.\n            if (n && unescape.indexOf(n) != -1) {\n              specialComesNext = true;\n            }\n            // Not passing this test means removing a '\\'.\n            if (!specialComesNext || n === '\\\\') {\n              out.push(c);\n            }\n          } else {\n            out.push(c);\n            if (specialComesNext && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n\n    // Translates the replace part of a search and replace from ex (vim) syntax into\n    // javascript form.  Similar to translateRegex, but additionally fixes back references\n    // (translates '\\[0..9]' to '$[0..9]') and follows different rules for escaping '$'.\n    var charUnescapes = {'\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t'};\n    function translateRegexReplace(str) {\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i+1) || '';\n        if (charUnescapes[c + n]) {\n          out.push(charUnescapes[c+n]);\n          i++;\n        } else if (escapeNextChar) {\n          // At any point in the loop, escapeNextChar is true if the previous\n          // character was a '\\' and was not escaped.\n          out.push(c);\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            if ((isNumber(n) || n === '$')) {\n              out.push('$');\n            } else if (n !== '/' && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          } else {\n            if (c === '$') {\n              out.push('$');\n            }\n            out.push(c);\n            if (n === '/') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n\n    // Unescape \\ and / in the replace part, for PCRE mode.\n    var unescapes = {'\\\\/': '/', '\\\\\\\\': '\\\\', '\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t', '\\\\&':'&'};\n    function unescapeRegexReplace(str) {\n      var stream = new CodeMirror.StringStream(str);\n      var output = [];\n      while (!stream.eol()) {\n        // Search for \\.\n        while (stream.peek() && stream.peek() != '\\\\') {\n          output.push(stream.next());\n        }\n        var matched = false;\n        for (var matcher in unescapes) {\n          if (stream.match(matcher, true)) {\n            matched = true;\n            output.push(unescapes[matcher]);\n            break;\n          }\n        }\n        if (!matched) {\n          // Don't change anything\n          output.push(stream.next());\n        }\n      }\n      return output.join('');\n    }\n\n    /**\n     * Extract the regular expression from the query and return a Regexp object.\n     * Returns null if the query is blank.\n     * If ignoreCase is passed in, the Regexp object will have the 'i' flag set.\n     * If smartCase is passed in, and the query contains upper case letters,\n     *   then ignoreCase is overridden, and the 'i' flag will not be set.\n     * If the query contains the /i in the flag part of the regular expression,\n     *   then both ignoreCase and smartCase are ignored, and 'i' will be passed\n     *   through to the Regex object.\n     */\n    function parseQuery(query, ignoreCase, smartCase) {\n      // First update the last search register\n      var lastSearchRegister = vimGlobalState.registerController.getRegister('/');\n      lastSearchRegister.setText(query);\n      // Check if the query is already a regex.\n      if (query instanceof RegExp) { return query; }\n      // First try to extract regex + flags from the input. If no flags found,\n      // extract just the regex. IE does not accept flags directly defined in\n      // the regex string in the form /regex/flags\n      var slashes = findUnescapedSlashes(query);\n      var regexPart;\n      var forceIgnoreCase;\n      if (!slashes.length) {\n        // Query looks like 'regexp'\n        regexPart = query;\n      } else {\n        // Query looks like 'regexp/...'\n        regexPart = query.substring(0, slashes[0]);\n        var flagsPart = query.substring(slashes[0]);\n        forceIgnoreCase = (flagsPart.indexOf('i') != -1);\n      }\n      if (!regexPart) {\n        return null;\n      }\n      if (!getOption('pcre')) {\n        regexPart = translateRegex(regexPart);\n      }\n      if (smartCase) {\n        ignoreCase = (/^[^A-Z]*$/).test(regexPart);\n      }\n      var regexp = new RegExp(regexPart,\n          (ignoreCase || forceIgnoreCase) ? 'im' : 'm');\n      return regexp;\n    }\n\n    /**\n     * dom - Document Object Manipulator\n     * Usage:\n     *   dom('<tag>'|<node>[, ...{<attributes>|<$styles>}|<child-node>|'<text>'])\n     * Examples:\n     *   dom('div', {id:'xyz'}, dom('p', 'CM rocks!', {$color:'red'}))\n     *   dom(document.head, dom('script', 'alert(\"hello!\")'))\n     * Not supported:\n     *   dom('p', ['arrays are objects'], Error('objects specify attributes'))\n     */\n    function dom(n) {\n      if (typeof n === 'string') n = document.createElement(n);\n      for (var a, i = 1; i < arguments.length; i++) {\n        if (!(a = arguments[i])) continue;\n        if (typeof a !== 'object') a = document.createTextNode(a);\n        if (a.nodeType) n.appendChild(a);\n        else for (var key in a) {\n          if (!Object.prototype.hasOwnProperty.call(a, key)) continue;\n          if (key[0] === '$') n.style[key.slice(1)] = a[key];\n          else n.setAttribute(key, a[key]);\n        }\n      }\n      return n;\n    }\n\n    function showConfirm(cm, template) {\n      var pre = dom('pre', {$color: 'red'}, template);\n      if (cm.openNotification) {\n        cm.openNotification(pre, {bottom: true, duration: 5000});\n      } else {\n        alert(pre.innerText);\n      }\n    }\n\n    function makePrompt(prefix, desc) {\n      return dom(document.createDocumentFragment(),\n               dom('span', {$fontFamily: 'monospace', $whiteSpace: 'pre'},\n                 prefix,\n                 dom('input', {type: 'text', autocorrect: 'off',\n                               autocapitalize: 'off', spellcheck: 'false'})),\n               desc && dom('span', {$color: '#888'}, desc));\n    }\n\n    function showPrompt(cm, options) {\n      var shortText = (options.prefix || '') + ' ' + (options.desc || '');\n      var template = makePrompt(options.prefix, options.desc);\n      if (cm.openDialog) {\n        cm.openDialog(template, options.onClose, {\n          onKeyDown: options.onKeyDown, onKeyUp: options.onKeyUp,\n          bottom: true, selectValueOnOpen: false, value: options.value\n        });\n      }\n      else {\n        options.onClose(prompt(shortText, ''));\n      }\n    }\n\n    function regexEqual(r1, r2) {\n      if (r1 instanceof RegExp && r2 instanceof RegExp) {\n          var props = ['global', 'multiline', 'ignoreCase', 'source'];\n          for (var i = 0; i < props.length; i++) {\n              var prop = props[i];\n              if (r1[prop] !== r2[prop]) {\n                  return false;\n              }\n          }\n          return true;\n      }\n      return false;\n    }\n    // Returns true if the query is valid.\n    function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {\n      if (!rawQuery) {\n        return;\n      }\n      var state = getSearchState(cm);\n      var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);\n      if (!query) {\n        return;\n      }\n      highlightSearchMatches(cm, query);\n      if (regexEqual(query, state.getQuery())) {\n        return query;\n      }\n      state.setQuery(query);\n      return query;\n    }\n    function searchOverlay(query) {\n      if (query.source.charAt(0) == '^') {\n        var matchSol = true;\n      }\n      return {\n        token: function(stream) {\n          if (matchSol && !stream.sol()) {\n            stream.skipToEnd();\n            return;\n          }\n          var match = stream.match(query, false);\n          if (match) {\n            if (match[0].length == 0) {\n              // Matched empty string, skip to next.\n              stream.next();\n              return 'searching';\n            }\n            if (!stream.sol()) {\n              // Backtrack 1 to match \\b\n              stream.backUp(1);\n              if (!query.exec(stream.next() + match[0])) {\n                stream.next();\n                return null;\n              }\n            }\n            stream.match(query);\n            return 'searching';\n          }\n          while (!stream.eol()) {\n            stream.next();\n            if (stream.match(query, false)) break;\n          }\n        },\n        query: query\n      };\n    }\n    var highlightTimeout = 0;\n    function highlightSearchMatches(cm, query) {\n      clearTimeout(highlightTimeout);\n      highlightTimeout = setTimeout(function() {\n        var searchState = getSearchState(cm);\n        var overlay = searchState.getOverlay();\n        if (!overlay || query != overlay.query) {\n          if (overlay) {\n            cm.removeOverlay(overlay);\n          }\n          overlay = searchOverlay(query);\n          cm.addOverlay(overlay);\n          if (cm.showMatchesOnScrollbar) {\n            if (searchState.getScrollbarAnnotate()) {\n              searchState.getScrollbarAnnotate().clear();\n            }\n            searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));\n          }\n          searchState.setOverlay(overlay);\n        }\n      }, 50);\n    }\n    function findNext(cm, prev, query, repeat) {\n      if (repeat === undefined) { repeat = 1; }\n      return cm.operation(function() {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n        for (var i = 0; i < repeat; i++) {\n          var found = cursor.find(prev);\n          if (i == 0 && found && cursorEqual(cursor.from(), pos)) {\n            var lastEndPos = prev ? cursor.from() : cursor.to();\n            found = cursor.find(prev);\n            if (found && !found[0] && cursorEqual(cursor.from(), lastEndPos)) {\n              if (cm.getLine(lastEndPos.line).length == lastEndPos.ch)\n                found = cursor.find(prev);\n            }\n          }\n          if (!found) {\n            // SearchCursor may have returned null because it hit EOF, wrap\n            // around and try again.\n            cursor = cm.getSearchCursor(query,\n                (prev) ? Pos(cm.lastLine()) : Pos(cm.firstLine(), 0) );\n            if (!cursor.find(prev)) {\n              return;\n            }\n          }\n        }\n        return cursor.from();\n      });\n    }\n    /**\n     * Pretty much the same as `findNext`, except for the following differences:\n     *\n     * 1. Before starting the search, move to the previous search. This way if our cursor is\n     * already inside a match, we should return the current match.\n     * 2. Rather than only returning the cursor's from, we return the cursor's from and to as a tuple.\n     */\n    function findNextFromAndToInclusive(cm, prev, query, repeat, vim) {\n      if (repeat === undefined) { repeat = 1; }\n      return cm.operation(function() {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n\n        // Go back one result to ensure that if the cursor is currently a match, we keep it.\n        var found = cursor.find(!prev);\n\n        // If we haven't moved, go back one more (similar to if i==0 logic in findNext).\n        if (!vim.visualMode && found && cursorEqual(cursor.from(), pos)) {\n          cursor.find(!prev);\n        }\n\n        for (var i = 0; i < repeat; i++) {\n          found = cursor.find(prev);\n          if (!found) {\n            // SearchCursor may have returned null because it hit EOF, wrap\n            // around and try again.\n            cursor = cm.getSearchCursor(query,\n                (prev) ? Pos(cm.lastLine()) : Pos(cm.firstLine(), 0) );\n            if (!cursor.find(prev)) {\n              return;\n            }\n          }\n        }\n        return [cursor.from(), cursor.to()];\n      });\n    }\n    function clearSearchHighlight(cm) {\n      var state = getSearchState(cm);\n      cm.removeOverlay(getSearchState(cm).getOverlay());\n      state.setOverlay(null);\n      if (state.getScrollbarAnnotate()) {\n        state.getScrollbarAnnotate().clear();\n        state.setScrollbarAnnotate(null);\n      }\n    }\n    /**\n     * Check if pos is in the specified range, INCLUSIVE.\n     * Range can be specified with 1 or 2 arguments.\n     * If the first range argument is an array, treat it as an array of line\n     * numbers. Match pos against any of the lines.\n     * If the first range argument is a number,\n     *   if there is only 1 range argument, check if pos has the same line\n     *       number\n     *   if there are 2 range arguments, then check if pos is in between the two\n     *       range arguments.\n     */\n    function isInRange(pos, start, end) {\n      if (typeof pos != 'number') {\n        // Assume it is a cursor position. Get the line number.\n        pos = pos.line;\n      }\n      if (start instanceof Array) {\n        return inArray(pos, start);\n      } else {\n        if (typeof end == 'number') {\n          return (pos >= start && pos <= end);\n        } else {\n          return pos == start;\n        }\n      }\n    }\n    function getUserVisibleLines(cm) {\n      var scrollInfo = cm.getScrollInfo();\n      var occludeToleranceTop = 6;\n      var occludeToleranceBottom = 10;\n      var from = cm.coordsChar({left:0, top: occludeToleranceTop + scrollInfo.top}, 'local');\n      var bottomY = scrollInfo.clientHeight - occludeToleranceBottom + scrollInfo.top;\n      var to = cm.coordsChar({left:0, top: bottomY}, 'local');\n      return {top: from.line, bottom: to.line};\n    }\n\n    function getMarkPos(cm, vim, markName) {\n      if (markName == '\\'' || markName == '`') {\n        return vimGlobalState.jumpList.find(cm, -1) || Pos(0, 0);\n      } else if (markName == '.') {\n        return getLastEditPos(cm);\n      }\n\n      var mark = vim.marks[markName];\n      return mark && mark.find();\n    }\n\n    function getLastEditPos(cm) {\n      var done = cm.doc.history.done;\n      for (var i = done.length; i--;) {\n        if (done[i].changes) {\n          return copyCursor(done[i].changes[0].to);\n        }\n      }\n    }\n\n    var ExCommandDispatcher = function() {\n      this.buildCommandMap_();\n    };\n    ExCommandDispatcher.prototype = {\n      processCommand: function(cm, input, opt_params) {\n        var that = this;\n        cm.operation(function () {\n          cm.curOp.isVimOp = true;\n          that._processCommand(cm, input, opt_params);\n        });\n      },\n      _processCommand: function(cm, input, opt_params) {\n        var vim = cm.state.vim;\n        var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');\n        var previousCommand = commandHistoryRegister.toString();\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n        var inputStream = new CodeMirror.StringStream(input);\n        // update \": with the latest command whether valid or invalid\n        commandHistoryRegister.setText(input);\n        var params = opt_params || {};\n        params.input = input;\n        try {\n          this.parseInput_(cm, inputStream, params);\n        } catch(e) {\n          showConfirm(cm, e.toString());\n          throw e;\n        }\n        var command;\n        var commandName;\n        if (!params.commandName) {\n          // If only a line range is defined, move to the line.\n          if (params.line !== undefined) {\n            commandName = 'move';\n          }\n        } else {\n          command = this.matchCommand_(params.commandName);\n          if (command) {\n            commandName = command.name;\n            if (command.excludeFromCommandHistory) {\n              commandHistoryRegister.setText(previousCommand);\n            }\n            this.parseCommandArgs_(inputStream, params, command);\n            if (command.type == 'exToKey') {\n              // Handle Ex to Key mapping.\n              for (var i = 0; i < command.toKeys.length; i++) {\n                CodeMirror.Vim.handleKey(cm, command.toKeys[i], 'mapping');\n              }\n              return;\n            } else if (command.type == 'exToEx') {\n              // Handle Ex to Ex mapping.\n              this.processCommand(cm, command.toInput);\n              return;\n            }\n          }\n        }\n        if (!commandName) {\n          showConfirm(cm, 'Not an editor command \":' + input + '\"');\n          return;\n        }\n        try {\n          exCommands[commandName](cm, params);\n          // Possibly asynchronous commands (e.g. substitute, which might have a\n          // user confirmation), are responsible for calling the callback when\n          // done. All others have it taken care of for them here.\n          if ((!command || !command.possiblyAsync) && params.callback) {\n            params.callback();\n          }\n        } catch(e) {\n          showConfirm(cm, e.toString());\n          throw e;\n        }\n      },\n      parseInput_: function(cm, inputStream, result) {\n        inputStream.eatWhile(':');\n        // Parse range.\n        if (inputStream.eat('%')) {\n          result.line = cm.firstLine();\n          result.lineEnd = cm.lastLine();\n        } else {\n          result.line = this.parseLineSpec_(cm, inputStream);\n          if (result.line !== undefined && inputStream.eat(',')) {\n            result.lineEnd = this.parseLineSpec_(cm, inputStream);\n          }\n        }\n\n        // Parse command name.\n        var commandMatch = inputStream.match(/^(\\w+|!!|@@|[!#&*<=>@~])/);\n        if (commandMatch) {\n          result.commandName = commandMatch[1];\n        } else {\n          result.commandName = inputStream.match(/.*/)[0];\n        }\n\n        return result;\n      },\n      parseLineSpec_: function(cm, inputStream) {\n        var numberMatch = inputStream.match(/^(\\d+)/);\n        if (numberMatch) {\n          // Absolute line number plus offset (N+M or N-M) is probably a typo,\n          // not something the user actually wanted. (NB: vim does allow this.)\n          return parseInt(numberMatch[1], 10) - 1;\n        }\n        switch (inputStream.next()) {\n          case '.':\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n          case '$':\n            return this.parseLineSpecOffset_(inputStream, cm.lastLine());\n          case '\\'':\n            var markName = inputStream.next();\n            var markPos = getMarkPos(cm, cm.state.vim, markName);\n            if (!markPos) throw new Error('Mark not set');\n            return this.parseLineSpecOffset_(inputStream, markPos.line);\n          case '-':\n          case '+':\n            inputStream.backUp(1);\n            // Offset is relative to current line if not otherwise specified.\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n          default:\n            inputStream.backUp(1);\n            return undefined;\n        }\n      },\n      parseLineSpecOffset_: function(inputStream, line) {\n        var offsetMatch = inputStream.match(/^([+-])?(\\d+)/);\n        if (offsetMatch) {\n          var offset = parseInt(offsetMatch[2], 10);\n          if (offsetMatch[1] == \"-\") {\n            line -= offset;\n          } else {\n            line += offset;\n          }\n        }\n        return line;\n      },\n      parseCommandArgs_: function(inputStream, params, command) {\n        if (inputStream.eol()) {\n          return;\n        }\n        params.argString = inputStream.match(/.*/)[0];\n        // Parse command-line arguments\n        var delim = command.argDelimiter || /\\s+/;\n        var args = trim(params.argString).split(delim);\n        if (args.length && args[0]) {\n          params.args = args;\n        }\n      },\n      matchCommand_: function(commandName) {\n        // Return the command in the command map that matches the shortest\n        // prefix of the passed in command name. The match is guaranteed to be\n        // unambiguous if the defaultExCommandMap's shortNames are set up\n        // correctly. (see @code{defaultExCommandMap}).\n        for (var i = commandName.length; i > 0; i--) {\n          var prefix = commandName.substring(0, i);\n          if (this.commandMap_[prefix]) {\n            var command = this.commandMap_[prefix];\n            if (command.name.indexOf(commandName) === 0) {\n              return command;\n            }\n          }\n        }\n        return null;\n      },\n      buildCommandMap_: function() {\n        this.commandMap_ = {};\n        for (var i = 0; i < defaultExCommandMap.length; i++) {\n          var command = defaultExCommandMap[i];\n          var key = command.shortName || command.name;\n          this.commandMap_[key] = command;\n        }\n      },\n      map: function(lhs, rhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\n          var commandName = lhs.substring(1);\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Ex to Ex mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToEx',\n              toInput: rhs.substring(1),\n              user: true\n            };\n          } else {\n            // Ex to key mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToKey',\n              toKeys: rhs,\n              user: true\n            };\n          }\n        } else {\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Key to Ex mapping.\n            var mapping = {\n              keys: lhs,\n              type: 'keyToEx',\n              exArgs: { input: rhs.substring(1) }\n            };\n            if (ctx) { mapping.context = ctx; }\n            defaultKeymap.unshift(mapping);\n          } else {\n            // Key to key mapping\n            var mapping = {\n              keys: lhs,\n              type: 'keyToKey',\n              toKeys: rhs\n            };\n            if (ctx) { mapping.context = ctx; }\n            defaultKeymap.unshift(mapping);\n          }\n        }\n      },\n      unmap: function(lhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          // Ex to Ex or Ex to key mapping\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\n          var commandName = lhs.substring(1);\n          if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {\n            delete this.commandMap_[commandName];\n            return;\n          }\n        } else {\n          // Key to Ex or key to key mapping\n          var keys = lhs;\n          for (var i = 0; i < defaultKeymap.length; i++) {\n            if (keys == defaultKeymap[i].keys\n                && defaultKeymap[i].context === ctx) {\n              defaultKeymap.splice(i, 1);\n              return;\n            }\n          }\n        }\n        throw Error('No such mapping.');\n      }\n    };\n\n    var exCommands = {\n      colorscheme: function(cm, params) {\n        if (!params.args || params.args.length < 1) {\n          showConfirm(cm, cm.getOption('theme'));\n          return;\n        }\n        cm.setOption('theme', params.args[0]);\n      },\n      map: function(cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 2) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx);\n      },\n      imap: function(cm, params) { this.map(cm, params, 'insert'); },\n      nmap: function(cm, params) { this.map(cm, params, 'normal'); },\n      vmap: function(cm, params) { this.map(cm, params, 'visual'); },\n      unmap: function(cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 1) {\n          if (cm) {\n            showConfirm(cm, 'No such mapping: ' + params.input);\n          }\n          return;\n        }\n        exCommandDispatcher.unmap(mapArgs[0], ctx);\n      },\n      move: function(cm, params) {\n        commandDispatcher.processCommand(cm, cm.state.vim, {\n            type: 'motion',\n            motion: 'moveToLineOrEdgeOfDocument',\n            motionArgs: { forward: false, explicitRepeat: true,\n              linewise: true },\n            repeatOverride: params.line+1});\n      },\n      set: function(cm, params) {\n        var setArgs = params.args;\n        // Options passed through to the setOption/getOption calls. May be passed in by the\n        // local/global versions of the set command\n        var setCfg = params.setCfg || {};\n        if (!setArgs || setArgs.length < 1) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        var expr = setArgs[0].split('=');\n        var optionName = expr[0];\n        var value = expr[1];\n        var forceGet = false;\n\n        if (optionName.charAt(optionName.length - 1) == '?') {\n          // If post-fixed with ?, then the set is actually a get.\n          if (value) { throw Error('Trailing characters: ' + params.argString); }\n          optionName = optionName.substring(0, optionName.length - 1);\n          forceGet = true;\n        }\n        if (value === undefined && optionName.substring(0, 2) == 'no') {\n          // To set boolean options to false, the option name is prefixed with\n          // 'no'.\n          optionName = optionName.substring(2);\n          value = false;\n        }\n\n        var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';\n        if (optionIsBoolean && value == undefined) {\n          // Calling set with a boolean option sets it to true.\n          value = true;\n        }\n        // If no value is provided, then we assume this is a get.\n        if (!optionIsBoolean && value === undefined || forceGet) {\n          var oldValue = getOption(optionName, cm, setCfg);\n          if (oldValue instanceof Error) {\n            showConfirm(cm, oldValue.message);\n          } else if (oldValue === true || oldValue === false) {\n            showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);\n          } else {\n            showConfirm(cm, '  ' + optionName + '=' + oldValue);\n          }\n        } else {\n          var setOptionReturn = setOption(optionName, value, cm, setCfg);\n          if (setOptionReturn instanceof Error) {\n            showConfirm(cm, setOptionReturn.message);\n          }\n        }\n      },\n      setlocal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {scope: 'local'};\n        this.set(cm, params);\n      },\n      setglobal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {scope: 'global'};\n        this.set(cm, params);\n      },\n      registers: function(cm, params) {\n        var regArgs = params.args;\n        var registers = vimGlobalState.registerController.registers;\n        var regInfo = '----------Registers----------\\n\\n';\n        if (!regArgs) {\n          for (var registerName in registers) {\n            var text = registers[registerName].toString();\n            if (text.length) {\n              regInfo += '\"' + registerName + '    ' + text + '\\n'\n            }\n          }\n        } else {\n          var registerName;\n          regArgs = regArgs.join('');\n          for (var i = 0; i < regArgs.length; i++) {\n            registerName = regArgs.charAt(i);\n            if (!vimGlobalState.registerController.isValidRegister(registerName)) {\n              continue;\n            }\n            var register = registers[registerName] || new Register();\n            regInfo += '\"' + registerName + '    ' + register.toString() + '\\n'\n          }\n        }\n        showConfirm(cm, regInfo);\n      },\n      sort: function(cm, params) {\n        var reverse, ignoreCase, unique, number, pattern;\n        function parseArgs() {\n          if (params.argString) {\n            var args = new CodeMirror.StringStream(params.argString);\n            if (args.eat('!')) { reverse = true; }\n            if (args.eol()) { return; }\n            if (!args.eatSpace()) { return 'Invalid arguments'; }\n            var opts = args.match(/([dinuox]+)?\\s*(\\/.+\\/)?\\s*/);\n            if (!opts && !args.eol()) { return 'Invalid arguments'; }\n            if (opts[1]) {\n              ignoreCase = opts[1].indexOf('i') != -1;\n              unique = opts[1].indexOf('u') != -1;\n              var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1 && 1;\n              var hex = opts[1].indexOf('x') != -1 && 1;\n              var octal = opts[1].indexOf('o') != -1 && 1;\n              if (decimal + hex + octal > 1) { return 'Invalid arguments'; }\n              number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';\n            }\n            if (opts[2]) {\n              pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '');\n            }\n          }\n        }\n        var err = parseArgs();\n        if (err) {\n          showConfirm(cm, err + ': ' + params.argString);\n          return;\n        }\n        var lineStart = params.line || cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        if (lineStart == lineEnd) { return; }\n        var curStart = Pos(lineStart, 0);\n        var curEnd = Pos(lineEnd, lineLength(cm, lineEnd));\n        var text = cm.getRange(curStart, curEnd).split('\\n');\n        var numberRegex = pattern ? pattern :\n           (number == 'decimal') ? /(-?)([\\d]+)/ :\n           (number == 'hex') ? /(-?)(?:0x)?([0-9a-f]+)/i :\n           (number == 'octal') ? /([0-7]+)/ : null;\n        var radix = (number == 'decimal') ? 10 : (number == 'hex') ? 16 : (number == 'octal') ? 8 : null;\n        var numPart = [], textPart = [];\n        if (number || pattern) {\n          for (var i = 0; i < text.length; i++) {\n            var matchPart = pattern ? text[i].match(pattern) : null;\n            if (matchPart && matchPart[0] != '') {\n              numPart.push(matchPart);\n            } else if (!pattern && numberRegex.exec(text[i])) {\n              numPart.push(text[i]);\n            } else {\n              textPart.push(text[i]);\n            }\n          }\n        } else {\n          textPart = text;\n        }\n        function compareFn(a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n          if (ignoreCase) { a = a.toLowerCase(); b = b.toLowerCase(); }\n          var anum = number && numberRegex.exec(a);\n          var bnum = number && numberRegex.exec(b);\n          if (!anum) { return a < b ? -1 : 1; }\n          anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);\n          bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);\n          return anum - bnum;\n        }\n        function comparePatternFn(a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n          if (ignoreCase) { a[0] = a[0].toLowerCase(); b[0] = b[0].toLowerCase(); }\n          return (a[0] < b[0]) ? -1 : 1;\n        }\n        numPart.sort(pattern ? comparePatternFn : compareFn);\n        if (pattern) {\n          for (var i = 0; i < numPart.length; i++) {\n            numPart[i] = numPart[i].input;\n          }\n        } else if (!number) { textPart.sort(compareFn); }\n        text = (!reverse) ? textPart.concat(numPart) : numPart.concat(textPart);\n        if (unique) { // Remove duplicate lines\n          var textOld = text;\n          var lastLine;\n          text = [];\n          for (var i = 0; i < textOld.length; i++) {\n            if (textOld[i] != lastLine) {\n              text.push(textOld[i]);\n            }\n            lastLine = textOld[i];\n          }\n        }\n        cm.replaceRange(text.join('\\n'), curStart, curEnd);\n      },\n      vglobal: function(cm, params) {\n        // global inspects params.commandName\n        this.global(cm, params);\n      },\n      global: function(cm, params) {\n        // a global command is of the form\n        // :[range]g/pattern/[cmd]\n        // argString holds the string /pattern/[cmd]\n        var argString = params.argString;\n        if (!argString) {\n          showConfirm(cm, 'Regular Expression missing from global');\n          return;\n        }\n        var inverted = params.commandName[0] === 'v';\n        // range is specified here\n        var lineStart = (params.line !== undefined) ? params.line : cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        // get the tokens from argString\n        var tokens = splitBySlash(argString);\n        var regexPart = argString, cmd;\n        if (tokens.length) {\n          regexPart = tokens[0];\n          cmd = tokens.slice(1, tokens.length).join('/');\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise\n          // use the regex part as the new query.\n          try {\n           updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n             true /** smartCase */);\n          } catch (e) {\n           showConfirm(cm, 'Invalid regex: ' + regexPart);\n           return;\n          }\n        }\n        // now that we have the regexPart, search for regex matches in the\n        // specified range of lines\n        var query = getSearchState(cm).getQuery();\n        var matchedLines = [];\n        for (var i = lineStart; i <= lineEnd; i++) {\n          var line = cm.getLineHandle(i);\n          var matched = query.test(line.text);\n          if (matched !== inverted) {\n            matchedLines.push(cmd ? line : line.text);\n          }\n        }\n        // if there is no [cmd], just display the list of matched lines\n        if (!cmd) {\n          showConfirm(cm, matchedLines.join('\\n'));\n          return;\n        }\n        var index = 0;\n        var nextCommand = function() {\n          if (index < matchedLines.length) {\n            var line = matchedLines[index++];\n            var lineNum = cm.getLineNumber(line);\n            if (lineNum == null) {\n              nextCommand();\n              return;\n            }\n            var command = (lineNum + 1) + cmd;\n            exCommandDispatcher.processCommand(cm, command, {\n              callback: nextCommand\n            });\n          }\n        };\n        nextCommand();\n      },\n      substitute: function(cm, params) {\n        if (!cm.getSearchCursor) {\n          throw new Error('Search feature not available. Requires searchcursor.js or ' +\n              'any other getSearchCursor implementation.');\n        }\n        var argString = params.argString;\n        var tokens = argString ? splitBySeparator(argString, argString[0]) : [];\n        var regexPart, replacePart = '', trailing, flagsPart, count;\n        var confirm = false; // Whether to confirm each replace.\n        var global = false; // True to replace all instances on a line, false to replace only 1.\n        if (tokens.length) {\n          regexPart = tokens[0];\n          if (getOption('pcre') && regexPart !== '') {\n              regexPart = new RegExp(regexPart).source; //normalize not escaped characters\n          }\n          replacePart = tokens[1];\n          if (replacePart !== undefined) {\n            if (getOption('pcre')) {\n              replacePart = unescapeRegexReplace(replacePart.replace(/([^\\\\])&/g,\"$1$$&\"));\n            } else {\n              replacePart = translateRegexReplace(replacePart);\n            }\n            vimGlobalState.lastSubstituteReplacePart = replacePart;\n          }\n          trailing = tokens[2] ? tokens[2].split(' ') : [];\n        } else {\n          // either the argString is empty or its of the form ' hello/world'\n          // actually splitBySlash returns a list of tokens\n          // only if the string starts with a '/'\n          if (argString && argString.length) {\n            showConfirm(cm, 'Substitutions should be of the form ' +\n                ':s/pattern/replace/');\n            return;\n          }\n        }\n        // After the 3rd slash, we can have flags followed by a space followed\n        // by count.\n        if (trailing) {\n          flagsPart = trailing[0];\n          count = parseInt(trailing[1]);\n          if (flagsPart) {\n            if (flagsPart.indexOf('c') != -1) {\n              confirm = true;\n            }\n            if (flagsPart.indexOf('g') != -1) {\n              global = true;\n            }\n            if (getOption('pcre')) {\n               regexPart = regexPart + '/' + flagsPart;\n            } else {\n               regexPart = regexPart.replace(/\\//g, \"\\\\/\") + '/' + flagsPart;\n            }\n          }\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise use\n          // the regex part as the new query.\n          try {\n            updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n              true /** smartCase */);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + regexPart);\n            return;\n          }\n        }\n        replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;\n        if (replacePart === undefined) {\n          showConfirm(cm, 'No previous substitute regular expression');\n          return;\n        }\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        var lineStart = (params.line !== undefined) ? params.line : cm.getCursor().line;\n        var lineEnd = params.lineEnd || lineStart;\n        if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {\n          lineEnd = Infinity;\n        }\n        if (count) {\n          lineStart = lineEnd;\n          lineEnd = lineStart + count - 1;\n        }\n        var startPos = clipCursorToContent(cm, Pos(lineStart, 0));\n        var cursor = cm.getSearchCursor(query, startPos);\n        doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);\n      },\n      redo: CodeMirror.commands.redo,\n      undo: CodeMirror.commands.undo,\n      write: function(cm) {\n        if (CodeMirror.commands.save) {\n          // If a save command is defined, call it.\n          CodeMirror.commands.save(cm);\n        } else if (cm.save) {\n          // Saves to text area if no save command is defined and cm.save() is available.\n          cm.save();\n        }\n      },\n      nohlsearch: function(cm) {\n        clearSearchHighlight(cm);\n      },\n      yank: function (cm) {\n        var cur = copyCursor(cm.getCursor());\n        var line = cur.line;\n        var lineText = cm.getLine(line);\n        vimGlobalState.registerController.pushText(\n          '0', 'yank', lineText, true, true);\n      },\n      delmarks: function(cm, params) {\n        if (!params.argString || !trim(params.argString)) {\n          showConfirm(cm, 'Argument required');\n          return;\n        }\n\n        var state = cm.state.vim;\n        var stream = new CodeMirror.StringStream(trim(params.argString));\n        while (!stream.eol()) {\n          stream.eatSpace();\n\n          // Record the streams position at the beginning of the loop for use\n          // in error messages.\n          var count = stream.pos;\n\n          if (!stream.match(/[a-zA-Z]/, false)) {\n            showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n            return;\n          }\n\n          var sym = stream.next();\n          // Check if this symbol is part of a range\n          if (stream.match('-', true)) {\n            // This symbol is part of a range.\n\n            // The range must terminate at an alphabetic character.\n            if (!stream.match(/[a-zA-Z]/, false)) {\n              showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n              return;\n            }\n\n            var startMark = sym;\n            var finishMark = stream.next();\n            // The range must terminate at an alphabetic character which\n            // shares the same case as the start of the range.\n            if (isLowerCase(startMark) && isLowerCase(finishMark) ||\n                isUpperCase(startMark) && isUpperCase(finishMark)) {\n              var start = startMark.charCodeAt(0);\n              var finish = finishMark.charCodeAt(0);\n              if (start >= finish) {\n                showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n                return;\n              }\n\n              // Because marks are always ASCII values, and we have\n              // determined that they are the same case, we can use\n              // their char codes to iterate through the defined range.\n              for (var j = 0; j <= finish - start; j++) {\n                var mark = String.fromCharCode(start + j);\n                delete state.marks[mark];\n              }\n            } else {\n              showConfirm(cm, 'Invalid argument: ' + startMark + '-');\n              return;\n            }\n          } else {\n            // This symbol is a valid mark, and is not part of a range.\n            delete state.marks[sym];\n          }\n        }\n      }\n    };\n\n    var exCommandDispatcher = new ExCommandDispatcher();\n\n    /**\n    * @param {CodeMirror} cm CodeMirror instance we are in.\n    * @param {boolean} confirm Whether to confirm each replace.\n    * @param {Cursor} lineStart Line to start replacing from.\n    * @param {Cursor} lineEnd Line to stop replacing at.\n    * @param {RegExp} query Query for performing matches with.\n    * @param {string} replaceWith Text to replace matches with. May contain $1,\n    *     $2, etc for replacing captured groups using JavaScript replace.\n    * @param {function()} callback A callback for when the replace is done.\n    */\n    function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query,\n        replaceWith, callback) {\n      // Set up all the functions.\n      cm.state.vim.exMode = true;\n      var done = false;\n      var lastPos, modifiedLineNumber, joined;\n      function replaceAll() {\n        cm.operation(function() {\n          while (!done) {\n            replace();\n            next();\n          }\n          stop();\n        });\n      }\n      function replace() {\n        var text = cm.getRange(searchCursor.from(), searchCursor.to());\n        var newText = text.replace(query, replaceWith);\n        var unmodifiedLineNumber = searchCursor.to().line;\n        searchCursor.replace(newText);\n        modifiedLineNumber = searchCursor.to().line;\n        lineEnd += modifiedLineNumber - unmodifiedLineNumber;\n        joined = modifiedLineNumber < unmodifiedLineNumber;\n      }\n      function findNextValidMatch() {\n        var lastMatchTo = lastPos && copyCursor(searchCursor.to());\n        var match = searchCursor.findNext();\n        if (match && !match[0] && lastMatchTo && cursorEqual(searchCursor.from(), lastMatchTo)) {\n          match = searchCursor.findNext();\n        }\n        return match;\n      }\n      function next() {\n        // The below only loops to skip over multiple occurrences on the same\n        // line when 'global' is not true.\n        while(findNextValidMatch() &&\n              isInRange(searchCursor.from(), lineStart, lineEnd)) {\n          if (!global && searchCursor.from().line == modifiedLineNumber && !joined) {\n            continue;\n          }\n          cm.scrollIntoView(searchCursor.from(), 30);\n          cm.setSelection(searchCursor.from(), searchCursor.to());\n          lastPos = searchCursor.from();\n          done = false;\n          return;\n        }\n        done = true;\n      }\n      function stop(close) {\n        if (close) { close(); }\n        cm.focus();\n        if (lastPos) {\n          cm.setCursor(lastPos);\n          var vim = cm.state.vim;\n          vim.exMode = false;\n          vim.lastHPos = vim.lastHSPos = lastPos.ch;\n        }\n        if (callback) { callback(); }\n      }\n      function onPromptKeyDown(e, _value, close) {\n        // Swallow all keys.\n        CodeMirror.e_stop(e);\n        var keyName = CodeMirror.keyName(e);\n        switch (keyName) {\n          case 'Y':\n            replace(); next(); break;\n          case 'N':\n            next(); break;\n          case 'A':\n            // replaceAll contains a call to close of its own. We don't want it\n            // to fire too early or multiple times.\n            var savedCallback = callback;\n            callback = undefined;\n            cm.operation(replaceAll);\n            callback = savedCallback;\n            break;\n          case 'L':\n            replace();\n            // fall through and exit.\n          case 'Q':\n          case 'Esc':\n          case 'Ctrl-C':\n          case 'Ctrl-[':\n            stop(close);\n            break;\n        }\n        if (done) { stop(close); }\n        return true;\n      }\n\n      // Actually do replace.\n      next();\n      if (done) {\n        showConfirm(cm, 'No matches for ' + query.source);\n        return;\n      }\n      if (!confirm) {\n        replaceAll();\n        if (callback) { callback(); }\n        return;\n      }\n      showPrompt(cm, {\n        prefix: dom('span', 'replace with ', dom('strong', replaceWith), ' (y/n/a/q/l)'),\n        onKeyDown: onPromptKeyDown\n      });\n    }\n\n    CodeMirror.keyMap.vim = {\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function exitInsertMode(cm) {\n      var vim = cm.state.vim;\n      var macroModeState = vimGlobalState.macroModeState;\n      var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');\n      var isPlaying = macroModeState.isPlaying;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (!isPlaying) {\n        cm.off('change', onChange);\n        CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n      }\n      if (!isPlaying && vim.insertModeRepeat > 1) {\n        // Perform insert mode repeat for commands like 3,a and 3,o.\n        repeatLastEdit(cm, vim, vim.insertModeRepeat - 1,\n            true /** repeatForInsert */);\n        vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;\n      }\n      delete vim.insertModeRepeat;\n      vim.insertMode = false;\n      cm.setCursor(cm.getCursor().line, cm.getCursor().ch-1);\n      cm.setOption('keyMap', 'vim');\n      cm.setOption('disableInput', true);\n      cm.toggleOverwrite(false); // exit replace mode if we were in it.\n      // update the \". register before exiting insert mode\n      insertModeChangeRegister.setText(lastChange.changes.join(''));\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      if (macroModeState.isRecording) {\n        logInsertModeChange(macroModeState);\n      }\n    }\n\n    function _mapCommand(command) {\n      defaultKeymap.unshift(command);\n    }\n\n    function mapCommand(keys, type, name, args, extra) {\n      var command = {keys: keys, type: type};\n      command[type] = name;\n      command[type + \"Args\"] = args;\n      for (var key in extra)\n        command[key] = extra[key];\n      _mapCommand(command);\n    }\n\n    // The timeout in milliseconds for the two-character ESC keymap should be\n    // adjusted according to your typing speed to prevent false positives.\n    defineOption('insertModeEscKeysTimeout', 200, 'number');\n\n    CodeMirror.keyMap['vim-insert'] = {\n      // TODO: override navigation keys so that Esc will cancel automatic\n      // indentation from o, O, i_<CR>\n      fallthrough: ['default'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    CodeMirror.keyMap['vim-replace'] = {\n      'Backspace': 'goCharLeft',\n      fallthrough: ['vim-insert'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function executeMacroRegister(cm, vim, macroModeState, registerName) {\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (registerName == ':') {\n        // Read-only register containing last Ex command.\n        if (register.keyBuffer[0]) {\n          exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);\n        }\n        macroModeState.isPlaying = false;\n        return;\n      }\n      var keyBuffer = register.keyBuffer;\n      var imc = 0;\n      macroModeState.isPlaying = true;\n      macroModeState.replaySearchQueries = register.searchQueries.slice(0);\n      for (var i = 0; i < keyBuffer.length; i++) {\n        var text = keyBuffer[i];\n        var match, key;\n        while (text) {\n          // Pull off one command key, which is either a single character\n          // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n          match = (/<\\w+-.+?>|<\\w+>|./).exec(text);\n          key = match[0];\n          text = text.substring(match.index + key.length);\n          CodeMirror.Vim.handleKey(cm, key, 'macro');\n          if (vim.insertMode) {\n            var changes = register.insertModeChanges[imc++].changes;\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes =\n                changes;\n            repeatInsertModeChanges(cm, changes, 1);\n            exitInsertMode(cm);\n          }\n        }\n      }\n      macroModeState.isPlaying = false;\n    }\n\n    function logKey(macroModeState, key) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register) {\n        register.pushText(key);\n      }\n    }\n\n    function logInsertModeChange(macroModeState) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushInsertModeChanges) {\n        register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);\n      }\n    }\n\n    function logSearchQuery(macroModeState, query) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushSearchQuery) {\n        register.pushSearchQuery(query);\n      }\n    }\n\n    /**\n     * Listens for changes made in insert mode.\n     * Should only be active in insert mode.\n     */\n    function onChange(cm, changeObj) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (!macroModeState.isPlaying) {\n        while(changeObj) {\n          lastChange.expectCursorActivityForChange = true;\n          if (lastChange.ignoreCount > 1) {\n            lastChange.ignoreCount--;\n          } else if (changeObj.origin == '+input' || changeObj.origin == 'paste'\n              || changeObj.origin === undefined /* only in testing */) {\n            var selectionCount = cm.listSelections().length;\n            if (selectionCount > 1)\n              lastChange.ignoreCount = selectionCount;\n            var text = changeObj.text.join('\\n');\n            if (lastChange.maybeReset) {\n              lastChange.changes = [];\n              lastChange.maybeReset = false;\n            }\n            if (text) {\n              if (cm.state.overwrite && !/\\n/.test(text)) {\n                lastChange.changes.push([text]);\n              } else {\n                lastChange.changes.push(text);\n              }\n            }\n          }\n          // Change objects may be chained with next.\n          changeObj = changeObj.next;\n        }\n      }\n    }\n\n    /**\n    * Listens for any kind of cursor activity on CodeMirror.\n    */\n    function onCursorActivity(cm) {\n      var vim = cm.state.vim;\n      if (vim.insertMode) {\n        // Tracking cursor activity in insert mode (for macro support).\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) { return; }\n        var lastChange = macroModeState.lastInsertModeChanges;\n        if (lastChange.expectCursorActivityForChange) {\n          lastChange.expectCursorActivityForChange = false;\n        } else {\n          // Cursor moved outside the context of an edit. Reset the change.\n          lastChange.maybeReset = true;\n        }\n      } else if (!cm.curOp.isVimOp) {\n        handleExternalSelection(cm, vim);\n      }\n      if (vim.visualMode) {\n        updateFakeCursor(cm);\n      }\n    }\n    /**\n     * Keeps track of a fake cursor to support visual mode cursor behavior.\n     */\n    function updateFakeCursor(cm) {\n      var className = 'cm-animate-fat-cursor';\n      var vim = cm.state.vim;\n      var from = clipCursorToContent(cm, copyCursor(vim.sel.head));\n      var to = offsetCursor(from, 0, 1);\n      clearFakeCursor(vim);\n      // In visual mode, the cursor may be positioned over EOL.\n      if (from.ch == cm.getLine(from.line).length) {\n        var widget = dom('span', { 'class': className }, '\\u00a0');\n        vim.fakeCursorBookmark = cm.setBookmark(from, {widget: widget});\n      } else {\n        vim.fakeCursor = cm.markText(from, to, {className: className});\n      }\n    }\n    function clearFakeCursor(vim) {\n      if (vim.fakeCursor) {\n        vim.fakeCursor.clear();\n        vim.fakeCursor = null;\n      }\n      if (vim.fakeCursorBookmark) {\n        vim.fakeCursorBookmark.clear();\n        vim.fakeCursorBookmark = null;\n      }\n    }\n    function handleExternalSelection(cm, vim) {\n      var anchor = cm.getCursor('anchor');\n      var head = cm.getCursor('head');\n      // Enter or exit visual mode to match mouse selection.\n      if (vim.visualMode && !cm.somethingSelected()) {\n        exitVisualMode(cm, false);\n      } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {\n        vim.visualMode = true;\n        vim.visualLine = false;\n        CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\"});\n      }\n      if (vim.visualMode) {\n        // Bind CodeMirror selection model to vim selection model.\n        // Mouse selections are considered visual characterwise.\n        var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n        var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n        head = offsetCursor(head, 0, headOffset);\n        anchor = offsetCursor(anchor, 0, anchorOffset);\n        vim.sel = {\n          anchor: anchor,\n          head: head\n        };\n        updateMark(cm, vim, '<', cursorMin(head, anchor));\n        updateMark(cm, vim, '>', cursorMax(head, anchor));\n      } else if (!vim.insertMode) {\n        // Reset lastHPos if selection was modified by something outside of vim mode e.g. by mouse.\n        vim.lastHPos = cm.getCursor().ch;\n      }\n    }\n\n    /** Wrapper for special keys pressed in insert mode */\n    function InsertModeKey(keyName) {\n      this.keyName = keyName;\n    }\n\n    /**\n    * Handles raw key down events from the text area.\n    * - Should only be active in insert mode.\n    * - For recording deletes in insert mode.\n    */\n    function onKeyEventTargetKeyDown(e) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      var keyName = CodeMirror.keyName(e);\n      if (!keyName) { return; }\n      function onKeyFound() {\n        if (lastChange.maybeReset) {\n          lastChange.changes = [];\n          lastChange.maybeReset = false;\n        }\n        lastChange.changes.push(new InsertModeKey(keyName));\n        return true;\n      }\n      if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {\n        CodeMirror.lookupKey(keyName, 'vim-insert', onKeyFound);\n      }\n    }\n\n    /**\n     * Repeats the last edit, which includes exactly 1 command and at most 1\n     * insert. Operator and motion commands are read from lastEditInputState,\n     * while action commands are read from lastEditActionCommand.\n     *\n     * If repeatForInsert is true, then the function was called by\n     * exitInsertMode to repeat the insert mode changes the user just made. The\n     * corresponding enterInsertMode call was made with a count.\n     */\n    function repeatLastEdit(cm, vim, repeat, repeatForInsert) {\n      var macroModeState = vimGlobalState.macroModeState;\n      macroModeState.isPlaying = true;\n      var isAction = !!vim.lastEditActionCommand;\n      var cachedInputState = vim.inputState;\n      function repeatCommand() {\n        if (isAction) {\n          commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);\n        } else {\n          commandDispatcher.evalInput(cm, vim);\n        }\n      }\n      function repeatInsert(repeat) {\n        if (macroModeState.lastInsertModeChanges.changes.length > 0) {\n          // For some reason, repeat cw in desktop VIM does not repeat\n          // insert mode changes. Will conform to that behavior.\n          repeat = !vim.lastEditActionCommand ? 1 : repeat;\n          var changeObject = macroModeState.lastInsertModeChanges;\n          repeatInsertModeChanges(cm, changeObject.changes, repeat);\n        }\n      }\n      vim.inputState = vim.lastEditInputState;\n      if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {\n        // o and O repeat have to be interlaced with insert repeats so that the\n        // insertions appear on separate lines instead of the last line.\n        for (var i = 0; i < repeat; i++) {\n          repeatCommand();\n          repeatInsert(1);\n        }\n      } else {\n        if (!repeatForInsert) {\n          // Hack to get the cursor to end up at the right place. If I is\n          // repeated in insert mode repeat, cursor will be 1 insert\n          // change set left of where it should be.\n          repeatCommand();\n        }\n        repeatInsert(repeat);\n      }\n      vim.inputState = cachedInputState;\n      if (vim.insertMode && !repeatForInsert) {\n        // Don't exit insert mode twice. If repeatForInsert is set, then we\n        // were called by an exitInsertMode call lower on the stack.\n        exitInsertMode(cm);\n      }\n      macroModeState.isPlaying = false;\n    }\n\n    function repeatInsertModeChanges(cm, changes, repeat) {\n      function keyHandler(binding) {\n        if (typeof binding == 'string') {\n          CodeMirror.commands[binding](cm);\n        } else {\n          binding(cm);\n        }\n        return true;\n      }\n      var head = cm.getCursor('head');\n      var visualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.visualBlock;\n      if (visualBlock) {\n        // Set up block selection again for repeating the changes.\n        selectForInsert(cm, head, visualBlock + 1);\n        repeat = cm.listSelections().length;\n        cm.setCursor(head);\n      }\n      for (var i = 0; i < repeat; i++) {\n        if (visualBlock) {\n          cm.setCursor(offsetCursor(head, i, 0));\n        }\n        for (var j = 0; j < changes.length; j++) {\n          var change = changes[j];\n          if (change instanceof InsertModeKey) {\n            CodeMirror.lookupKey(change.keyName, 'vim-insert', keyHandler);\n          } else if (typeof change == \"string\") {\n            var cur = cm.getCursor();\n            cm.replaceRange(change, cur, cur);\n          } else {\n            var start = cm.getCursor();\n            var end = offsetCursor(start, 0, change[0].length);\n            cm.replaceRange(change[0], start, end);\n          }\n        }\n      }\n      if (visualBlock) {\n        cm.setCursor(offsetCursor(head, 0, 1));\n      }\n    }\n\n    resetVimGlobalState();\n    return vimApi;\n  };\n  // Initialize Vim and make it available as an API.\n  CodeMirror.Vim = Vim();\n});\n"]},"metadata":{},"sourceType":"script"}